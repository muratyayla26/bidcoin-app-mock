{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.CryptoKeypath = void 0;\nconst lib_1 = require(\"./lib\");\nconst PathComponent_1 = require(\"./PathComponent\");\nconst RegistryItem_1 = require(\"./RegistryItem\");\nconst RegistryType_1 = require(\"./RegistryType\");\nvar Keys;\n(function (Keys) {\n  Keys[Keys[\"components\"] = 1] = \"components\";\n  Keys[Keys[\"source_fingerprint\"] = 2] = \"source_fingerprint\";\n  Keys[Keys[\"depth\"] = 3] = \"depth\";\n})(Keys || (Keys = {}));\nclass CryptoKeypath extends RegistryItem_1.RegistryItem {\n  constructor() {\n    let components = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n    let sourceFingerprint = arguments.length > 1 ? arguments[1] : undefined;\n    let depth = arguments.length > 2 ? arguments[2] : undefined;\n    super();\n    this.components = components;\n    this.sourceFingerprint = sourceFingerprint;\n    this.depth = depth;\n    this.getRegistryType = () => {\n      return RegistryType_1.RegistryTypes.CRYPTO_KEYPATH;\n    };\n    this.getPath = () => {\n      if (this.components.length === 0) {\n        return undefined;\n      }\n      const components = this.components.map(component => {\n        return `${component.isWildcard() ? '*' : component.getIndex()}${component.isHardened() ? \"'\" : ''}`;\n      });\n      return components.join('/');\n    };\n    this.getComponents = () => this.components;\n    this.getSourceFingerprint = () => this.sourceFingerprint;\n    this.getDepth = () => this.depth;\n    this.toDataItem = () => {\n      const map = {};\n      const components = [];\n      this.components && this.components.forEach(component => {\n        if (component.isWildcard()) {\n          components.push([]);\n        } else {\n          components.push(component.getIndex());\n        }\n        components.push(component.isHardened());\n      });\n      map[Keys.components] = components;\n      if (this.sourceFingerprint) {\n        map[Keys.source_fingerprint] = this.sourceFingerprint.readUInt32BE(0);\n      }\n      if (this.depth !== undefined) {\n        map[Keys.depth] = this.depth;\n      }\n      return new lib_1.DataItem(map);\n    };\n  }\n}\nexports.CryptoKeypath = CryptoKeypath;\nCryptoKeypath.fromDataItem = dataItem => {\n  const map = dataItem.getData();\n  const pathComponents = [];\n  const components = map[Keys.components];\n  if (components) {\n    for (let i = 0; i < components.length; i += 2) {\n      const isHardened = components[i + 1];\n      const path = components[i];\n      if (typeof path === 'number') {\n        pathComponents.push(new PathComponent_1.PathComponent({\n          index: path,\n          hardened: isHardened\n        }));\n      } else {\n        pathComponents.push(new PathComponent_1.PathComponent({\n          hardened: isHardened\n        }));\n      }\n    }\n  }\n  const _sourceFingerprint = map[Keys.source_fingerprint];\n  let sourceFingerprint;\n  if (_sourceFingerprint) {\n    sourceFingerprint = Buffer.alloc(4);\n    sourceFingerprint.writeUInt32BE(_sourceFingerprint, 0);\n  }\n  const depth = map[Keys.depth];\n  return new CryptoKeypath(pathComponents, sourceFingerprint, depth);\n};\nCryptoKeypath.fromCBOR = _cborPayload => {\n  const dataItem = lib_1.decodeToDataItem(_cborPayload);\n  return CryptoKeypath.fromDataItem(dataItem);\n};","map":{"version":3,"names":["lib_1","require","PathComponent_1","RegistryItem_1","RegistryType_1","Keys","CryptoKeypath","RegistryItem","constructor","components","arguments","length","undefined","sourceFingerprint","depth","getRegistryType","RegistryTypes","CRYPTO_KEYPATH","getPath","map","component","isWildcard","getIndex","isHardened","join","getComponents","getSourceFingerprint","getDepth","toDataItem","forEach","push","source_fingerprint","readUInt32BE","DataItem","exports","fromDataItem","dataItem","getData","pathComponents","i","path","PathComponent","index","hardened","_sourceFingerprint","Buffer","alloc","writeUInt32BE","fromCBOR","_cborPayload","decodeToDataItem"],"sources":["C:\\Users\\Administrator\\solana-wallet-app\\node_modules\\@keystonehq\\bc-ur-registry\\src\\CryptoKeypath.ts"],"sourcesContent":["import { decodeToDataItem, DataItem } from './lib';\nimport { PathComponent } from './PathComponent';\nimport { RegistryItem } from './RegistryItem';\nimport { RegistryTypes } from './RegistryType';\nimport { DataItemMap } from './types';\n\nenum Keys {\n  components = 1,\n  source_fingerprint,\n  depth,\n}\n\nexport class CryptoKeypath extends RegistryItem {\n  getRegistryType = () => {\n    return RegistryTypes.CRYPTO_KEYPATH;\n  };\n\n  constructor(\n    private components: PathComponent[] = [],\n    private sourceFingerprint?: Buffer,\n    private depth?: number,\n  ) {\n    super();\n  }\n\n  public getPath = () => {\n    if (this.components.length === 0) {\n      return undefined;\n    }\n\n    const components = this.components.map((component) => {\n      return `${component.isWildcard() ? '*' : component.getIndex()}${\n        component.isHardened() ? \"'\" : ''\n      }`;\n    });\n    return components.join('/');\n  };\n\n  public getComponents = () => this.components;\n  public getSourceFingerprint = () => this.sourceFingerprint;\n  public getDepth = () => this.depth;\n\n  toDataItem = () => {\n    const map: DataItemMap = {};\n    const components: (number | boolean | any[])[] = [];\n    this.components &&\n      this.components.forEach((component) => {\n        if (component.isWildcard()) {\n          components.push([]);\n        } else {\n          components.push(component.getIndex() as number);\n        }\n        components.push(component.isHardened());\n      });\n    map[Keys.components] = components;\n    if (this.sourceFingerprint) {\n      map[Keys.source_fingerprint] = this.sourceFingerprint.readUInt32BE(0);\n    }\n    if (this.depth !== undefined) {\n      map[Keys.depth] = this.depth;\n    }\n    return new DataItem(map);\n  };\n\n  static fromDataItem = (dataItem: DataItem) => {\n    const map: Record<string, any> = dataItem.getData();\n    const pathComponents: PathComponent[] = [];\n    const components = map[Keys.components] as any[];\n    if (components) {\n      for (let i = 0; i < components.length; i += 2) {\n        const isHardened = components[i + 1];\n        const path = components[i];\n        if (typeof path === 'number') {\n          pathComponents.push(\n            new PathComponent({ index: path, hardened: isHardened }),\n          );\n        } else {\n          pathComponents.push(new PathComponent({ hardened: isHardened }));\n        }\n      }\n    }\n    const _sourceFingerprint = map[Keys.source_fingerprint];\n    let sourceFingerprint: Buffer | undefined;\n    if (_sourceFingerprint) {\n      sourceFingerprint = Buffer.alloc(4);\n      sourceFingerprint.writeUInt32BE(_sourceFingerprint, 0);\n    }\n    const depth = map[Keys.depth];\n    return new CryptoKeypath(pathComponents, sourceFingerprint, depth);\n  };\n\n  public static fromCBOR = (_cborPayload: Buffer) => {\n    const dataItem = decodeToDataItem(_cborPayload);\n    return CryptoKeypath.fromDataItem(dataItem);\n  };\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}