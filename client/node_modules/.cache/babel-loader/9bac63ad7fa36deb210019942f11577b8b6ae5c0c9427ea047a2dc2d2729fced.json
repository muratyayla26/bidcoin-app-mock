{"ast":null,"code":"/**\n * Utility function that works like `Object.apply`, but copies getters and setters properly as well.  Additionally gives\n * the option to exclude properties by name.\n */\nconst copyProps = function (dest, src) {\n  let exclude = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n  const props = Object.getOwnPropertyDescriptors(src);\n  for (let prop of exclude) delete props[prop];\n  Object.defineProperties(dest, props);\n};\n/**\n * Returns the full chain of prototypes up until Object.prototype given a starting object.  The order of prototypes will\n * be closest to farthest in the chain.\n */\nconst protoChain = function (obj) {\n  let currentChain = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [obj];\n  const proto = Object.getPrototypeOf(obj);\n  if (proto === null) return currentChain;\n  return protoChain(proto, [...currentChain, proto]);\n};\n/**\n * Identifies the nearest ancestor common to all the given objects in their prototype chains.  For most unrelated\n * objects, this function should return Object.prototype.\n */\nconst nearestCommonProto = function () {\n  for (var _len = arguments.length, objs = new Array(_len), _key = 0; _key < _len; _key++) {\n    objs[_key] = arguments[_key];\n  }\n  if (objs.length === 0) return undefined;\n  let commonProto = undefined;\n  const protoChains = objs.map(obj => protoChain(obj));\n  while (protoChains.every(protoChain => protoChain.length > 0)) {\n    const protos = protoChains.map(protoChain => protoChain.pop());\n    const potentialCommonProto = protos[0];\n    if (protos.every(proto => proto === potentialCommonProto)) commonProto = potentialCommonProto;else break;\n  }\n  return commonProto;\n};\n/**\n * Creates a new prototype object that is a mixture of the given prototypes.  The mixing is achieved by first\n * identifying the nearest common ancestor and using it as the prototype for a new object.  Then all properties/methods\n * downstream of this prototype (ONLY downstream) are copied into the new object.\n *\n * The resulting prototype is more performant than softMixProtos(...), as well as ES5 compatible.  However, it's not as\n * flexible as updates to the source prototypes aren't captured by the mixed result.  See softMixProtos for why you may\n * want to use that instead.\n */\nconst hardMixProtos = function (ingredients, constructor) {\n  let exclude = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n  var _a;\n  const base = (_a = nearestCommonProto(...ingredients)) !== null && _a !== void 0 ? _a : Object.prototype;\n  const mixedProto = Object.create(base);\n  // Keeps track of prototypes we've already visited to avoid copying the same properties multiple times.  We init the\n  // list with the proto chain below the nearest common ancestor because we don't want any of those methods mixed in\n  // when they will already be accessible via prototype access.\n  const visitedProtos = protoChain(base);\n  for (let prototype of ingredients) {\n    let protos = protoChain(prototype);\n    // Apply the prototype chain in reverse order so that old methods don't override newer ones.\n    for (let i = protos.length - 1; i >= 0; i--) {\n      let newProto = protos[i];\n      if (visitedProtos.indexOf(newProto) === -1) {\n        copyProps(mixedProto, newProto, ['constructor', ...exclude]);\n        visitedProtos.push(newProto);\n      }\n    }\n  }\n  mixedProto.constructor = constructor;\n  return mixedProto;\n};\nconst unique = arr => arr.filter((e, i) => arr.indexOf(e) == i);\n\n/**\n * Finds the ingredient with the given prop, searching in reverse order and breadth-first if searching ingredient\n * prototypes is required.\n */\nconst getIngredientWithProp = (prop, ingredients) => {\n  const protoChains = ingredients.map(ingredient => protoChain(ingredient));\n  // since we search breadth-first, we need to keep track of our depth in the prototype chains\n  let protoDepth = 0;\n  // not all prototype chains are the same depth, so this remains true as long as at least one of the ingredients'\n  // prototype chains has an object at this depth\n  let protosAreLeftToSearch = true;\n  while (protosAreLeftToSearch) {\n    // with the start of each horizontal slice, we assume this is the one that's deeper than any of the proto chains\n    protosAreLeftToSearch = false;\n    // scan through the ingredients right to left\n    for (let i = ingredients.length - 1; i >= 0; i--) {\n      const searchTarget = protoChains[i][protoDepth];\n      if (searchTarget !== undefined && searchTarget !== null) {\n        // if we find something, this is proof that this horizontal slice potentially more objects to search\n        protosAreLeftToSearch = true;\n        // eureka, we found it\n        if (Object.getOwnPropertyDescriptor(searchTarget, prop) != undefined) {\n          return protoChains[i][0];\n        }\n      }\n    }\n    protoDepth++;\n  }\n  return undefined;\n};\n/**\n * \"Mixes\" ingredients by wrapping them in a Proxy.  The optional prototype argument allows the mixed object to sit\n * downstream of an existing prototype chain.  Note that \"properties\" cannot be added, deleted, or modified.\n */\nconst proxyMix = function (ingredients) {\n  let prototype = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Object.prototype;\n  return new Proxy({}, {\n    getPrototypeOf() {\n      return prototype;\n    },\n    setPrototypeOf() {\n      throw Error('Cannot set prototype of Proxies created by ts-mixer');\n    },\n    getOwnPropertyDescriptor(_, prop) {\n      return Object.getOwnPropertyDescriptor(getIngredientWithProp(prop, ingredients) || {}, prop);\n    },\n    defineProperty() {\n      throw new Error('Cannot define new properties on Proxies created by ts-mixer');\n    },\n    has(_, prop) {\n      return getIngredientWithProp(prop, ingredients) !== undefined || prototype[prop] !== undefined;\n    },\n    get(_, prop) {\n      return (getIngredientWithProp(prop, ingredients) || prototype)[prop];\n    },\n    set(_, prop, val) {\n      const ingredientWithProp = getIngredientWithProp(prop, ingredients);\n      if (ingredientWithProp === undefined) throw new Error('Cannot set new properties on Proxies created by ts-mixer');\n      ingredientWithProp[prop] = val;\n      return true;\n    },\n    deleteProperty() {\n      throw new Error('Cannot delete properties on Proxies created by ts-mixer');\n    },\n    ownKeys() {\n      return ingredients.map(Object.getOwnPropertyNames).reduce((prev, curr) => curr.concat(prev.filter(key => curr.indexOf(key) < 0)));\n    }\n  });\n};\n/**\n * Creates a new proxy-prototype object that is a \"soft\" mixture of the given prototypes.  The mixing is achieved by\n * proxying all property access to the ingredients.  This is not ES5 compatible and less performant.  However, any\n * changes made to the source prototypes will be reflected in the proxy-prototype, which may be desirable.\n */\nconst softMixProtos = (ingredients, constructor) => proxyMix([...ingredients, {\n  constructor\n}]);\nconst settings = {\n  initFunction: null,\n  staticsStrategy: 'copy',\n  prototypeStrategy: 'copy',\n  decoratorInheritance: 'deep'\n};\n\n// Keeps track of constituent classes for every mixin class created by ts-mixer.\nconst mixins = new WeakMap();\nconst getMixinsForClass = clazz => mixins.get(clazz);\nconst registerMixins = (mixedClass, constituents) => mixins.set(mixedClass, constituents);\nconst hasMixin = (instance, mixin) => {\n  if (instance instanceof mixin) return true;\n  const constructor = instance.constructor;\n  const visited = new Set();\n  let frontier = new Set();\n  frontier.add(constructor);\n  while (frontier.size > 0) {\n    // check if the frontier has the mixin we're looking for.  if not, we can say we visited every item in the frontier\n    if (frontier.has(mixin)) return true;\n    frontier.forEach(item => visited.add(item));\n    // build a new frontier based on the associated mixin classes and prototype chains of each frontier item\n    const newFrontier = new Set();\n    frontier.forEach(item => {\n      var _a;\n      const itemConstituents = (_a = mixins.get(item)) !== null && _a !== void 0 ? _a : protoChain(item.prototype).map(proto => proto.constructor).filter(item => item !== null);\n      if (itemConstituents) itemConstituents.forEach(constituent => {\n        if (!visited.has(constituent) && !frontier.has(constituent)) newFrontier.add(constituent);\n      });\n    });\n    // we have a new frontier, now search again\n    frontier = newFrontier;\n  }\n  // if we get here, we couldn't find the mixin anywhere in the prototype chain or associated mixin classes\n  return false;\n};\nconst mergeObjectsOfDecorators = (o1, o2) => {\n  var _a, _b;\n  const allKeys = unique([...Object.getOwnPropertyNames(o1), ...Object.getOwnPropertyNames(o2)]);\n  const mergedObject = {};\n  for (let key of allKeys) mergedObject[key] = unique([...((_a = o1 === null || o1 === void 0 ? void 0 : o1[key]) !== null && _a !== void 0 ? _a : []), ...((_b = o2 === null || o2 === void 0 ? void 0 : o2[key]) !== null && _b !== void 0 ? _b : [])]);\n  return mergedObject;\n};\nconst mergePropertyAndMethodDecorators = (d1, d2) => {\n  var _a, _b, _c, _d;\n  return {\n    property: mergeObjectsOfDecorators((_a = d1 === null || d1 === void 0 ? void 0 : d1.property) !== null && _a !== void 0 ? _a : {}, (_b = d2 === null || d2 === void 0 ? void 0 : d2.property) !== null && _b !== void 0 ? _b : {}),\n    method: mergeObjectsOfDecorators((_c = d1 === null || d1 === void 0 ? void 0 : d1.method) !== null && _c !== void 0 ? _c : {}, (_d = d2 === null || d2 === void 0 ? void 0 : d2.method) !== null && _d !== void 0 ? _d : {})\n  };\n};\nconst mergeDecorators = (d1, d2) => {\n  var _a, _b, _c, _d, _e, _f;\n  return {\n    class: unique([...((_a = d1 === null || d1 === void 0 ? void 0 : d1.class) !== null && _a !== void 0 ? _a : []), ...((_b = d2 === null || d2 === void 0 ? void 0 : d2.class) !== null && _b !== void 0 ? _b : [])]),\n    static: mergePropertyAndMethodDecorators((_c = d1 === null || d1 === void 0 ? void 0 : d1.static) !== null && _c !== void 0 ? _c : {}, (_d = d2 === null || d2 === void 0 ? void 0 : d2.static) !== null && _d !== void 0 ? _d : {}),\n    instance: mergePropertyAndMethodDecorators((_e = d1 === null || d1 === void 0 ? void 0 : d1.instance) !== null && _e !== void 0 ? _e : {}, (_f = d2 === null || d2 === void 0 ? void 0 : d2.instance) !== null && _f !== void 0 ? _f : {})\n  };\n};\nconst decorators = new Map();\nconst findAllConstituentClasses = function () {\n  var _a;\n  const allClasses = new Set();\n  for (var _len2 = arguments.length, classes = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n    classes[_key2] = arguments[_key2];\n  }\n  const frontier = new Set([...classes]);\n  while (frontier.size > 0) {\n    for (let clazz of frontier) {\n      const protoChainClasses = protoChain(clazz.prototype).map(proto => proto.constructor);\n      const mixinClasses = (_a = getMixinsForClass(clazz)) !== null && _a !== void 0 ? _a : [];\n      const potentiallyNewClasses = [...protoChainClasses, ...mixinClasses];\n      const newClasses = potentiallyNewClasses.filter(c => !allClasses.has(c));\n      for (let newClass of newClasses) frontier.add(newClass);\n      allClasses.add(clazz);\n      frontier.delete(clazz);\n    }\n  }\n  return [...allClasses];\n};\nconst deepDecoratorSearch = function () {\n  const decoratorsForClassChain = findAllConstituentClasses(...arguments).map(clazz => decorators.get(clazz)).filter(decorators => !!decorators);\n  if (decoratorsForClassChain.length == 0) return {};\n  if (decoratorsForClassChain.length == 1) return decoratorsForClassChain[0];\n  return decoratorsForClassChain.reduce((d1, d2) => mergeDecorators(d1, d2));\n};\nconst directDecoratorSearch = function () {\n  for (var _len3 = arguments.length, classes = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n    classes[_key3] = arguments[_key3];\n  }\n  const classDecorators = classes.map(clazz => getDecoratorsForClass(clazz));\n  if (classDecorators.length === 0) return {};\n  if (classDecorators.length === 1) return classDecorators[0];\n  return classDecorators.reduce((d1, d2) => mergeDecorators(d1, d2));\n};\nconst getDecoratorsForClass = clazz => {\n  let decoratorsForClass = decorators.get(clazz);\n  if (!decoratorsForClass) {\n    decoratorsForClass = {};\n    decorators.set(clazz, decoratorsForClass);\n  }\n  return decoratorsForClass;\n};\nconst decorateClass = decorator => clazz => {\n  const decoratorsForClass = getDecoratorsForClass(clazz);\n  let classDecorators = decoratorsForClass.class;\n  if (!classDecorators) {\n    classDecorators = [];\n    decoratorsForClass.class = classDecorators;\n  }\n  classDecorators.push(decorator);\n  return decorator(clazz);\n};\nconst decorateMember = decorator => function (object, key) {\n  var _a, _b, _c;\n  const decoratorTargetType = typeof object === 'function' ? 'static' : 'instance';\n  const decoratorType = typeof object[key] === 'function' ? 'method' : 'property';\n  const clazz = decoratorTargetType === 'static' ? object : object.constructor;\n  const decoratorsForClass = getDecoratorsForClass(clazz);\n  const decoratorsForTargetType = (_a = decoratorsForClass === null || decoratorsForClass === void 0 ? void 0 : decoratorsForClass[decoratorTargetType]) !== null && _a !== void 0 ? _a : {};\n  decoratorsForClass[decoratorTargetType] = decoratorsForTargetType;\n  let decoratorsForType = (_b = decoratorsForTargetType === null || decoratorsForTargetType === void 0 ? void 0 : decoratorsForTargetType[decoratorType]) !== null && _b !== void 0 ? _b : {};\n  decoratorsForTargetType[decoratorType] = decoratorsForType;\n  let decoratorsForKey = (_c = decoratorsForType === null || decoratorsForType === void 0 ? void 0 : decoratorsForType[key]) !== null && _c !== void 0 ? _c : [];\n  decoratorsForType[key] = decoratorsForKey;\n  // @ts-ignore: array is type `A[] | B[]` and item is type `A | B`, so technically a type error, but it's fine\n  decoratorsForKey.push(decorator);\n  // @ts-ignore\n  for (var _len4 = arguments.length, otherArgs = new Array(_len4 > 2 ? _len4 - 2 : 0), _key4 = 2; _key4 < _len4; _key4++) {\n    otherArgs[_key4 - 2] = arguments[_key4];\n  }\n  return decorator(object, key, ...otherArgs);\n};\nconst decorate = decorator => function () {\n  if (arguments.length === 1) return decorateClass(decorator)(arguments.length <= 0 ? undefined : arguments[0]);\n  return decorateMember(decorator)(...arguments);\n};\nfunction Mixin() {\n  for (var _len5 = arguments.length, constructors = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {\n    constructors[_key5] = arguments[_key5];\n  }\n  var _a, _b, _c;\n  const prototypes = constructors.map(constructor => constructor.prototype);\n  // Here we gather up the init functions of the ingredient prototypes, combine them into one init function, and\n  // attach it to the mixed class prototype.  The reason we do this is because we want the init functions to mix\n  // similarly to constructors -- not methods, which simply override each other.\n  const initFunctionName = settings.initFunction;\n  if (initFunctionName !== null) {\n    const initFunctions = prototypes.map(proto => proto[initFunctionName]).filter(func => typeof func === 'function');\n    const combinedInitFunction = function () {\n      for (var _len6 = arguments.length, args = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {\n        args[_key6] = arguments[_key6];\n      }\n      for (let initFunction of initFunctions) initFunction.apply(this, args);\n    };\n    const extraProto = {\n      [initFunctionName]: combinedInitFunction\n    };\n    prototypes.push(extraProto);\n  }\n  function MixedClass() {\n    for (var _len7 = arguments.length, args = new Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {\n      args[_key7] = arguments[_key7];\n    }\n    for (const constructor of constructors)\n    // @ts-ignore: potentially abstract class\n    copyProps(this, new constructor(...args));\n    if (initFunctionName !== null && typeof this[initFunctionName] === 'function') this[initFunctionName].apply(this, args);\n  }\n  MixedClass.prototype = settings.prototypeStrategy === 'copy' ? hardMixProtos(prototypes, MixedClass) : softMixProtos(prototypes, MixedClass);\n  Object.setPrototypeOf(MixedClass, settings.staticsStrategy === 'copy' ? hardMixProtos(constructors, null, ['prototype']) : proxyMix(constructors, Function.prototype));\n  let DecoratedMixedClass = MixedClass;\n  if (settings.decoratorInheritance !== 'none') {\n    const classDecorators = settings.decoratorInheritance === 'deep' ? deepDecoratorSearch(...constructors) : directDecoratorSearch(...constructors);\n    for (let decorator of (_a = classDecorators === null || classDecorators === void 0 ? void 0 : classDecorators.class) !== null && _a !== void 0 ? _a : []) {\n      const result = decorator(DecoratedMixedClass);\n      if (result) {\n        DecoratedMixedClass = result;\n      }\n    }\n    applyPropAndMethodDecorators((_b = classDecorators === null || classDecorators === void 0 ? void 0 : classDecorators.static) !== null && _b !== void 0 ? _b : {}, DecoratedMixedClass);\n    applyPropAndMethodDecorators((_c = classDecorators === null || classDecorators === void 0 ? void 0 : classDecorators.instance) !== null && _c !== void 0 ? _c : {}, DecoratedMixedClass.prototype);\n  }\n  registerMixins(DecoratedMixedClass, constructors);\n  return DecoratedMixedClass;\n}\nconst applyPropAndMethodDecorators = (propAndMethodDecorators, target) => {\n  const propDecorators = propAndMethodDecorators.property;\n  const methodDecorators = propAndMethodDecorators.method;\n  if (propDecorators) for (let key in propDecorators) for (let decorator of propDecorators[key]) decorator(target, key);\n  if (methodDecorators) for (let key in methodDecorators) for (let decorator of methodDecorators[key]) decorator(target, key, Object.getOwnPropertyDescriptor(target, key));\n};\n/**\n * A decorator version of the `Mixin` function.  You'll want to use this instead of `Mixin` for mixing generic classes.\n */\nconst mix = function () {\n  for (var _len8 = arguments.length, ingredients = new Array(_len8), _key8 = 0; _key8 < _len8; _key8++) {\n    ingredients[_key8] = arguments[_key8];\n  }\n  return decoratedClass => {\n    // @ts-ignore\n    const mixedClass = Mixin(...ingredients.concat([decoratedClass]));\n    Object.defineProperty(mixedClass, 'name', {\n      value: decoratedClass.name,\n      writable: false\n    });\n    return mixedClass;\n  };\n};\nexport { Mixin, decorate, hasMixin, mix, settings };","map":{"version":3,"names":["copyProps","dest","src","exclude","arguments","length","undefined","props","Object","getOwnPropertyDescriptors","prop","defineProperties","protoChain","obj","currentChain","proto","getPrototypeOf","nearestCommonProto","_len","objs","Array","_key","commonProto","protoChains","map","every","protos","pop","potentialCommonProto","hardMixProtos","ingredients","constructor","_a","base","prototype","mixedProto","create","visitedProtos","i","newProto","indexOf","push","unique","arr","filter","e","getIngredientWithProp","ingredient","protoDepth","protosAreLeftToSearch","searchTarget","getOwnPropertyDescriptor","proxyMix","Proxy","setPrototypeOf","Error","_","defineProperty","has","get","set","val","ingredientWithProp","deleteProperty","ownKeys","getOwnPropertyNames","reduce","prev","curr","concat","key","softMixProtos","settings","initFunction","staticsStrategy","prototypeStrategy","decoratorInheritance","mixins","WeakMap","getMixinsForClass","clazz","registerMixins","mixedClass","constituents","hasMixin","instance","mixin","visited","Set","frontier","add","size","forEach","item","newFrontier","itemConstituents","constituent","mergeObjectsOfDecorators","o1","o2","_b","allKeys","mergedObject","mergePropertyAndMethodDecorators","d1","d2","_c","_d","property","method","mergeDecorators","_e","_f","class","static","decorators","Map","findAllConstituentClasses","allClasses","_len2","classes","_key2","protoChainClasses","mixinClasses","potentiallyNewClasses","newClasses","c","newClass","delete","deepDecoratorSearch","decoratorsForClassChain","directDecoratorSearch","_len3","_key3","classDecorators","getDecoratorsForClass","decoratorsForClass","decorateClass","decorator","decorateMember","object","decoratorTargetType","decoratorType","decoratorsForTargetType","decoratorsForType","decoratorsForKey","_len4","otherArgs","_key4","decorate","Mixin","_len5","constructors","_key5","prototypes","initFunctionName","initFunctions","func","combinedInitFunction","_len6","args","_key6","apply","extraProto","MixedClass","_len7","_key7","Function","DecoratedMixedClass","result","applyPropAndMethodDecorators","propAndMethodDecorators","target","propDecorators","methodDecorators","mix","_len8","_key8","decoratedClass","value","name","writable"],"sources":["C:/Users/Administrator/solana-wallet-app/node_modules/ts-mixer/dist/esm/index.js"],"sourcesContent":["/**\n * Utility function that works like `Object.apply`, but copies getters and setters properly as well.  Additionally gives\n * the option to exclude properties by name.\n */\nconst copyProps = (dest, src, exclude = []) => {\n    const props = Object.getOwnPropertyDescriptors(src);\n    for (let prop of exclude)\n        delete props[prop];\n    Object.defineProperties(dest, props);\n};\n/**\n * Returns the full chain of prototypes up until Object.prototype given a starting object.  The order of prototypes will\n * be closest to farthest in the chain.\n */\nconst protoChain = (obj, currentChain = [obj]) => {\n    const proto = Object.getPrototypeOf(obj);\n    if (proto === null)\n        return currentChain;\n    return protoChain(proto, [...currentChain, proto]);\n};\n/**\n * Identifies the nearest ancestor common to all the given objects in their prototype chains.  For most unrelated\n * objects, this function should return Object.prototype.\n */\nconst nearestCommonProto = (...objs) => {\n    if (objs.length === 0)\n        return undefined;\n    let commonProto = undefined;\n    const protoChains = objs.map(obj => protoChain(obj));\n    while (protoChains.every(protoChain => protoChain.length > 0)) {\n        const protos = protoChains.map(protoChain => protoChain.pop());\n        const potentialCommonProto = protos[0];\n        if (protos.every(proto => proto === potentialCommonProto))\n            commonProto = potentialCommonProto;\n        else\n            break;\n    }\n    return commonProto;\n};\n/**\n * Creates a new prototype object that is a mixture of the given prototypes.  The mixing is achieved by first\n * identifying the nearest common ancestor and using it as the prototype for a new object.  Then all properties/methods\n * downstream of this prototype (ONLY downstream) are copied into the new object.\n *\n * The resulting prototype is more performant than softMixProtos(...), as well as ES5 compatible.  However, it's not as\n * flexible as updates to the source prototypes aren't captured by the mixed result.  See softMixProtos for why you may\n * want to use that instead.\n */\nconst hardMixProtos = (ingredients, constructor, exclude = []) => {\n    var _a;\n    const base = (_a = nearestCommonProto(...ingredients)) !== null && _a !== void 0 ? _a : Object.prototype;\n    const mixedProto = Object.create(base);\n    // Keeps track of prototypes we've already visited to avoid copying the same properties multiple times.  We init the\n    // list with the proto chain below the nearest common ancestor because we don't want any of those methods mixed in\n    // when they will already be accessible via prototype access.\n    const visitedProtos = protoChain(base);\n    for (let prototype of ingredients) {\n        let protos = protoChain(prototype);\n        // Apply the prototype chain in reverse order so that old methods don't override newer ones.\n        for (let i = protos.length - 1; i >= 0; i--) {\n            let newProto = protos[i];\n            if (visitedProtos.indexOf(newProto) === -1) {\n                copyProps(mixedProto, newProto, ['constructor', ...exclude]);\n                visitedProtos.push(newProto);\n            }\n        }\n    }\n    mixedProto.constructor = constructor;\n    return mixedProto;\n};\nconst unique = (arr) => arr.filter((e, i) => arr.indexOf(e) == i);\n\n/**\n * Finds the ingredient with the given prop, searching in reverse order and breadth-first if searching ingredient\n * prototypes is required.\n */\nconst getIngredientWithProp = (prop, ingredients) => {\n    const protoChains = ingredients.map(ingredient => protoChain(ingredient));\n    // since we search breadth-first, we need to keep track of our depth in the prototype chains\n    let protoDepth = 0;\n    // not all prototype chains are the same depth, so this remains true as long as at least one of the ingredients'\n    // prototype chains has an object at this depth\n    let protosAreLeftToSearch = true;\n    while (protosAreLeftToSearch) {\n        // with the start of each horizontal slice, we assume this is the one that's deeper than any of the proto chains\n        protosAreLeftToSearch = false;\n        // scan through the ingredients right to left\n        for (let i = ingredients.length - 1; i >= 0; i--) {\n            const searchTarget = protoChains[i][protoDepth];\n            if (searchTarget !== undefined && searchTarget !== null) {\n                // if we find something, this is proof that this horizontal slice potentially more objects to search\n                protosAreLeftToSearch = true;\n                // eureka, we found it\n                if (Object.getOwnPropertyDescriptor(searchTarget, prop) != undefined) {\n                    return protoChains[i][0];\n                }\n            }\n        }\n        protoDepth++;\n    }\n    return undefined;\n};\n/**\n * \"Mixes\" ingredients by wrapping them in a Proxy.  The optional prototype argument allows the mixed object to sit\n * downstream of an existing prototype chain.  Note that \"properties\" cannot be added, deleted, or modified.\n */\nconst proxyMix = (ingredients, prototype = Object.prototype) => new Proxy({}, {\n    getPrototypeOf() {\n        return prototype;\n    },\n    setPrototypeOf() {\n        throw Error('Cannot set prototype of Proxies created by ts-mixer');\n    },\n    getOwnPropertyDescriptor(_, prop) {\n        return Object.getOwnPropertyDescriptor(getIngredientWithProp(prop, ingredients) || {}, prop);\n    },\n    defineProperty() {\n        throw new Error('Cannot define new properties on Proxies created by ts-mixer');\n    },\n    has(_, prop) {\n        return getIngredientWithProp(prop, ingredients) !== undefined || prototype[prop] !== undefined;\n    },\n    get(_, prop) {\n        return (getIngredientWithProp(prop, ingredients) || prototype)[prop];\n    },\n    set(_, prop, val) {\n        const ingredientWithProp = getIngredientWithProp(prop, ingredients);\n        if (ingredientWithProp === undefined)\n            throw new Error('Cannot set new properties on Proxies created by ts-mixer');\n        ingredientWithProp[prop] = val;\n        return true;\n    },\n    deleteProperty() {\n        throw new Error('Cannot delete properties on Proxies created by ts-mixer');\n    },\n    ownKeys() {\n        return ingredients\n            .map(Object.getOwnPropertyNames)\n            .reduce((prev, curr) => curr.concat(prev.filter(key => curr.indexOf(key) < 0)));\n    },\n});\n/**\n * Creates a new proxy-prototype object that is a \"soft\" mixture of the given prototypes.  The mixing is achieved by\n * proxying all property access to the ingredients.  This is not ES5 compatible and less performant.  However, any\n * changes made to the source prototypes will be reflected in the proxy-prototype, which may be desirable.\n */\nconst softMixProtos = (ingredients, constructor) => proxyMix([...ingredients, { constructor }]);\n\nconst settings = {\n    initFunction: null,\n    staticsStrategy: 'copy',\n    prototypeStrategy: 'copy',\n    decoratorInheritance: 'deep',\n};\n\n// Keeps track of constituent classes for every mixin class created by ts-mixer.\nconst mixins = new WeakMap();\nconst getMixinsForClass = (clazz) => mixins.get(clazz);\nconst registerMixins = (mixedClass, constituents) => mixins.set(mixedClass, constituents);\nconst hasMixin = (instance, mixin) => {\n    if (instance instanceof mixin)\n        return true;\n    const constructor = instance.constructor;\n    const visited = new Set();\n    let frontier = new Set();\n    frontier.add(constructor);\n    while (frontier.size > 0) {\n        // check if the frontier has the mixin we're looking for.  if not, we can say we visited every item in the frontier\n        if (frontier.has(mixin))\n            return true;\n        frontier.forEach((item) => visited.add(item));\n        // build a new frontier based on the associated mixin classes and prototype chains of each frontier item\n        const newFrontier = new Set();\n        frontier.forEach((item) => {\n            var _a;\n            const itemConstituents = (_a = mixins.get(item)) !== null && _a !== void 0 ? _a : protoChain(item.prototype)\n                .map((proto) => proto.constructor)\n                .filter((item) => item !== null);\n            if (itemConstituents)\n                itemConstituents.forEach((constituent) => {\n                    if (!visited.has(constituent) && !frontier.has(constituent))\n                        newFrontier.add(constituent);\n                });\n        });\n        // we have a new frontier, now search again\n        frontier = newFrontier;\n    }\n    // if we get here, we couldn't find the mixin anywhere in the prototype chain or associated mixin classes\n    return false;\n};\n\nconst mergeObjectsOfDecorators = (o1, o2) => {\n    var _a, _b;\n    const allKeys = unique([...Object.getOwnPropertyNames(o1), ...Object.getOwnPropertyNames(o2)]);\n    const mergedObject = {};\n    for (let key of allKeys)\n        mergedObject[key] = unique([...((_a = o1 === null || o1 === void 0 ? void 0 : o1[key]) !== null && _a !== void 0 ? _a : []), ...((_b = o2 === null || o2 === void 0 ? void 0 : o2[key]) !== null && _b !== void 0 ? _b : [])]);\n    return mergedObject;\n};\nconst mergePropertyAndMethodDecorators = (d1, d2) => {\n    var _a, _b, _c, _d;\n    return ({\n        property: mergeObjectsOfDecorators((_a = d1 === null || d1 === void 0 ? void 0 : d1.property) !== null && _a !== void 0 ? _a : {}, (_b = d2 === null || d2 === void 0 ? void 0 : d2.property) !== null && _b !== void 0 ? _b : {}),\n        method: mergeObjectsOfDecorators((_c = d1 === null || d1 === void 0 ? void 0 : d1.method) !== null && _c !== void 0 ? _c : {}, (_d = d2 === null || d2 === void 0 ? void 0 : d2.method) !== null && _d !== void 0 ? _d : {}),\n    });\n};\nconst mergeDecorators = (d1, d2) => {\n    var _a, _b, _c, _d, _e, _f;\n    return ({\n        class: unique([...(_a = d1 === null || d1 === void 0 ? void 0 : d1.class) !== null && _a !== void 0 ? _a : [], ...(_b = d2 === null || d2 === void 0 ? void 0 : d2.class) !== null && _b !== void 0 ? _b : []]),\n        static: mergePropertyAndMethodDecorators((_c = d1 === null || d1 === void 0 ? void 0 : d1.static) !== null && _c !== void 0 ? _c : {}, (_d = d2 === null || d2 === void 0 ? void 0 : d2.static) !== null && _d !== void 0 ? _d : {}),\n        instance: mergePropertyAndMethodDecorators((_e = d1 === null || d1 === void 0 ? void 0 : d1.instance) !== null && _e !== void 0 ? _e : {}, (_f = d2 === null || d2 === void 0 ? void 0 : d2.instance) !== null && _f !== void 0 ? _f : {}),\n    });\n};\nconst decorators = new Map();\nconst findAllConstituentClasses = (...classes) => {\n    var _a;\n    const allClasses = new Set();\n    const frontier = new Set([...classes]);\n    while (frontier.size > 0) {\n        for (let clazz of frontier) {\n            const protoChainClasses = protoChain(clazz.prototype).map(proto => proto.constructor);\n            const mixinClasses = (_a = getMixinsForClass(clazz)) !== null && _a !== void 0 ? _a : [];\n            const potentiallyNewClasses = [...protoChainClasses, ...mixinClasses];\n            const newClasses = potentiallyNewClasses.filter(c => !allClasses.has(c));\n            for (let newClass of newClasses)\n                frontier.add(newClass);\n            allClasses.add(clazz);\n            frontier.delete(clazz);\n        }\n    }\n    return [...allClasses];\n};\nconst deepDecoratorSearch = (...classes) => {\n    const decoratorsForClassChain = findAllConstituentClasses(...classes)\n        .map(clazz => decorators.get(clazz))\n        .filter(decorators => !!decorators);\n    if (decoratorsForClassChain.length == 0)\n        return {};\n    if (decoratorsForClassChain.length == 1)\n        return decoratorsForClassChain[0];\n    return decoratorsForClassChain.reduce((d1, d2) => mergeDecorators(d1, d2));\n};\nconst directDecoratorSearch = (...classes) => {\n    const classDecorators = classes.map(clazz => getDecoratorsForClass(clazz));\n    if (classDecorators.length === 0)\n        return {};\n    if (classDecorators.length === 1)\n        return classDecorators[0];\n    return classDecorators.reduce((d1, d2) => mergeDecorators(d1, d2));\n};\nconst getDecoratorsForClass = (clazz) => {\n    let decoratorsForClass = decorators.get(clazz);\n    if (!decoratorsForClass) {\n        decoratorsForClass = {};\n        decorators.set(clazz, decoratorsForClass);\n    }\n    return decoratorsForClass;\n};\nconst decorateClass = (decorator) => ((clazz) => {\n    const decoratorsForClass = getDecoratorsForClass(clazz);\n    let classDecorators = decoratorsForClass.class;\n    if (!classDecorators) {\n        classDecorators = [];\n        decoratorsForClass.class = classDecorators;\n    }\n    classDecorators.push(decorator);\n    return decorator(clazz);\n});\nconst decorateMember = (decorator) => ((object, key, ...otherArgs) => {\n    var _a, _b, _c;\n    const decoratorTargetType = typeof object === 'function' ? 'static' : 'instance';\n    const decoratorType = typeof object[key] === 'function' ? 'method' : 'property';\n    const clazz = decoratorTargetType === 'static' ? object : object.constructor;\n    const decoratorsForClass = getDecoratorsForClass(clazz);\n    const decoratorsForTargetType = (_a = decoratorsForClass === null || decoratorsForClass === void 0 ? void 0 : decoratorsForClass[decoratorTargetType]) !== null && _a !== void 0 ? _a : {};\n    decoratorsForClass[decoratorTargetType] = decoratorsForTargetType;\n    let decoratorsForType = (_b = decoratorsForTargetType === null || decoratorsForTargetType === void 0 ? void 0 : decoratorsForTargetType[decoratorType]) !== null && _b !== void 0 ? _b : {};\n    decoratorsForTargetType[decoratorType] = decoratorsForType;\n    let decoratorsForKey = (_c = decoratorsForType === null || decoratorsForType === void 0 ? void 0 : decoratorsForType[key]) !== null && _c !== void 0 ? _c : [];\n    decoratorsForType[key] = decoratorsForKey;\n    // @ts-ignore: array is type `A[] | B[]` and item is type `A | B`, so technically a type error, but it's fine\n    decoratorsForKey.push(decorator);\n    // @ts-ignore\n    return decorator(object, key, ...otherArgs);\n});\nconst decorate = (decorator) => ((...args) => {\n    if (args.length === 1)\n        return decorateClass(decorator)(args[0]);\n    return decorateMember(decorator)(...args);\n});\n\nfunction Mixin(...constructors) {\n    var _a, _b, _c;\n    const prototypes = constructors.map(constructor => constructor.prototype);\n    // Here we gather up the init functions of the ingredient prototypes, combine them into one init function, and\n    // attach it to the mixed class prototype.  The reason we do this is because we want the init functions to mix\n    // similarly to constructors -- not methods, which simply override each other.\n    const initFunctionName = settings.initFunction;\n    if (initFunctionName !== null) {\n        const initFunctions = prototypes\n            .map(proto => proto[initFunctionName])\n            .filter(func => typeof func === 'function');\n        const combinedInitFunction = function (...args) {\n            for (let initFunction of initFunctions)\n                initFunction.apply(this, args);\n        };\n        const extraProto = { [initFunctionName]: combinedInitFunction };\n        prototypes.push(extraProto);\n    }\n    function MixedClass(...args) {\n        for (const constructor of constructors)\n            // @ts-ignore: potentially abstract class\n            copyProps(this, new constructor(...args));\n        if (initFunctionName !== null && typeof this[initFunctionName] === 'function')\n            this[initFunctionName].apply(this, args);\n    }\n    MixedClass.prototype = settings.prototypeStrategy === 'copy'\n        ? hardMixProtos(prototypes, MixedClass)\n        : softMixProtos(prototypes, MixedClass);\n    Object.setPrototypeOf(MixedClass, settings.staticsStrategy === 'copy'\n        ? hardMixProtos(constructors, null, ['prototype'])\n        : proxyMix(constructors, Function.prototype));\n    let DecoratedMixedClass = MixedClass;\n    if (settings.decoratorInheritance !== 'none') {\n        const classDecorators = settings.decoratorInheritance === 'deep'\n            ? deepDecoratorSearch(...constructors)\n            : directDecoratorSearch(...constructors);\n        for (let decorator of (_a = classDecorators === null || classDecorators === void 0 ? void 0 : classDecorators.class) !== null && _a !== void 0 ? _a : []) {\n            const result = decorator(DecoratedMixedClass);\n            if (result) {\n                DecoratedMixedClass = result;\n            }\n        }\n        applyPropAndMethodDecorators((_b = classDecorators === null || classDecorators === void 0 ? void 0 : classDecorators.static) !== null && _b !== void 0 ? _b : {}, DecoratedMixedClass);\n        applyPropAndMethodDecorators((_c = classDecorators === null || classDecorators === void 0 ? void 0 : classDecorators.instance) !== null && _c !== void 0 ? _c : {}, DecoratedMixedClass.prototype);\n    }\n    registerMixins(DecoratedMixedClass, constructors);\n    return DecoratedMixedClass;\n}\nconst applyPropAndMethodDecorators = (propAndMethodDecorators, target) => {\n    const propDecorators = propAndMethodDecorators.property;\n    const methodDecorators = propAndMethodDecorators.method;\n    if (propDecorators)\n        for (let key in propDecorators)\n            for (let decorator of propDecorators[key])\n                decorator(target, key);\n    if (methodDecorators)\n        for (let key in methodDecorators)\n            for (let decorator of methodDecorators[key])\n                decorator(target, key, Object.getOwnPropertyDescriptor(target, key));\n};\n/**\n * A decorator version of the `Mixin` function.  You'll want to use this instead of `Mixin` for mixing generic classes.\n */\nconst mix = (...ingredients) => decoratedClass => {\n    // @ts-ignore\n    const mixedClass = Mixin(...ingredients.concat([decoratedClass]));\n    Object.defineProperty(mixedClass, 'name', {\n        value: decoratedClass.name,\n        writable: false,\n    });\n    return mixedClass;\n};\n\nexport { Mixin, decorate, hasMixin, mix, settings };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}