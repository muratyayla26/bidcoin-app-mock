{"ast":null,"code":"function wrapToPromise(value) {\n  if (!value || typeof value.then !== \"function\") {\n    return Promise.resolve(value);\n  }\n  return value;\n}\nfunction asyncCall(function_, ...arguments_) {\n  try {\n    return wrapToPromise(function_(...arguments_));\n  } catch (error) {\n    return Promise.reject(error);\n  }\n}\nfunction isPrimitive(value) {\n  const type = typeof value;\n  return value === null || type !== \"object\" && type !== \"function\";\n}\nfunction isPureObject(value) {\n  const proto = Object.getPrototypeOf(value);\n  return !proto || proto.isPrototypeOf(Object);\n}\nfunction stringify(value) {\n  if (isPrimitive(value)) {\n    return String(value);\n  }\n  if (isPureObject(value) || Array.isArray(value)) {\n    return JSON.stringify(value);\n  }\n  if (typeof value.toJSON === \"function\") {\n    return stringify(value.toJSON());\n  }\n  throw new Error(\"[unstorage] Cannot stringify value!\");\n}\nfunction checkBufferSupport() {\n  if (typeof Buffer === \"undefined\") {\n    throw new TypeError(\"[unstorage] Buffer is not supported!\");\n  }\n}\nconst BASE64_PREFIX = \"base64:\";\nfunction serializeRaw(value) {\n  if (typeof value === \"string\") {\n    return value;\n  }\n  checkBufferSupport();\n  const base64 = Buffer.from(value).toString(\"base64\");\n  return BASE64_PREFIX + base64;\n}\nfunction deserializeRaw(value) {\n  if (typeof value !== \"string\") {\n    return value;\n  }\n  if (!value.startsWith(BASE64_PREFIX)) {\n    return value;\n  }\n  checkBufferSupport();\n  return Buffer.from(value.slice(BASE64_PREFIX.length), \"base64\");\n}\nconst storageKeyProperties = [\"hasItem\", \"getItem\", \"getItemRaw\", \"setItem\", \"setItemRaw\", \"removeItem\", \"getMeta\", \"setMeta\", \"removeMeta\", \"getKeys\", \"clear\", \"mount\", \"unmount\"];\nfunction prefixStorage(storage, base) {\n  base = normalizeBaseKey(base);\n  if (!base) {\n    return storage;\n  }\n  const nsStorage = {\n    ...storage\n  };\n  for (const property of storageKeyProperties) {\n    nsStorage[property] = (key = \"\", ...args) =>\n    // @ts-ignore\n    storage[property](base + key, ...args);\n  }\n  nsStorage.getKeys = (key = \"\", ...arguments_) => storage.getKeys(base + key, ...arguments_).then(keys => keys.map(key2 => key2.slice(base.length)));\n  return nsStorage;\n}\nfunction normalizeKey(key) {\n  if (!key) {\n    return \"\";\n  }\n  return key.split(\"?\")[0].replace(/[/\\\\]/g, \":\").replace(/:+/g, \":\").replace(/^:|:$/g, \"\");\n}\nfunction joinKeys(...keys) {\n  return normalizeKey(keys.join(\":\"));\n}\nfunction normalizeBaseKey(base) {\n  base = normalizeKey(base);\n  return base ? base + \":\" : \"\";\n}\nexport { normalizeKey as a, asyncCall as b, serializeRaw as c, deserializeRaw as d, joinKeys as j, normalizeBaseKey as n, prefixStorage as p, stringify as s };","map":{"version":3,"names":["wrapToPromise","value","then","Promise","resolve","asyncCall","function_","arguments_","error","reject","isPrimitive","type","isPureObject","proto","Object","getPrototypeOf","isPrototypeOf","stringify","String","Array","isArray","JSON","toJSON","Error","checkBufferSupport","Buffer","TypeError","BASE64_PREFIX","serializeRaw","base64","from","toString","deserializeRaw","startsWith","slice","length","storageKeyProperties","prefixStorage","storage","base","normalizeBaseKey","nsStorage","property","key","args","getKeys","keys","map","key2","normalizeKey","split","replace","joinKeys","join","a","b","c","d","j","n","p","s"],"sources":["C:/Users/Administrator/solana-wallet-app/node_modules/unstorage/dist/shared/unstorage.d569726e.mjs"],"sourcesContent":["function wrapToPromise(value) {\n  if (!value || typeof value.then !== \"function\") {\n    return Promise.resolve(value);\n  }\n  return value;\n}\nfunction asyncCall(function_, ...arguments_) {\n  try {\n    return wrapToPromise(function_(...arguments_));\n  } catch (error) {\n    return Promise.reject(error);\n  }\n}\nfunction isPrimitive(value) {\n  const type = typeof value;\n  return value === null || type !== \"object\" && type !== \"function\";\n}\nfunction isPureObject(value) {\n  const proto = Object.getPrototypeOf(value);\n  return !proto || proto.isPrototypeOf(Object);\n}\nfunction stringify(value) {\n  if (isPrimitive(value)) {\n    return String(value);\n  }\n  if (isPureObject(value) || Array.isArray(value)) {\n    return JSON.stringify(value);\n  }\n  if (typeof value.toJSON === \"function\") {\n    return stringify(value.toJSON());\n  }\n  throw new Error(\"[unstorage] Cannot stringify value!\");\n}\nfunction checkBufferSupport() {\n  if (typeof Buffer === \"undefined\") {\n    throw new TypeError(\"[unstorage] Buffer is not supported!\");\n  }\n}\nconst BASE64_PREFIX = \"base64:\";\nfunction serializeRaw(value) {\n  if (typeof value === \"string\") {\n    return value;\n  }\n  checkBufferSupport();\n  const base64 = Buffer.from(value).toString(\"base64\");\n  return BASE64_PREFIX + base64;\n}\nfunction deserializeRaw(value) {\n  if (typeof value !== \"string\") {\n    return value;\n  }\n  if (!value.startsWith(BASE64_PREFIX)) {\n    return value;\n  }\n  checkBufferSupport();\n  return Buffer.from(value.slice(BASE64_PREFIX.length), \"base64\");\n}\n\nconst storageKeyProperties = [\n  \"hasItem\",\n  \"getItem\",\n  \"getItemRaw\",\n  \"setItem\",\n  \"setItemRaw\",\n  \"removeItem\",\n  \"getMeta\",\n  \"setMeta\",\n  \"removeMeta\",\n  \"getKeys\",\n  \"clear\",\n  \"mount\",\n  \"unmount\"\n];\nfunction prefixStorage(storage, base) {\n  base = normalizeBaseKey(base);\n  if (!base) {\n    return storage;\n  }\n  const nsStorage = { ...storage };\n  for (const property of storageKeyProperties) {\n    nsStorage[property] = (key = \"\", ...args) => (\n      // @ts-ignore\n      storage[property](base + key, ...args)\n    );\n  }\n  nsStorage.getKeys = (key = \"\", ...arguments_) => storage.getKeys(base + key, ...arguments_).then((keys) => keys.map((key2) => key2.slice(base.length)));\n  return nsStorage;\n}\nfunction normalizeKey(key) {\n  if (!key) {\n    return \"\";\n  }\n  return key.split(\"?\")[0].replace(/[/\\\\]/g, \":\").replace(/:+/g, \":\").replace(/^:|:$/g, \"\");\n}\nfunction joinKeys(...keys) {\n  return normalizeKey(keys.join(\":\"));\n}\nfunction normalizeBaseKey(base) {\n  base = normalizeKey(base);\n  return base ? base + \":\" : \"\";\n}\n\nexport { normalizeKey as a, asyncCall as b, serializeRaw as c, deserializeRaw as d, joinKeys as j, normalizeBaseKey as n, prefixStorage as p, stringify as s };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}