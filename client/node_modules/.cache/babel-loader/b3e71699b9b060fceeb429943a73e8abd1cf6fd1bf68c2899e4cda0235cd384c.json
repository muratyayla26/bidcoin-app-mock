{"ast":null,"code":"import { BaseWalletAdapter } from './adapter.js';\nimport { WalletSendTransactionError, WalletSignTransactionError } from './errors.js';\nimport { isVersionedTransaction } from './transaction.js';\nexport class BaseSignerWalletAdapter extends BaseWalletAdapter {\n  async sendTransaction(transaction, connection) {\n    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    let emit = true;\n    try {\n      if (isVersionedTransaction(transaction)) {\n        if (!this.supportedTransactionVersions) throw new WalletSendTransactionError(`Sending versioned transactions isn't supported by this wallet`);\n        if (!this.supportedTransactionVersions.has(transaction.version)) throw new WalletSendTransactionError(`Sending transaction version ${transaction.version} isn't supported by this wallet`);\n        try {\n          transaction = await this.signTransaction(transaction);\n          const rawTransaction = transaction.serialize();\n          return await connection.sendRawTransaction(rawTransaction, options);\n        } catch (error) {\n          // If the error was thrown by `signTransaction`, rethrow it and don't emit a duplicate event\n          if (error instanceof WalletSignTransactionError) {\n            emit = false;\n            throw error;\n          }\n          throw new WalletSendTransactionError(error?.message, error);\n        }\n      } else {\n        try {\n          const {\n            signers,\n            ...sendOptions\n          } = options;\n          transaction = await this.prepareTransaction(transaction, connection, sendOptions);\n          signers?.length && transaction.partialSign(...signers);\n          transaction = await this.signTransaction(transaction);\n          const rawTransaction = transaction.serialize();\n          return await connection.sendRawTransaction(rawTransaction, sendOptions);\n        } catch (error) {\n          // If the error was thrown by `signTransaction`, rethrow it and don't emit a duplicate event\n          if (error instanceof WalletSignTransactionError) {\n            emit = false;\n            throw error;\n          }\n          throw new WalletSendTransactionError(error?.message, error);\n        }\n      }\n    } catch (error) {\n      if (emit) {\n        this.emit('error', error);\n      }\n      throw error;\n    }\n  }\n  async signAllTransactions(transactions) {\n    for (const transaction of transactions) {\n      if (isVersionedTransaction(transaction)) {\n        if (!this.supportedTransactionVersions) throw new WalletSignTransactionError(`Signing versioned transactions isn't supported by this wallet`);\n        if (!this.supportedTransactionVersions.has(transaction.version)) throw new WalletSignTransactionError(`Signing transaction version ${transaction.version} isn't supported by this wallet`);\n      }\n    }\n    const signedTransactions = [];\n    for (const transaction of transactions) {\n      signedTransactions.push(await this.signTransaction(transaction));\n    }\n    return signedTransactions;\n  }\n}\nexport class BaseMessageSignerWalletAdapter extends BaseSignerWalletAdapter {}\nexport class BaseSignInMessageSignerWalletAdapter extends BaseMessageSignerWalletAdapter {}","map":{"version":3,"names":["BaseWalletAdapter","WalletSendTransactionError","WalletSignTransactionError","isVersionedTransaction","BaseSignerWalletAdapter","sendTransaction","transaction","connection","options","arguments","length","undefined","emit","supportedTransactionVersions","has","version","signTransaction","rawTransaction","serialize","sendRawTransaction","error","message","signers","sendOptions","prepareTransaction","partialSign","signAllTransactions","transactions","signedTransactions","push","BaseMessageSignerWalletAdapter","BaseSignInMessageSignerWalletAdapter"],"sources":["C:\\Users\\Administrator\\solana-wallet-app\\client\\node_modules\\@solana\\wallet-adapter-base\\src\\signer.ts"],"sourcesContent":["import type { SolanaSignInInput, SolanaSignInOutput } from '@solana/wallet-standard-features';\nimport type { Connection, TransactionSignature } from '@solana/web3.js';\nimport {\n    BaseWalletAdapter,\n    type SendTransactionOptions,\n    type WalletAdapter,\n    type WalletAdapterProps,\n} from './adapter.js';\nimport { WalletSendTransactionError, WalletSignTransactionError } from './errors.js';\nimport { isVersionedTransaction, type TransactionOrVersionedTransaction } from './transaction.js';\n\nexport interface SignerWalletAdapterProps<Name extends string = string> extends WalletAdapterProps<Name> {\n    signTransaction<T extends TransactionOrVersionedTransaction<this['supportedTransactionVersions']>>(\n        transaction: T\n    ): Promise<T>;\n    signAllTransactions<T extends TransactionOrVersionedTransaction<this['supportedTransactionVersions']>>(\n        transactions: T[]\n    ): Promise<T[]>;\n}\n\nexport type SignerWalletAdapter<Name extends string = string> = WalletAdapter<Name> & SignerWalletAdapterProps<Name>;\n\nexport abstract class BaseSignerWalletAdapter<Name extends string = string>\n    extends BaseWalletAdapter<Name>\n    implements SignerWalletAdapter<Name>\n{\n    async sendTransaction(\n        transaction: TransactionOrVersionedTransaction<this['supportedTransactionVersions']>,\n        connection: Connection,\n        options: SendTransactionOptions = {}\n    ): Promise<TransactionSignature> {\n        let emit = true;\n        try {\n            if (isVersionedTransaction(transaction)) {\n                if (!this.supportedTransactionVersions)\n                    throw new WalletSendTransactionError(\n                        `Sending versioned transactions isn't supported by this wallet`\n                    );\n\n                if (!this.supportedTransactionVersions.has(transaction.version))\n                    throw new WalletSendTransactionError(\n                        `Sending transaction version ${transaction.version} isn't supported by this wallet`\n                    );\n\n                try {\n                    transaction = await this.signTransaction(transaction);\n\n                    const rawTransaction = transaction.serialize();\n\n                    return await connection.sendRawTransaction(rawTransaction, options);\n                } catch (error: any) {\n                    // If the error was thrown by `signTransaction`, rethrow it and don't emit a duplicate event\n                    if (error instanceof WalletSignTransactionError) {\n                        emit = false;\n                        throw error;\n                    }\n                    throw new WalletSendTransactionError(error?.message, error);\n                }\n            } else {\n                try {\n                    const { signers, ...sendOptions } = options;\n\n                    transaction = await this.prepareTransaction(transaction, connection, sendOptions);\n\n                    signers?.length && transaction.partialSign(...signers);\n\n                    transaction = await this.signTransaction(transaction);\n\n                    const rawTransaction = transaction.serialize();\n\n                    return await connection.sendRawTransaction(rawTransaction, sendOptions);\n                } catch (error: any) {\n                    // If the error was thrown by `signTransaction`, rethrow it and don't emit a duplicate event\n                    if (error instanceof WalletSignTransactionError) {\n                        emit = false;\n                        throw error;\n                    }\n                    throw new WalletSendTransactionError(error?.message, error);\n                }\n            }\n        } catch (error: any) {\n            if (emit) {\n                this.emit('error', error);\n            }\n            throw error;\n        }\n    }\n\n    abstract signTransaction<T extends TransactionOrVersionedTransaction<this['supportedTransactionVersions']>>(\n        transaction: T\n    ): Promise<T>;\n\n    async signAllTransactions<T extends TransactionOrVersionedTransaction<this['supportedTransactionVersions']>>(\n        transactions: T[]\n    ): Promise<T[]> {\n        for (const transaction of transactions) {\n            if (isVersionedTransaction(transaction)) {\n                if (!this.supportedTransactionVersions)\n                    throw new WalletSignTransactionError(\n                        `Signing versioned transactions isn't supported by this wallet`\n                    );\n\n                if (!this.supportedTransactionVersions.has(transaction.version))\n                    throw new WalletSignTransactionError(\n                        `Signing transaction version ${transaction.version} isn't supported by this wallet`\n                    );\n            }\n        }\n\n        const signedTransactions: T[] = [];\n        for (const transaction of transactions) {\n            signedTransactions.push(await this.signTransaction(transaction));\n        }\n        return signedTransactions;\n    }\n}\n\nexport interface MessageSignerWalletAdapterProps<Name extends string = string> extends WalletAdapterProps<Name> {\n    signMessage(message: Uint8Array): Promise<Uint8Array>;\n}\n\nexport type MessageSignerWalletAdapter<Name extends string = string> = WalletAdapter<Name> &\n    MessageSignerWalletAdapterProps<Name>;\n\nexport abstract class BaseMessageSignerWalletAdapter<Name extends string = string>\n    extends BaseSignerWalletAdapter<Name>\n    implements MessageSignerWalletAdapter<Name>\n{\n    abstract signMessage(message: Uint8Array): Promise<Uint8Array>;\n}\n\nexport interface SignInMessageSignerWalletAdapterProps<Name extends string = string> extends WalletAdapterProps<Name> {\n    signIn(input?: SolanaSignInInput): Promise<SolanaSignInOutput>;\n}\n\nexport type SignInMessageSignerWalletAdapter<Name extends string = string> = WalletAdapter<Name> &\n    SignInMessageSignerWalletAdapterProps<Name>;\n\nexport abstract class BaseSignInMessageSignerWalletAdapter<Name extends string = string>\n    extends BaseMessageSignerWalletAdapter<Name>\n    implements SignInMessageSignerWalletAdapter<Name>\n{\n    abstract signIn(input?: SolanaSignInInput): Promise<SolanaSignInOutput>;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}