{"ast":null,"code":"\"use strict\";\n\n/*--------------------------------------------------------------------------\n\n@sinclair/typebox\n\nThe MIT License (MIT)\n\nCopyright (c) 2017-2023 Haydn Paterson (sinclair) <haydn.developer@gmail.com>\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n\n---------------------------------------------------------------------------*/\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Type = exports.JsonType = exports.JavaScriptTypeBuilder = exports.JsonTypeBuilder = exports.TypeBuilder = exports.TypeBuilderError = exports.TransformEncodeBuilder = exports.TransformDecodeBuilder = exports.TemplateLiteralDslParser = exports.TemplateLiteralGenerator = exports.TemplateLiteralGeneratorError = exports.TemplateLiteralFinite = exports.TemplateLiteralFiniteError = exports.TemplateLiteralParser = exports.TemplateLiteralParserError = exports.TemplateLiteralResolver = exports.TemplateLiteralPattern = exports.TemplateLiteralPatternError = exports.UnionResolver = exports.KeyArrayResolver = exports.KeyArrayResolverError = exports.KeyResolver = exports.ObjectMap = exports.Intrinsic = exports.IndexedAccessor = exports.TypeClone = exports.TypeExtends = exports.TypeExtendsResult = exports.TypeExtendsError = exports.ExtendsUndefined = exports.TypeGuard = exports.TypeGuardUnknownTypeError = exports.ValueGuard = exports.FormatRegistry = exports.TypeBoxError = exports.TypeRegistry = exports.PatternStringExact = exports.PatternNumberExact = exports.PatternBooleanExact = exports.PatternString = exports.PatternNumber = exports.PatternBoolean = exports.Kind = exports.Hint = exports.Optional = exports.Readonly = exports.Transform = void 0;\n// --------------------------------------------------------------------------\n// Symbols\n// --------------------------------------------------------------------------\nexports.Transform = Symbol.for('TypeBox.Transform');\nexports.Readonly = Symbol.for('TypeBox.Readonly');\nexports.Optional = Symbol.for('TypeBox.Optional');\nexports.Hint = Symbol.for('TypeBox.Hint');\nexports.Kind = Symbol.for('TypeBox.Kind');\n// --------------------------------------------------------------------------\n// Patterns\n// --------------------------------------------------------------------------\nexports.PatternBoolean = '(true|false)';\nexports.PatternNumber = '(0|[1-9][0-9]*)';\nexports.PatternString = '(.*)';\nexports.PatternBooleanExact = `^${exports.PatternBoolean}$`;\nexports.PatternNumberExact = `^${exports.PatternNumber}$`;\nexports.PatternStringExact = `^${exports.PatternString}$`;\n/** A registry for user defined types */\nvar TypeRegistry;\n(function (TypeRegistry) {\n  const map = new Map();\n  /** Returns the entries in this registry */\n  function Entries() {\n    return new Map(map);\n  }\n  TypeRegistry.Entries = Entries;\n  /** Clears all user defined types */\n  function Clear() {\n    return map.clear();\n  }\n  TypeRegistry.Clear = Clear;\n  /** Deletes a registered type */\n  function Delete(kind) {\n    return map.delete(kind);\n  }\n  TypeRegistry.Delete = Delete;\n  /** Returns true if this registry contains this kind */\n  function Has(kind) {\n    return map.has(kind);\n  }\n  TypeRegistry.Has = Has;\n  /** Sets a validation function for a user defined type */\n  function Set(kind, func) {\n    map.set(kind, func);\n  }\n  TypeRegistry.Set = Set;\n  /** Gets a custom validation function for a user defined type */\n  function Get(kind) {\n    return map.get(kind);\n  }\n  TypeRegistry.Get = Get;\n})(TypeRegistry || (exports.TypeRegistry = TypeRegistry = {}));\n// --------------------------------------------------------------------------\n// TypeBoxError\n// --------------------------------------------------------------------------\nclass TypeBoxError extends Error {\n  constructor(message) {\n    super(message);\n  }\n}\nexports.TypeBoxError = TypeBoxError;\n/** A registry for user defined string formats */\nvar FormatRegistry;\n(function (FormatRegistry) {\n  const map = new Map();\n  /** Returns the entries in this registry */\n  function Entries() {\n    return new Map(map);\n  }\n  FormatRegistry.Entries = Entries;\n  /** Clears all user defined string formats */\n  function Clear() {\n    return map.clear();\n  }\n  FormatRegistry.Clear = Clear;\n  /** Deletes a registered format */\n  function Delete(format) {\n    return map.delete(format);\n  }\n  FormatRegistry.Delete = Delete;\n  /** Returns true if the user defined string format exists */\n  function Has(format) {\n    return map.has(format);\n  }\n  FormatRegistry.Has = Has;\n  /** Sets a validation function for a user defined string format */\n  function Set(format, func) {\n    map.set(format, func);\n  }\n  FormatRegistry.Set = Set;\n  /** Gets a validation function for a user defined string format */\n  function Get(format) {\n    return map.get(format);\n  }\n  FormatRegistry.Get = Get;\n})(FormatRegistry || (exports.FormatRegistry = FormatRegistry = {}));\n// --------------------------------------------------------------------------\n// ValueGuard\n// --------------------------------------------------------------------------\n/** Provides functions to type guard raw JavaScript values */\nvar ValueGuard;\n(function (ValueGuard) {\n  /** Returns true if this value is an array */\n  function IsArray(value) {\n    return Array.isArray(value);\n  }\n  ValueGuard.IsArray = IsArray;\n  /** Returns true if this value is bigint */\n  function IsBigInt(value) {\n    return typeof value === 'bigint';\n  }\n  ValueGuard.IsBigInt = IsBigInt;\n  /** Returns true if this value is a boolean */\n  function IsBoolean(value) {\n    return typeof value === 'boolean';\n  }\n  ValueGuard.IsBoolean = IsBoolean;\n  /** Returns true if this value is a Date object */\n  function IsDate(value) {\n    return value instanceof globalThis.Date;\n  }\n  ValueGuard.IsDate = IsDate;\n  /** Returns true if this value is null */\n  function IsNull(value) {\n    return value === null;\n  }\n  ValueGuard.IsNull = IsNull;\n  /** Returns true if this value is number */\n  function IsNumber(value) {\n    return typeof value === 'number';\n  }\n  ValueGuard.IsNumber = IsNumber;\n  /** Returns true if this value is an object */\n  function IsObject(value) {\n    return typeof value === 'object' && value !== null;\n  }\n  ValueGuard.IsObject = IsObject;\n  /** Returns true if this value is string */\n  function IsString(value) {\n    return typeof value === 'string';\n  }\n  ValueGuard.IsString = IsString;\n  /** Returns true if this value is a Uint8Array */\n  function IsUint8Array(value) {\n    return value instanceof globalThis.Uint8Array;\n  }\n  ValueGuard.IsUint8Array = IsUint8Array;\n  /** Returns true if this value is undefined */\n  function IsUndefined(value) {\n    return value === undefined;\n  }\n  ValueGuard.IsUndefined = IsUndefined;\n})(ValueGuard || (exports.ValueGuard = ValueGuard = {}));\n// --------------------------------------------------------------------------\n// TypeGuard\n// --------------------------------------------------------------------------\nclass TypeGuardUnknownTypeError extends TypeBoxError {}\nexports.TypeGuardUnknownTypeError = TypeGuardUnknownTypeError;\n/** Provides functions to test if JavaScript values are TypeBox types */\nvar TypeGuard;\n(function (TypeGuard) {\n  function IsPattern(value) {\n    try {\n      new RegExp(value);\n      return true;\n    } catch {\n      return false;\n    }\n  }\n  function IsControlCharacterFree(value) {\n    if (!ValueGuard.IsString(value)) return false;\n    for (let i = 0; i < value.length; i++) {\n      const code = value.charCodeAt(i);\n      if (code >= 7 && code <= 13 || code === 27 || code === 127) {\n        return false;\n      }\n    }\n    return true;\n  }\n  function IsAdditionalProperties(value) {\n    return IsOptionalBoolean(value) || TSchema(value);\n  }\n  function IsOptionalBigInt(value) {\n    return ValueGuard.IsUndefined(value) || ValueGuard.IsBigInt(value);\n  }\n  function IsOptionalNumber(value) {\n    return ValueGuard.IsUndefined(value) || ValueGuard.IsNumber(value);\n  }\n  function IsOptionalBoolean(value) {\n    return ValueGuard.IsUndefined(value) || ValueGuard.IsBoolean(value);\n  }\n  function IsOptionalString(value) {\n    return ValueGuard.IsUndefined(value) || ValueGuard.IsString(value);\n  }\n  function IsOptionalPattern(value) {\n    return ValueGuard.IsUndefined(value) || ValueGuard.IsString(value) && IsControlCharacterFree(value) && IsPattern(value);\n  }\n  function IsOptionalFormat(value) {\n    return ValueGuard.IsUndefined(value) || ValueGuard.IsString(value) && IsControlCharacterFree(value);\n  }\n  function IsOptionalSchema(value) {\n    return ValueGuard.IsUndefined(value) || TSchema(value);\n  }\n  // ----------------------------------------------------------------\n  // Types\n  // ----------------------------------------------------------------\n  /** Returns true if the given value is TAny */\n  function TAny(schema) {\n    // prettier-ignore\n    return TKindOf(schema, 'Any') && IsOptionalString(schema.$id);\n  }\n  TypeGuard.TAny = TAny;\n  /** Returns true if the given value is TArray */\n  function TArray(schema) {\n    return TKindOf(schema, 'Array') && schema.type === 'array' && IsOptionalString(schema.$id) && TSchema(schema.items) && IsOptionalNumber(schema.minItems) && IsOptionalNumber(schema.maxItems) && IsOptionalBoolean(schema.uniqueItems) && IsOptionalSchema(schema.contains) && IsOptionalNumber(schema.minContains) && IsOptionalNumber(schema.maxContains);\n  }\n  TypeGuard.TArray = TArray;\n  /** Returns true if the given value is TAsyncIterator */\n  function TAsyncIterator(schema) {\n    // prettier-ignore\n    return TKindOf(schema, 'AsyncIterator') && schema.type === 'AsyncIterator' && IsOptionalString(schema.$id) && TSchema(schema.items);\n  }\n  TypeGuard.TAsyncIterator = TAsyncIterator;\n  /** Returns true if the given value is TBigInt */\n  function TBigInt(schema) {\n    // prettier-ignore\n    return TKindOf(schema, 'BigInt') && schema.type === 'bigint' && IsOptionalString(schema.$id) && IsOptionalBigInt(schema.exclusiveMaximum) && IsOptionalBigInt(schema.exclusiveMinimum) && IsOptionalBigInt(schema.maximum) && IsOptionalBigInt(schema.minimum) && IsOptionalBigInt(schema.multipleOf);\n  }\n  TypeGuard.TBigInt = TBigInt;\n  /** Returns true if the given value is TBoolean */\n  function TBoolean(schema) {\n    // prettier-ignore\n    return TKindOf(schema, 'Boolean') && schema.type === 'boolean' && IsOptionalString(schema.$id);\n  }\n  TypeGuard.TBoolean = TBoolean;\n  /** Returns true if the given value is TConstructor */\n  function TConstructor(schema) {\n    // prettier-ignore\n    return TKindOf(schema, 'Constructor') && schema.type === 'Constructor' && IsOptionalString(schema.$id) && ValueGuard.IsArray(schema.parameters) && schema.parameters.every(schema => TSchema(schema)) && TSchema(schema.returns);\n  }\n  TypeGuard.TConstructor = TConstructor;\n  /** Returns true if the given value is TDate */\n  function TDate(schema) {\n    return TKindOf(schema, 'Date') && schema.type === 'Date' && IsOptionalString(schema.$id) && IsOptionalNumber(schema.exclusiveMaximumTimestamp) && IsOptionalNumber(schema.exclusiveMinimumTimestamp) && IsOptionalNumber(schema.maximumTimestamp) && IsOptionalNumber(schema.minimumTimestamp) && IsOptionalNumber(schema.multipleOfTimestamp);\n  }\n  TypeGuard.TDate = TDate;\n  /** Returns true if the given value is TFunction */\n  function TFunction(schema) {\n    // prettier-ignore\n    return TKindOf(schema, 'Function') && schema.type === 'Function' && IsOptionalString(schema.$id) && ValueGuard.IsArray(schema.parameters) && schema.parameters.every(schema => TSchema(schema)) && TSchema(schema.returns);\n  }\n  TypeGuard.TFunction = TFunction;\n  /** Returns true if the given value is TInteger */\n  function TInteger(schema) {\n    return TKindOf(schema, 'Integer') && schema.type === 'integer' && IsOptionalString(schema.$id) && IsOptionalNumber(schema.exclusiveMaximum) && IsOptionalNumber(schema.exclusiveMinimum) && IsOptionalNumber(schema.maximum) && IsOptionalNumber(schema.minimum) && IsOptionalNumber(schema.multipleOf);\n  }\n  TypeGuard.TInteger = TInteger;\n  /** Returns true if the given value is TIntersect */\n  function TIntersect(schema) {\n    // prettier-ignore\n    return TKindOf(schema, 'Intersect') && (ValueGuard.IsString(schema.type) && schema.type !== 'object' ? false : true) && ValueGuard.IsArray(schema.allOf) && schema.allOf.every(schema => TSchema(schema) && !TTransform(schema)) && IsOptionalString(schema.type) && (IsOptionalBoolean(schema.unevaluatedProperties) || IsOptionalSchema(schema.unevaluatedProperties)) && IsOptionalString(schema.$id);\n  }\n  TypeGuard.TIntersect = TIntersect;\n  /** Returns true if the given value is TIterator */\n  function TIterator(schema) {\n    // prettier-ignore\n    return TKindOf(schema, 'Iterator') && schema.type === 'Iterator' && IsOptionalString(schema.$id) && TSchema(schema.items);\n  }\n  TypeGuard.TIterator = TIterator;\n  /** Returns true if the given value is a TKind with the given name. */\n  function TKindOf(schema, kind) {\n    return TKind(schema) && schema[exports.Kind] === kind;\n  }\n  TypeGuard.TKindOf = TKindOf;\n  /** Returns true if the given value is TKind */\n  function TKind(schema) {\n    return ValueGuard.IsObject(schema) && exports.Kind in schema && ValueGuard.IsString(schema[exports.Kind]);\n  }\n  TypeGuard.TKind = TKind;\n  /** Returns true if the given value is TLiteral<string> */\n  function TLiteralString(schema) {\n    return TLiteral(schema) && ValueGuard.IsString(schema.const);\n  }\n  TypeGuard.TLiteralString = TLiteralString;\n  /** Returns true if the given value is TLiteral<number> */\n  function TLiteralNumber(schema) {\n    return TLiteral(schema) && ValueGuard.IsNumber(schema.const);\n  }\n  TypeGuard.TLiteralNumber = TLiteralNumber;\n  /** Returns true if the given value is TLiteral<boolean> */\n  function TLiteralBoolean(schema) {\n    return TLiteral(schema) && ValueGuard.IsBoolean(schema.const);\n  }\n  TypeGuard.TLiteralBoolean = TLiteralBoolean;\n  /** Returns true if the given value is TLiteral */\n  function TLiteral(schema) {\n    // prettier-ignore\n    return TKindOf(schema, 'Literal') && IsOptionalString(schema.$id) && (ValueGuard.IsBoolean(schema.const) || ValueGuard.IsNumber(schema.const) || ValueGuard.IsString(schema.const));\n  }\n  TypeGuard.TLiteral = TLiteral;\n  /** Returns true if the given value is TNever */\n  function TNever(schema) {\n    // prettier-ignore\n    return TKindOf(schema, 'Never') && ValueGuard.IsObject(schema.not) && Object.getOwnPropertyNames(schema.not).length === 0;\n  }\n  TypeGuard.TNever = TNever;\n  /** Returns true if the given value is TNot */\n  function TNot(schema) {\n    // prettier-ignore\n    return TKindOf(schema, 'Not') && TSchema(schema.not);\n  }\n  TypeGuard.TNot = TNot;\n  /** Returns true if the given value is TNull */\n  function TNull(schema) {\n    // prettier-ignore\n    return TKindOf(schema, 'Null') && schema.type === 'null' && IsOptionalString(schema.$id);\n  }\n  TypeGuard.TNull = TNull;\n  /** Returns true if the given value is TNumber */\n  function TNumber(schema) {\n    return TKindOf(schema, 'Number') && schema.type === 'number' && IsOptionalString(schema.$id) && IsOptionalNumber(schema.exclusiveMaximum) && IsOptionalNumber(schema.exclusiveMinimum) && IsOptionalNumber(schema.maximum) && IsOptionalNumber(schema.minimum) && IsOptionalNumber(schema.multipleOf);\n  }\n  TypeGuard.TNumber = TNumber;\n  /** Returns true if the given value is TObject */\n  function TObject(schema) {\n    // prettier-ignore\n    return TKindOf(schema, 'Object') && schema.type === 'object' && IsOptionalString(schema.$id) && ValueGuard.IsObject(schema.properties) && IsAdditionalProperties(schema.additionalProperties) && IsOptionalNumber(schema.minProperties) && IsOptionalNumber(schema.maxProperties) && Object.entries(schema.properties).every(([key, schema]) => IsControlCharacterFree(key) && TSchema(schema));\n  }\n  TypeGuard.TObject = TObject;\n  /** Returns true if the given value is TPromise */\n  function TPromise(schema) {\n    // prettier-ignore\n    return TKindOf(schema, 'Promise') && schema.type === 'Promise' && IsOptionalString(schema.$id) && TSchema(schema.item);\n  }\n  TypeGuard.TPromise = TPromise;\n  /** Returns true if the given value is TRecord */\n  function TRecord(schema) {\n    // prettier-ignore\n    return TKindOf(schema, 'Record') && schema.type === 'object' && IsOptionalString(schema.$id) && IsAdditionalProperties(schema.additionalProperties) && ValueGuard.IsObject(schema.patternProperties) && (schema => {\n      const keys = Object.getOwnPropertyNames(schema.patternProperties);\n      return keys.length === 1 && IsPattern(keys[0]) && ValueGuard.IsObject(schema.patternProperties) && TSchema(schema.patternProperties[keys[0]]);\n    })(schema);\n  }\n  TypeGuard.TRecord = TRecord;\n  /** Returns true if this value is TRecursive */\n  function TRecursive(schema) {\n    return ValueGuard.IsObject(schema) && exports.Hint in schema && schema[exports.Hint] === 'Recursive';\n  }\n  TypeGuard.TRecursive = TRecursive;\n  /** Returns true if the given value is TRef */\n  function TRef(schema) {\n    // prettier-ignore\n    return TKindOf(schema, 'Ref') && IsOptionalString(schema.$id) && ValueGuard.IsString(schema.$ref);\n  }\n  TypeGuard.TRef = TRef;\n  /** Returns true if the given value is TString */\n  function TString(schema) {\n    // prettier-ignore\n    return TKindOf(schema, 'String') && schema.type === 'string' && IsOptionalString(schema.$id) && IsOptionalNumber(schema.minLength) && IsOptionalNumber(schema.maxLength) && IsOptionalPattern(schema.pattern) && IsOptionalFormat(schema.format);\n  }\n  TypeGuard.TString = TString;\n  /** Returns true if the given value is TSymbol */\n  function TSymbol(schema) {\n    // prettier-ignore\n    return TKindOf(schema, 'Symbol') && schema.type === 'symbol' && IsOptionalString(schema.$id);\n  }\n  TypeGuard.TSymbol = TSymbol;\n  /** Returns true if the given value is TTemplateLiteral */\n  function TTemplateLiteral(schema) {\n    // prettier-ignore\n    return TKindOf(schema, 'TemplateLiteral') && schema.type === 'string' && ValueGuard.IsString(schema.pattern) && schema.pattern[0] === '^' && schema.pattern[schema.pattern.length - 1] === '$';\n  }\n  TypeGuard.TTemplateLiteral = TTemplateLiteral;\n  /** Returns true if the given value is TThis */\n  function TThis(schema) {\n    // prettier-ignore\n    return TKindOf(schema, 'This') && IsOptionalString(schema.$id) && ValueGuard.IsString(schema.$ref);\n  }\n  TypeGuard.TThis = TThis;\n  /** Returns true of this value is TTransform */\n  function TTransform(schema) {\n    return ValueGuard.IsObject(schema) && exports.Transform in schema;\n  }\n  TypeGuard.TTransform = TTransform;\n  /** Returns true if the given value is TTuple */\n  function TTuple(schema) {\n    // prettier-ignore\n    return TKindOf(schema, 'Tuple') && schema.type === 'array' && IsOptionalString(schema.$id) && ValueGuard.IsNumber(schema.minItems) && ValueGuard.IsNumber(schema.maxItems) && schema.minItems === schema.maxItems && (\n    // empty\n    ValueGuard.IsUndefined(schema.items) && ValueGuard.IsUndefined(schema.additionalItems) && schema.minItems === 0 || ValueGuard.IsArray(schema.items) && schema.items.every(schema => TSchema(schema)));\n  }\n  TypeGuard.TTuple = TTuple;\n  /** Returns true if the given value is TUndefined */\n  function TUndefined(schema) {\n    // prettier-ignore\n    return TKindOf(schema, 'Undefined') && schema.type === 'undefined' && IsOptionalString(schema.$id);\n  }\n  TypeGuard.TUndefined = TUndefined;\n  /** Returns true if the given value is TUnion<Literal<string | number>[]> */\n  function TUnionLiteral(schema) {\n    return TUnion(schema) && schema.anyOf.every(schema => TLiteralString(schema) || TLiteralNumber(schema));\n  }\n  TypeGuard.TUnionLiteral = TUnionLiteral;\n  /** Returns true if the given value is TUnion */\n  function TUnion(schema) {\n    // prettier-ignore\n    return TKindOf(schema, 'Union') && IsOptionalString(schema.$id) && ValueGuard.IsObject(schema) && ValueGuard.IsArray(schema.anyOf) && schema.anyOf.every(schema => TSchema(schema));\n  }\n  TypeGuard.TUnion = TUnion;\n  /** Returns true if the given value is TUint8Array */\n  function TUint8Array(schema) {\n    // prettier-ignore\n    return TKindOf(schema, 'Uint8Array') && schema.type === 'Uint8Array' && IsOptionalString(schema.$id) && IsOptionalNumber(schema.minByteLength) && IsOptionalNumber(schema.maxByteLength);\n  }\n  TypeGuard.TUint8Array = TUint8Array;\n  /** Returns true if the given value is TUnknown */\n  function TUnknown(schema) {\n    // prettier-ignore\n    return TKindOf(schema, 'Unknown') && IsOptionalString(schema.$id);\n  }\n  TypeGuard.TUnknown = TUnknown;\n  /** Returns true if the given value is a raw TUnsafe */\n  function TUnsafe(schema) {\n    return TKindOf(schema, 'Unsafe');\n  }\n  TypeGuard.TUnsafe = TUnsafe;\n  /** Returns true if the given value is TVoid */\n  function TVoid(schema) {\n    // prettier-ignore\n    return TKindOf(schema, 'Void') && schema.type === 'void' && IsOptionalString(schema.$id);\n  }\n  TypeGuard.TVoid = TVoid;\n  /** Returns true if this value has a Readonly symbol */\n  function TReadonly(schema) {\n    return ValueGuard.IsObject(schema) && schema[exports.Readonly] === 'Readonly';\n  }\n  TypeGuard.TReadonly = TReadonly;\n  /** Returns true if this value has a Optional symbol */\n  function TOptional(schema) {\n    return ValueGuard.IsObject(schema) && schema[exports.Optional] === 'Optional';\n  }\n  TypeGuard.TOptional = TOptional;\n  /** Returns true if the given value is TSchema */\n  function TSchema(schema) {\n    // prettier-ignore\n    return ValueGuard.IsObject(schema) && (TAny(schema) || TArray(schema) || TBoolean(schema) || TBigInt(schema) || TAsyncIterator(schema) || TConstructor(schema) || TDate(schema) || TFunction(schema) || TInteger(schema) || TIntersect(schema) || TIterator(schema) || TLiteral(schema) || TNever(schema) || TNot(schema) || TNull(schema) || TNumber(schema) || TObject(schema) || TPromise(schema) || TRecord(schema) || TRef(schema) || TString(schema) || TSymbol(schema) || TTemplateLiteral(schema) || TThis(schema) || TTuple(schema) || TUndefined(schema) || TUnion(schema) || TUint8Array(schema) || TUnknown(schema) || TUnsafe(schema) || TVoid(schema) || TKind(schema) && TypeRegistry.Has(schema[exports.Kind]));\n  }\n  TypeGuard.TSchema = TSchema;\n})(TypeGuard || (exports.TypeGuard = TypeGuard = {}));\n// --------------------------------------------------------------------------\n// ExtendsUndefined\n// --------------------------------------------------------------------------\n/** Fast undefined check used for properties of type undefined */\nvar ExtendsUndefined;\n(function (ExtendsUndefined) {\n  function Check(schema) {\n    return schema[exports.Kind] === 'Intersect' ? schema.allOf.every(schema => Check(schema)) : schema[exports.Kind] === 'Union' ? schema.anyOf.some(schema => Check(schema)) : schema[exports.Kind] === 'Undefined' ? true : schema[exports.Kind] === 'Not' ? !Check(schema.not) : false;\n  }\n  ExtendsUndefined.Check = Check;\n})(ExtendsUndefined || (exports.ExtendsUndefined = ExtendsUndefined = {}));\n// --------------------------------------------------------------------------\n// TypeExtends\n// --------------------------------------------------------------------------\nclass TypeExtendsError extends TypeBoxError {}\nexports.TypeExtendsError = TypeExtendsError;\nvar TypeExtendsResult;\n(function (TypeExtendsResult) {\n  TypeExtendsResult[TypeExtendsResult[\"Union\"] = 0] = \"Union\";\n  TypeExtendsResult[TypeExtendsResult[\"True\"] = 1] = \"True\";\n  TypeExtendsResult[TypeExtendsResult[\"False\"] = 2] = \"False\";\n})(TypeExtendsResult || (exports.TypeExtendsResult = TypeExtendsResult = {}));\nvar TypeExtends;\n(function (TypeExtends) {\n  // --------------------------------------------------------------------------\n  // IntoBooleanResult\n  // --------------------------------------------------------------------------\n  function IntoBooleanResult(result) {\n    return result === TypeExtendsResult.False ? result : TypeExtendsResult.True;\n  }\n  // --------------------------------------------------------------------------\n  // Throw\n  // --------------------------------------------------------------------------\n  function Throw(message) {\n    throw new TypeExtendsError(message);\n  }\n  // --------------------------------------------------------------------------\n  // StructuralRight\n  // --------------------------------------------------------------------------\n  function IsStructuralRight(right) {\n    // prettier-ignore\n    return TypeGuard.TNever(right) || TypeGuard.TIntersect(right) || TypeGuard.TUnion(right) || TypeGuard.TUnknown(right) || TypeGuard.TAny(right);\n  }\n  function StructuralRight(left, right) {\n    // prettier-ignore\n    return TypeGuard.TNever(right) ? TNeverRight(left, right) : TypeGuard.TIntersect(right) ? TIntersectRight(left, right) : TypeGuard.TUnion(right) ? TUnionRight(left, right) : TypeGuard.TUnknown(right) ? TUnknownRight(left, right) : TypeGuard.TAny(right) ? TAnyRight(left, right) : Throw('StructuralRight');\n  }\n  // --------------------------------------------------------------------------\n  // Any\n  // --------------------------------------------------------------------------\n  function TAnyRight(left, right) {\n    return TypeExtendsResult.True;\n  }\n  function TAny(left, right) {\n    // prettier-ignore\n    return TypeGuard.TIntersect(right) ? TIntersectRight(left, right) : TypeGuard.TUnion(right) && right.anyOf.some(schema => TypeGuard.TAny(schema) || TypeGuard.TUnknown(schema)) ? TypeExtendsResult.True : TypeGuard.TUnion(right) ? TypeExtendsResult.Union : TypeGuard.TUnknown(right) ? TypeExtendsResult.True : TypeGuard.TAny(right) ? TypeExtendsResult.True : TypeExtendsResult.Union;\n  }\n  // --------------------------------------------------------------------------\n  // Array\n  // --------------------------------------------------------------------------\n  function TArrayRight(left, right) {\n    // prettier-ignore\n    return TypeGuard.TUnknown(left) ? TypeExtendsResult.False : TypeGuard.TAny(left) ? TypeExtendsResult.Union : TypeGuard.TNever(left) ? TypeExtendsResult.True : TypeExtendsResult.False;\n  }\n  function TArray(left, right) {\n    // prettier-ignore\n    return TypeGuard.TObject(right) && IsObjectArrayLike(right) ? TypeExtendsResult.True : IsStructuralRight(right) ? StructuralRight(left, right) : !TypeGuard.TArray(right) ? TypeExtendsResult.False : IntoBooleanResult(Visit(left.items, right.items));\n  }\n  // --------------------------------------------------------------------------\n  // AsyncIterator\n  // --------------------------------------------------------------------------\n  function TAsyncIterator(left, right) {\n    // prettier-ignore\n    return IsStructuralRight(right) ? StructuralRight(left, right) : !TypeGuard.TAsyncIterator(right) ? TypeExtendsResult.False : IntoBooleanResult(Visit(left.items, right.items));\n  }\n  // --------------------------------------------------------------------------\n  // BigInt\n  // --------------------------------------------------------------------------\n  function TBigInt(left, right) {\n    // prettier-ignore\n    return IsStructuralRight(right) ? StructuralRight(left, right) : TypeGuard.TObject(right) ? TObjectRight(left, right) : TypeGuard.TRecord(right) ? TRecordRight(left, right) : TypeGuard.TBigInt(right) ? TypeExtendsResult.True : TypeExtendsResult.False;\n  }\n  // --------------------------------------------------------------------------\n  // Boolean\n  // --------------------------------------------------------------------------\n  function TBooleanRight(left, right) {\n    return TypeGuard.TLiteral(left) && ValueGuard.IsBoolean(left.const) ? TypeExtendsResult.True : TypeGuard.TBoolean(left) ? TypeExtendsResult.True : TypeExtendsResult.False;\n  }\n  function TBoolean(left, right) {\n    // prettier-ignore\n    return IsStructuralRight(right) ? StructuralRight(left, right) : TypeGuard.TObject(right) ? TObjectRight(left, right) : TypeGuard.TRecord(right) ? TRecordRight(left, right) : TypeGuard.TBoolean(right) ? TypeExtendsResult.True : TypeExtendsResult.False;\n  }\n  // --------------------------------------------------------------------------\n  // Constructor\n  // --------------------------------------------------------------------------\n  function TConstructor(left, right) {\n    // prettier-ignore\n    return IsStructuralRight(right) ? StructuralRight(left, right) : TypeGuard.TObject(right) ? TObjectRight(left, right) : !TypeGuard.TConstructor(right) ? TypeExtendsResult.False : left.parameters.length > right.parameters.length ? TypeExtendsResult.False : !left.parameters.every((schema, index) => IntoBooleanResult(Visit(right.parameters[index], schema)) === TypeExtendsResult.True) ? TypeExtendsResult.False : IntoBooleanResult(Visit(left.returns, right.returns));\n  }\n  // --------------------------------------------------------------------------\n  // Date\n  // --------------------------------------------------------------------------\n  function TDate(left, right) {\n    // prettier-ignore\n    return IsStructuralRight(right) ? StructuralRight(left, right) : TypeGuard.TObject(right) ? TObjectRight(left, right) : TypeGuard.TRecord(right) ? TRecordRight(left, right) : TypeGuard.TDate(right) ? TypeExtendsResult.True : TypeExtendsResult.False;\n  }\n  // --------------------------------------------------------------------------\n  // Function\n  // --------------------------------------------------------------------------\n  function TFunction(left, right) {\n    // prettier-ignore\n    return IsStructuralRight(right) ? StructuralRight(left, right) : TypeGuard.TObject(right) ? TObjectRight(left, right) : !TypeGuard.TFunction(right) ? TypeExtendsResult.False : left.parameters.length > right.parameters.length ? TypeExtendsResult.False : !left.parameters.every((schema, index) => IntoBooleanResult(Visit(right.parameters[index], schema)) === TypeExtendsResult.True) ? TypeExtendsResult.False : IntoBooleanResult(Visit(left.returns, right.returns));\n  }\n  // --------------------------------------------------------------------------\n  // Integer\n  // --------------------------------------------------------------------------\n  function TIntegerRight(left, right) {\n    // prettier-ignore\n    return TypeGuard.TLiteral(left) && ValueGuard.IsNumber(left.const) ? TypeExtendsResult.True : TypeGuard.TNumber(left) || TypeGuard.TInteger(left) ? TypeExtendsResult.True : TypeExtendsResult.False;\n  }\n  function TInteger(left, right) {\n    // prettier-ignore\n    return TypeGuard.TInteger(right) || TypeGuard.TNumber(right) ? TypeExtendsResult.True : IsStructuralRight(right) ? StructuralRight(left, right) : TypeGuard.TObject(right) ? TObjectRight(left, right) : TypeGuard.TRecord(right) ? TRecordRight(left, right) : TypeExtendsResult.False;\n  }\n  // --------------------------------------------------------------------------\n  // Intersect\n  // --------------------------------------------------------------------------\n  function TIntersectRight(left, right) {\n    // prettier-ignore\n    return right.allOf.every(schema => Visit(left, schema) === TypeExtendsResult.True) ? TypeExtendsResult.True : TypeExtendsResult.False;\n  }\n  function TIntersect(left, right) {\n    // prettier-ignore\n    return left.allOf.some(schema => Visit(schema, right) === TypeExtendsResult.True) ? TypeExtendsResult.True : TypeExtendsResult.False;\n  }\n  // --------------------------------------------------------------------------\n  // Iterator\n  // --------------------------------------------------------------------------\n  function TIterator(left, right) {\n    // prettier-ignore\n    return IsStructuralRight(right) ? StructuralRight(left, right) : !TypeGuard.TIterator(right) ? TypeExtendsResult.False : IntoBooleanResult(Visit(left.items, right.items));\n  }\n  // --------------------------------------------------------------------------\n  // Literal\n  // --------------------------------------------------------------------------\n  function TLiteral(left, right) {\n    // prettier-ignore\n    return TypeGuard.TLiteral(right) && right.const === left.const ? TypeExtendsResult.True : IsStructuralRight(right) ? StructuralRight(left, right) : TypeGuard.TObject(right) ? TObjectRight(left, right) : TypeGuard.TRecord(right) ? TRecordRight(left, right) : TypeGuard.TString(right) ? TStringRight(left, right) : TypeGuard.TNumber(right) ? TNumberRight(left, right) : TypeGuard.TInteger(right) ? TIntegerRight(left, right) : TypeGuard.TBoolean(right) ? TBooleanRight(left, right) : TypeExtendsResult.False;\n  }\n  // --------------------------------------------------------------------------\n  // Never\n  // --------------------------------------------------------------------------\n  function TNeverRight(left, right) {\n    return TypeExtendsResult.False;\n  }\n  function TNever(left, right) {\n    return TypeExtendsResult.True;\n  }\n  // --------------------------------------------------------------------------\n  // Not\n  // --------------------------------------------------------------------------\n  function UnwrapTNot(schema) {\n    let [current, depth] = [schema, 0];\n    while (true) {\n      if (!TypeGuard.TNot(current)) break;\n      current = current.not;\n      depth += 1;\n    }\n    return depth % 2 === 0 ? current : exports.Type.Unknown();\n  }\n  function TNot(left, right) {\n    // TypeScript has no concept of negated types, and attempts to correctly check the negated\n    // type at runtime would put TypeBox at odds with TypeScripts ability to statically infer\n    // the type. Instead we unwrap to either unknown or T and continue evaluating.\n    // prettier-ignore\n    return TypeGuard.TNot(left) ? Visit(UnwrapTNot(left), right) : TypeGuard.TNot(right) ? Visit(left, UnwrapTNot(right)) : Throw('Invalid fallthrough for Not');\n  }\n  // --------------------------------------------------------------------------\n  // Null\n  // --------------------------------------------------------------------------\n  function TNull(left, right) {\n    // prettier-ignore\n    return IsStructuralRight(right) ? StructuralRight(left, right) : TypeGuard.TObject(right) ? TObjectRight(left, right) : TypeGuard.TRecord(right) ? TRecordRight(left, right) : TypeGuard.TNull(right) ? TypeExtendsResult.True : TypeExtendsResult.False;\n  }\n  // --------------------------------------------------------------------------\n  // Number\n  // --------------------------------------------------------------------------\n  function TNumberRight(left, right) {\n    // prettier-ignore\n    return TypeGuard.TLiteralNumber(left) ? TypeExtendsResult.True : TypeGuard.TNumber(left) || TypeGuard.TInteger(left) ? TypeExtendsResult.True : TypeExtendsResult.False;\n  }\n  function TNumber(left, right) {\n    // prettier-ignore\n    return IsStructuralRight(right) ? StructuralRight(left, right) : TypeGuard.TObject(right) ? TObjectRight(left, right) : TypeGuard.TRecord(right) ? TRecordRight(left, right) : TypeGuard.TInteger(right) || TypeGuard.TNumber(right) ? TypeExtendsResult.True : TypeExtendsResult.False;\n  }\n  // --------------------------------------------------------------------------\n  // Object\n  // --------------------------------------------------------------------------\n  function IsObjectPropertyCount(schema, count) {\n    return Object.getOwnPropertyNames(schema.properties).length === count;\n  }\n  function IsObjectStringLike(schema) {\n    return IsObjectArrayLike(schema);\n  }\n  function IsObjectSymbolLike(schema) {\n    // prettier-ignore\n    return IsObjectPropertyCount(schema, 0) || IsObjectPropertyCount(schema, 1) && 'description' in schema.properties && TypeGuard.TUnion(schema.properties.description) && schema.properties.description.anyOf.length === 2 && (TypeGuard.TString(schema.properties.description.anyOf[0]) && TypeGuard.TUndefined(schema.properties.description.anyOf[1]) || TypeGuard.TString(schema.properties.description.anyOf[1]) && TypeGuard.TUndefined(schema.properties.description.anyOf[0]));\n  }\n  function IsObjectNumberLike(schema) {\n    return IsObjectPropertyCount(schema, 0);\n  }\n  function IsObjectBooleanLike(schema) {\n    return IsObjectPropertyCount(schema, 0);\n  }\n  function IsObjectBigIntLike(schema) {\n    return IsObjectPropertyCount(schema, 0);\n  }\n  function IsObjectDateLike(schema) {\n    return IsObjectPropertyCount(schema, 0);\n  }\n  function IsObjectUint8ArrayLike(schema) {\n    return IsObjectArrayLike(schema);\n  }\n  function IsObjectFunctionLike(schema) {\n    const length = exports.Type.Number();\n    return IsObjectPropertyCount(schema, 0) || IsObjectPropertyCount(schema, 1) && 'length' in schema.properties && IntoBooleanResult(Visit(schema.properties['length'], length)) === TypeExtendsResult.True;\n  }\n  function IsObjectConstructorLike(schema) {\n    return IsObjectPropertyCount(schema, 0);\n  }\n  function IsObjectArrayLike(schema) {\n    const length = exports.Type.Number();\n    return IsObjectPropertyCount(schema, 0) || IsObjectPropertyCount(schema, 1) && 'length' in schema.properties && IntoBooleanResult(Visit(schema.properties['length'], length)) === TypeExtendsResult.True;\n  }\n  function IsObjectPromiseLike(schema) {\n    const then = exports.Type.Function([exports.Type.Any()], exports.Type.Any());\n    return IsObjectPropertyCount(schema, 0) || IsObjectPropertyCount(schema, 1) && 'then' in schema.properties && IntoBooleanResult(Visit(schema.properties['then'], then)) === TypeExtendsResult.True;\n  }\n  // --------------------------------------------------------------------------\n  // Property\n  // --------------------------------------------------------------------------\n  function Property(left, right) {\n    // prettier-ignore\n    return Visit(left, right) === TypeExtendsResult.False ? TypeExtendsResult.False : TypeGuard.TOptional(left) && !TypeGuard.TOptional(right) ? TypeExtendsResult.False : TypeExtendsResult.True;\n  }\n  function TObjectRight(left, right) {\n    // prettier-ignore\n    return TypeGuard.TUnknown(left) ? TypeExtendsResult.False : TypeGuard.TAny(left) ? TypeExtendsResult.Union : TypeGuard.TNever(left) || TypeGuard.TLiteralString(left) && IsObjectStringLike(right) || TypeGuard.TLiteralNumber(left) && IsObjectNumberLike(right) || TypeGuard.TLiteralBoolean(left) && IsObjectBooleanLike(right) || TypeGuard.TSymbol(left) && IsObjectSymbolLike(right) || TypeGuard.TBigInt(left) && IsObjectBigIntLike(right) || TypeGuard.TString(left) && IsObjectStringLike(right) || TypeGuard.TSymbol(left) && IsObjectSymbolLike(right) || TypeGuard.TNumber(left) && IsObjectNumberLike(right) || TypeGuard.TInteger(left) && IsObjectNumberLike(right) || TypeGuard.TBoolean(left) && IsObjectBooleanLike(right) || TypeGuard.TUint8Array(left) && IsObjectUint8ArrayLike(right) || TypeGuard.TDate(left) && IsObjectDateLike(right) || TypeGuard.TConstructor(left) && IsObjectConstructorLike(right) || TypeGuard.TFunction(left) && IsObjectFunctionLike(right) ? TypeExtendsResult.True : TypeGuard.TRecord(left) && TypeGuard.TString(RecordKey(left)) ? (() => {\n      // When expressing a Record with literal key values, the Record is converted into a Object with\n      // the Hint assigned as `Record`. This is used to invert the extends logic.\n      return right[exports.Hint] === 'Record' ? TypeExtendsResult.True : TypeExtendsResult.False;\n    })() : TypeGuard.TRecord(left) && TypeGuard.TNumber(RecordKey(left)) ? (() => {\n      return IsObjectPropertyCount(right, 0) ? TypeExtendsResult.True : TypeExtendsResult.False;\n    })() : TypeExtendsResult.False;\n  }\n  function TObject(left, right) {\n    // prettier-ignore\n    return IsStructuralRight(right) ? StructuralRight(left, right) : TypeGuard.TRecord(right) ? TRecordRight(left, right) : !TypeGuard.TObject(right) ? TypeExtendsResult.False : (() => {\n      for (const key of Object.getOwnPropertyNames(right.properties)) {\n        if (!(key in left.properties) && !TypeGuard.TOptional(right.properties[key])) {\n          return TypeExtendsResult.False;\n        }\n        if (TypeGuard.TOptional(right.properties[key])) {\n          return TypeExtendsResult.True;\n        }\n        if (Property(left.properties[key], right.properties[key]) === TypeExtendsResult.False) {\n          return TypeExtendsResult.False;\n        }\n      }\n      return TypeExtendsResult.True;\n    })();\n  }\n  // --------------------------------------------------------------------------\n  // Promise\n  // --------------------------------------------------------------------------\n  function TPromise(left, right) {\n    // prettier-ignore\n    return IsStructuralRight(right) ? StructuralRight(left, right) : TypeGuard.TObject(right) && IsObjectPromiseLike(right) ? TypeExtendsResult.True : !TypeGuard.TPromise(right) ? TypeExtendsResult.False : IntoBooleanResult(Visit(left.item, right.item));\n  }\n  // --------------------------------------------------------------------------\n  // Record\n  // --------------------------------------------------------------------------\n  function RecordKey(schema) {\n    // prettier-ignore\n    return exports.PatternNumberExact in schema.patternProperties ? exports.Type.Number() : exports.PatternStringExact in schema.patternProperties ? exports.Type.String() : Throw('Unknown record key pattern');\n  }\n  function RecordValue(schema) {\n    // prettier-ignore\n    return exports.PatternNumberExact in schema.patternProperties ? schema.patternProperties[exports.PatternNumberExact] : exports.PatternStringExact in schema.patternProperties ? schema.patternProperties[exports.PatternStringExact] : Throw('Unable to get record value schema');\n  }\n  function TRecordRight(left, right) {\n    const [Key, Value] = [RecordKey(right), RecordValue(right)];\n    // prettier-ignore\n    return TypeGuard.TLiteralString(left) && TypeGuard.TNumber(Key) && IntoBooleanResult(Visit(left, Value)) === TypeExtendsResult.True ? TypeExtendsResult.True : TypeGuard.TUint8Array(left) && TypeGuard.TNumber(Key) ? Visit(left, Value) : TypeGuard.TString(left) && TypeGuard.TNumber(Key) ? Visit(left, Value) : TypeGuard.TArray(left) && TypeGuard.TNumber(Key) ? Visit(left, Value) : TypeGuard.TObject(left) ? (() => {\n      for (const key of Object.getOwnPropertyNames(left.properties)) {\n        if (Property(Value, left.properties[key]) === TypeExtendsResult.False) {\n          return TypeExtendsResult.False;\n        }\n      }\n      return TypeExtendsResult.True;\n    })() : TypeExtendsResult.False;\n  }\n  function TRecord(left, right) {\n    // prettier-ignore\n    return IsStructuralRight(right) ? StructuralRight(left, right) : TypeGuard.TObject(right) ? TObjectRight(left, right) : !TypeGuard.TRecord(right) ? TypeExtendsResult.False : Visit(RecordValue(left), RecordValue(right));\n  }\n  // --------------------------------------------------------------------------\n  // String\n  // --------------------------------------------------------------------------\n  function TStringRight(left, right) {\n    // prettier-ignore\n    return TypeGuard.TLiteral(left) && ValueGuard.IsString(left.const) ? TypeExtendsResult.True : TypeGuard.TString(left) ? TypeExtendsResult.True : TypeExtendsResult.False;\n  }\n  function TString(left, right) {\n    // prettier-ignore\n    return IsStructuralRight(right) ? StructuralRight(left, right) : TypeGuard.TObject(right) ? TObjectRight(left, right) : TypeGuard.TRecord(right) ? TRecordRight(left, right) : TypeGuard.TString(right) ? TypeExtendsResult.True : TypeExtendsResult.False;\n  }\n  // --------------------------------------------------------------------------\n  // Symbol\n  // --------------------------------------------------------------------------\n  function TSymbol(left, right) {\n    // prettier-ignore\n    return IsStructuralRight(right) ? StructuralRight(left, right) : TypeGuard.TObject(right) ? TObjectRight(left, right) : TypeGuard.TRecord(right) ? TRecordRight(left, right) : TypeGuard.TSymbol(right) ? TypeExtendsResult.True : TypeExtendsResult.False;\n  }\n  // --------------------------------------------------------------------------\n  // TemplateLiteral\n  // --------------------------------------------------------------------------\n  function TTemplateLiteral(left, right) {\n    // TemplateLiteral types are resolved to either unions for finite expressions or string\n    // for infinite expressions. Here we call to TemplateLiteralResolver to resolve for\n    // either type and continue evaluating.\n    // prettier-ignore\n    return TypeGuard.TTemplateLiteral(left) ? Visit(TemplateLiteralResolver.Resolve(left), right) : TypeGuard.TTemplateLiteral(right) ? Visit(left, TemplateLiteralResolver.Resolve(right)) : Throw('Invalid fallthrough for TemplateLiteral');\n  }\n  // --------------------------------------------------------------------------\n  // Tuple\n  // --------------------------------------------------------------------------\n  function IsArrayOfTuple(left, right) {\n    // prettier-ignore\n    return TypeGuard.TArray(right) && left.items !== undefined && left.items.every(schema => Visit(schema, right.items) === TypeExtendsResult.True);\n  }\n  function TTupleRight(left, right) {\n    // prettier-ignore\n    return TypeGuard.TNever(left) ? TypeExtendsResult.True : TypeGuard.TUnknown(left) ? TypeExtendsResult.False : TypeGuard.TAny(left) ? TypeExtendsResult.Union : TypeExtendsResult.False;\n  }\n  function TTuple(left, right) {\n    // prettier-ignore\n    return IsStructuralRight(right) ? StructuralRight(left, right) : TypeGuard.TObject(right) && IsObjectArrayLike(right) ? TypeExtendsResult.True : TypeGuard.TArray(right) && IsArrayOfTuple(left, right) ? TypeExtendsResult.True : !TypeGuard.TTuple(right) ? TypeExtendsResult.False : ValueGuard.IsUndefined(left.items) && !ValueGuard.IsUndefined(right.items) || !ValueGuard.IsUndefined(left.items) && ValueGuard.IsUndefined(right.items) ? TypeExtendsResult.False : ValueGuard.IsUndefined(left.items) && !ValueGuard.IsUndefined(right.items) ? TypeExtendsResult.True : left.items.every((schema, index) => Visit(schema, right.items[index]) === TypeExtendsResult.True) ? TypeExtendsResult.True : TypeExtendsResult.False;\n  }\n  // --------------------------------------------------------------------------\n  // Uint8Array\n  // --------------------------------------------------------------------------\n  function TUint8Array(left, right) {\n    // prettier-ignore\n    return IsStructuralRight(right) ? StructuralRight(left, right) : TypeGuard.TObject(right) ? TObjectRight(left, right) : TypeGuard.TRecord(right) ? TRecordRight(left, right) : TypeGuard.TUint8Array(right) ? TypeExtendsResult.True : TypeExtendsResult.False;\n  }\n  // --------------------------------------------------------------------------\n  // Undefined\n  // --------------------------------------------------------------------------\n  function TUndefined(left, right) {\n    // prettier-ignore\n    return IsStructuralRight(right) ? StructuralRight(left, right) : TypeGuard.TObject(right) ? TObjectRight(left, right) : TypeGuard.TRecord(right) ? TRecordRight(left, right) : TypeGuard.TVoid(right) ? VoidRight(left, right) : TypeGuard.TUndefined(right) ? TypeExtendsResult.True : TypeExtendsResult.False;\n  }\n  // --------------------------------------------------------------------------\n  // Union\n  // --------------------------------------------------------------------------\n  function TUnionRight(left, right) {\n    // prettier-ignore\n    return right.anyOf.some(schema => Visit(left, schema) === TypeExtendsResult.True) ? TypeExtendsResult.True : TypeExtendsResult.False;\n  }\n  function TUnion(left, right) {\n    // prettier-ignore\n    return left.anyOf.every(schema => Visit(schema, right) === TypeExtendsResult.True) ? TypeExtendsResult.True : TypeExtendsResult.False;\n  }\n  // --------------------------------------------------------------------------\n  // Unknown\n  // --------------------------------------------------------------------------\n  function TUnknownRight(left, right) {\n    return TypeExtendsResult.True;\n  }\n  function TUnknown(left, right) {\n    // prettier-ignore\n    return TypeGuard.TNever(right) ? TNeverRight(left, right) : TypeGuard.TIntersect(right) ? TIntersectRight(left, right) : TypeGuard.TUnion(right) ? TUnionRight(left, right) : TypeGuard.TAny(right) ? TAnyRight(left, right) : TypeGuard.TString(right) ? TStringRight(left, right) : TypeGuard.TNumber(right) ? TNumberRight(left, right) : TypeGuard.TInteger(right) ? TIntegerRight(left, right) : TypeGuard.TBoolean(right) ? TBooleanRight(left, right) : TypeGuard.TArray(right) ? TArrayRight(left, right) : TypeGuard.TTuple(right) ? TTupleRight(left, right) : TypeGuard.TObject(right) ? TObjectRight(left, right) : TypeGuard.TUnknown(right) ? TypeExtendsResult.True : TypeExtendsResult.False;\n  }\n  // --------------------------------------------------------------------------\n  // Void\n  // --------------------------------------------------------------------------\n  function VoidRight(left, right) {\n    // prettier-ignore\n    return TypeGuard.TUndefined(left) ? TypeExtendsResult.True : TypeGuard.TUndefined(left) ? TypeExtendsResult.True : TypeExtendsResult.False;\n  }\n  function TVoid(left, right) {\n    // prettier-ignore\n    return TypeGuard.TIntersect(right) ? TIntersectRight(left, right) : TypeGuard.TUnion(right) ? TUnionRight(left, right) : TypeGuard.TUnknown(right) ? TUnknownRight(left, right) : TypeGuard.TAny(right) ? TAnyRight(left, right) : TypeGuard.TObject(right) ? TObjectRight(left, right) : TypeGuard.TVoid(right) ? TypeExtendsResult.True : TypeExtendsResult.False;\n  }\n  function Visit(left, right) {\n    // prettier-ignore\n    return (\n      // resolvable\n      TypeGuard.TTemplateLiteral(left) || TypeGuard.TTemplateLiteral(right) ? TTemplateLiteral(left, right) : TypeGuard.TNot(left) || TypeGuard.TNot(right) ? TNot(left, right) :\n      // standard\n      TypeGuard.TAny(left) ? TAny(left, right) : TypeGuard.TArray(left) ? TArray(left, right) : TypeGuard.TBigInt(left) ? TBigInt(left, right) : TypeGuard.TBoolean(left) ? TBoolean(left, right) : TypeGuard.TAsyncIterator(left) ? TAsyncIterator(left, right) : TypeGuard.TConstructor(left) ? TConstructor(left, right) : TypeGuard.TDate(left) ? TDate(left, right) : TypeGuard.TFunction(left) ? TFunction(left, right) : TypeGuard.TInteger(left) ? TInteger(left, right) : TypeGuard.TIntersect(left) ? TIntersect(left, right) : TypeGuard.TIterator(left) ? TIterator(left, right) : TypeGuard.TLiteral(left) ? TLiteral(left, right) : TypeGuard.TNever(left) ? TNever(left, right) : TypeGuard.TNull(left) ? TNull(left, right) : TypeGuard.TNumber(left) ? TNumber(left, right) : TypeGuard.TObject(left) ? TObject(left, right) : TypeGuard.TRecord(left) ? TRecord(left, right) : TypeGuard.TString(left) ? TString(left, right) : TypeGuard.TSymbol(left) ? TSymbol(left, right) : TypeGuard.TTuple(left) ? TTuple(left, right) : TypeGuard.TPromise(left) ? TPromise(left, right) : TypeGuard.TUint8Array(left) ? TUint8Array(left, right) : TypeGuard.TUndefined(left) ? TUndefined(left, right) : TypeGuard.TUnion(left) ? TUnion(left, right) : TypeGuard.TUnknown(left) ? TUnknown(left, right) : TypeGuard.TVoid(left) ? TVoid(left, right) : Throw(`Unknown left type operand '${left[exports.Kind]}'`)\n    );\n  }\n  function Extends(left, right) {\n    return Visit(left, right);\n  }\n  TypeExtends.Extends = Extends;\n})(TypeExtends || (exports.TypeExtends = TypeExtends = {}));\n// --------------------------------------------------------------------------\n// TypeClone\n// --------------------------------------------------------------------------\n/** Specialized Clone for Types */\nvar TypeClone;\n(function (TypeClone) {\n  function ArrayType(value) {\n    return value.map(value => Visit(value));\n  }\n  function DateType(value) {\n    return new Date(value.getTime());\n  }\n  function Uint8ArrayType(value) {\n    return new Uint8Array(value);\n  }\n  function ObjectType(value) {\n    const clonedProperties = Object.getOwnPropertyNames(value).reduce((acc, key) => ({\n      ...acc,\n      [key]: Visit(value[key])\n    }), {});\n    const clonedSymbols = Object.getOwnPropertySymbols(value).reduce((acc, key) => ({\n      ...acc,\n      [key]: Visit(value[key])\n    }), {});\n    return {\n      ...clonedProperties,\n      ...clonedSymbols\n    };\n  }\n  function Visit(value) {\n    // prettier-ignore\n    return ValueGuard.IsArray(value) ? ArrayType(value) : ValueGuard.IsDate(value) ? DateType(value) : ValueGuard.IsUint8Array(value) ? Uint8ArrayType(value) : ValueGuard.IsObject(value) ? ObjectType(value) : value;\n  }\n  /** Clones a Rest */\n  function Rest(schemas) {\n    return schemas.map(schema => Type(schema));\n  }\n  TypeClone.Rest = Rest;\n  /** Clones a Type */\n  function Type(schema, options = {}) {\n    return {\n      ...Visit(schema),\n      ...options\n    };\n  }\n  TypeClone.Type = Type;\n})(TypeClone || (exports.TypeClone = TypeClone = {}));\n// --------------------------------------------------------------------------\n// IndexedAccessor\n// --------------------------------------------------------------------------\nvar IndexedAccessor;\n(function (IndexedAccessor) {\n  function OptionalUnwrap(schema) {\n    return schema.map(schema => {\n      const {\n        [exports.Optional]: _,\n        ...clone\n      } = TypeClone.Type(schema);\n      return clone;\n    });\n  }\n  function IsIntersectOptional(schema) {\n    return schema.every(schema => TypeGuard.TOptional(schema));\n  }\n  function IsUnionOptional(schema) {\n    return schema.some(schema => TypeGuard.TOptional(schema));\n  }\n  function ResolveIntersect(schema) {\n    return IsIntersectOptional(schema.allOf) ? exports.Type.Optional(exports.Type.Intersect(OptionalUnwrap(schema.allOf))) : schema;\n  }\n  function ResolveUnion(schema) {\n    return IsUnionOptional(schema.anyOf) ? exports.Type.Optional(exports.Type.Union(OptionalUnwrap(schema.anyOf))) : schema;\n  }\n  function ResolveOptional(schema) {\n    // prettier-ignore\n    return schema[exports.Kind] === 'Intersect' ? ResolveIntersect(schema) : schema[exports.Kind] === 'Union' ? ResolveUnion(schema) : schema;\n  }\n  function TIntersect(schema, key) {\n    const resolved = schema.allOf.reduce((acc, schema) => {\n      const indexed = Visit(schema, key);\n      return indexed[exports.Kind] === 'Never' ? acc : [...acc, indexed];\n    }, []);\n    return ResolveOptional(exports.Type.Intersect(resolved));\n  }\n  function TUnion(schema, key) {\n    const resolved = schema.anyOf.map(schema => Visit(schema, key));\n    return ResolveOptional(exports.Type.Union(resolved));\n  }\n  function TObject(schema, key) {\n    const property = schema.properties[key];\n    return ValueGuard.IsUndefined(property) ? exports.Type.Never() : exports.Type.Union([property]);\n  }\n  function TTuple(schema, key) {\n    const items = schema.items;\n    if (ValueGuard.IsUndefined(items)) return exports.Type.Never();\n    const element = items[key]; //\n    if (ValueGuard.IsUndefined(element)) return exports.Type.Never();\n    return element;\n  }\n  function Visit(schema, key) {\n    // prettier-ignore\n    return schema[exports.Kind] === 'Intersect' ? TIntersect(schema, key) : schema[exports.Kind] === 'Union' ? TUnion(schema, key) : schema[exports.Kind] === 'Object' ? TObject(schema, key) : schema[exports.Kind] === 'Tuple' ? TTuple(schema, key) : exports.Type.Never();\n  }\n  function Resolve(schema, keys, options = {}) {\n    const resolved = keys.map(key => Visit(schema, key.toString()));\n    return ResolveOptional(exports.Type.Union(resolved, options));\n  }\n  IndexedAccessor.Resolve = Resolve;\n})(IndexedAccessor || (exports.IndexedAccessor = IndexedAccessor = {}));\n// --------------------------------------------------------------------------\n// Intrinsic\n// --------------------------------------------------------------------------\nvar Intrinsic;\n(function (Intrinsic) {\n  function Uncapitalize(value) {\n    const [first, rest] = [value.slice(0, 1), value.slice(1)];\n    return `${first.toLowerCase()}${rest}`;\n  }\n  function Capitalize(value) {\n    const [first, rest] = [value.slice(0, 1), value.slice(1)];\n    return `${first.toUpperCase()}${rest}`;\n  }\n  function Uppercase(value) {\n    return value.toUpperCase();\n  }\n  function Lowercase(value) {\n    return value.toLowerCase();\n  }\n  function IntrinsicTemplateLiteral(schema, mode) {\n    // note: template literals require special runtime handling as they are encoded in string patterns.\n    // This diverges from the mapped type which would otherwise map on the template literal kind.\n    const expression = TemplateLiteralParser.ParseExact(schema.pattern);\n    const finite = TemplateLiteralFinite.Check(expression);\n    if (!finite) return {\n      ...schema,\n      pattern: IntrinsicLiteral(schema.pattern, mode)\n    };\n    const strings = [...TemplateLiteralGenerator.Generate(expression)];\n    const literals = strings.map(value => exports.Type.Literal(value));\n    const mapped = IntrinsicRest(literals, mode);\n    const union = exports.Type.Union(mapped);\n    return exports.Type.TemplateLiteral([union]);\n  }\n  function IntrinsicLiteral(value, mode) {\n    // prettier-ignore\n    return typeof value === 'string' ? mode === 'Uncapitalize' ? Uncapitalize(value) : mode === 'Capitalize' ? Capitalize(value) : mode === 'Uppercase' ? Uppercase(value) : mode === 'Lowercase' ? Lowercase(value) : value : value.toString();\n  }\n  function IntrinsicRest(schema, mode) {\n    if (schema.length === 0) return [];\n    const [L, ...R] = schema;\n    return [Map(L, mode), ...IntrinsicRest(R, mode)];\n  }\n  function Visit(schema, mode) {\n    // prettier-ignore\n    return TypeGuard.TTemplateLiteral(schema) ? IntrinsicTemplateLiteral(schema, mode) : TypeGuard.TUnion(schema) ? exports.Type.Union(IntrinsicRest(schema.anyOf, mode)) : TypeGuard.TLiteral(schema) ? exports.Type.Literal(IntrinsicLiteral(schema.const, mode)) : schema;\n  }\n  /** Applies an intrinsic string manipulation to the given type. */\n  function Map(schema, mode) {\n    return Visit(schema, mode);\n  }\n  Intrinsic.Map = Map;\n})(Intrinsic || (exports.Intrinsic = Intrinsic = {}));\n// --------------------------------------------------------------------------\n// ObjectMap\n// --------------------------------------------------------------------------\nvar ObjectMap;\n(function (ObjectMap) {\n  function TIntersect(schema, callback) {\n    // prettier-ignore\n    return exports.Type.Intersect(schema.allOf.map(inner => Visit(inner, callback)), {\n      ...schema\n    });\n  }\n  function TUnion(schema, callback) {\n    // prettier-ignore\n    return exports.Type.Union(schema.anyOf.map(inner => Visit(inner, callback)), {\n      ...schema\n    });\n  }\n  function TObject(schema, callback) {\n    return callback(schema);\n  }\n  function Visit(schema, callback) {\n    // There are cases where users need to map objects with unregistered kinds. Using a TypeGuard here would\n    // prevent sub schema mapping as unregistered kinds will not pass TSchema checks. This is notable in the\n    // case of TObject where unregistered property kinds cause the TObject check to fail. As mapping is only\n    // used for composition, we use explicit checks instead.\n    // prettier-ignore\n    return schema[exports.Kind] === 'Intersect' ? TIntersect(schema, callback) : schema[exports.Kind] === 'Union' ? TUnion(schema, callback) : schema[exports.Kind] === 'Object' ? TObject(schema, callback) : schema;\n  }\n  function Map(schema, callback, options) {\n    return {\n      ...Visit(TypeClone.Type(schema), callback),\n      ...options\n    };\n  }\n  ObjectMap.Map = Map;\n})(ObjectMap || (exports.ObjectMap = ObjectMap = {}));\nvar KeyResolver;\n(function (KeyResolver) {\n  function UnwrapPattern(key) {\n    return key[0] === '^' && key[key.length - 1] === '$' ? key.slice(1, key.length - 1) : key;\n  }\n  function TIntersect(schema, options) {\n    return schema.allOf.reduce((acc, schema) => [...acc, ...Visit(schema, options)], []);\n  }\n  function TUnion(schema, options) {\n    const sets = schema.anyOf.map(inner => Visit(inner, options));\n    return [...sets.reduce((set, outer) => outer.map(key => sets.every(inner => inner.includes(key)) ? set.add(key) : set)[0], new Set())];\n  }\n  function TObject(schema, options) {\n    return Object.getOwnPropertyNames(schema.properties);\n  }\n  function TRecord(schema, options) {\n    return options.includePatterns ? Object.getOwnPropertyNames(schema.patternProperties) : [];\n  }\n  function Visit(schema, options) {\n    // prettier-ignore\n    return TypeGuard.TIntersect(schema) ? TIntersect(schema, options) : TypeGuard.TUnion(schema) ? TUnion(schema, options) : TypeGuard.TObject(schema) ? TObject(schema, options) : TypeGuard.TRecord(schema) ? TRecord(schema, options) : [];\n  }\n  /** Resolves an array of keys in this schema */\n  function ResolveKeys(schema, options) {\n    return [...new Set(Visit(schema, options))];\n  }\n  KeyResolver.ResolveKeys = ResolveKeys;\n  /** Resolves a regular expression pattern matching all keys in this schema */\n  function ResolvePattern(schema) {\n    const keys = ResolveKeys(schema, {\n      includePatterns: true\n    });\n    const pattern = keys.map(key => `(${UnwrapPattern(key)})`);\n    return `^(${pattern.join('|')})$`;\n  }\n  KeyResolver.ResolvePattern = ResolvePattern;\n})(KeyResolver || (exports.KeyResolver = KeyResolver = {}));\n// --------------------------------------------------------------------------\n// KeyArrayResolver\n// --------------------------------------------------------------------------\nclass KeyArrayResolverError extends TypeBoxError {}\nexports.KeyArrayResolverError = KeyArrayResolverError;\nvar KeyArrayResolver;\n(function (KeyArrayResolver) {\n  /** Resolves an array of string[] keys from the given schema or array type. */\n  function Resolve(schema) {\n    // prettier-ignore\n    return Array.isArray(schema) ? schema : TypeGuard.TUnionLiteral(schema) ? schema.anyOf.map(schema => schema.const.toString()) : TypeGuard.TLiteral(schema) ? [schema.const] : TypeGuard.TTemplateLiteral(schema) ? (() => {\n      const expression = TemplateLiteralParser.ParseExact(schema.pattern);\n      if (!TemplateLiteralFinite.Check(expression)) throw new KeyArrayResolverError('Cannot resolve keys from infinite template expression');\n      return [...TemplateLiteralGenerator.Generate(expression)];\n    })() : [];\n  }\n  KeyArrayResolver.Resolve = Resolve;\n})(KeyArrayResolver || (exports.KeyArrayResolver = KeyArrayResolver = {}));\n// --------------------------------------------------------------------------\n// UnionResolver\n// --------------------------------------------------------------------------\nvar UnionResolver;\n(function (UnionResolver) {\n  function* TUnion(union) {\n    for (const schema of union.anyOf) {\n      if (schema[exports.Kind] === 'Union') {\n        yield* TUnion(schema);\n      } else {\n        yield schema;\n      }\n    }\n  }\n  /** Returns a resolved union with interior unions flattened */\n  function Resolve(union) {\n    return exports.Type.Union([...TUnion(union)], {\n      ...union\n    });\n  }\n  UnionResolver.Resolve = Resolve;\n})(UnionResolver || (exports.UnionResolver = UnionResolver = {}));\n// --------------------------------------------------------------------------\n// TemplateLiteralPattern\n// --------------------------------------------------------------------------\nclass TemplateLiteralPatternError extends TypeBoxError {}\nexports.TemplateLiteralPatternError = TemplateLiteralPatternError;\nvar TemplateLiteralPattern;\n(function (TemplateLiteralPattern) {\n  function Throw(message) {\n    throw new TemplateLiteralPatternError(message);\n  }\n  function Escape(value) {\n    return value.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&');\n  }\n  function Visit(schema, acc) {\n    // prettier-ignore\n    return TypeGuard.TTemplateLiteral(schema) ? schema.pattern.slice(1, schema.pattern.length - 1) : TypeGuard.TUnion(schema) ? `(${schema.anyOf.map(schema => Visit(schema, acc)).join('|')})` : TypeGuard.TNumber(schema) ? `${acc}${exports.PatternNumber}` : TypeGuard.TInteger(schema) ? `${acc}${exports.PatternNumber}` : TypeGuard.TBigInt(schema) ? `${acc}${exports.PatternNumber}` : TypeGuard.TString(schema) ? `${acc}${exports.PatternString}` : TypeGuard.TLiteral(schema) ? `${acc}${Escape(schema.const.toString())}` : TypeGuard.TBoolean(schema) ? `${acc}${exports.PatternBoolean}` : Throw(`Unexpected Kind '${schema[exports.Kind]}'`);\n  }\n  function Create(kinds) {\n    return `^${kinds.map(schema => Visit(schema, '')).join('')}\\$`;\n  }\n  TemplateLiteralPattern.Create = Create;\n})(TemplateLiteralPattern || (exports.TemplateLiteralPattern = TemplateLiteralPattern = {}));\n// --------------------------------------------------------------------------------------\n// TemplateLiteralResolver\n// --------------------------------------------------------------------------------------\nvar TemplateLiteralResolver;\n(function (TemplateLiteralResolver) {\n  /** Resolves a template literal as a TUnion */\n  function Resolve(template) {\n    const expression = TemplateLiteralParser.ParseExact(template.pattern);\n    if (!TemplateLiteralFinite.Check(expression)) return exports.Type.String();\n    const literals = [...TemplateLiteralGenerator.Generate(expression)].map(value => exports.Type.Literal(value));\n    return exports.Type.Union(literals);\n  }\n  TemplateLiteralResolver.Resolve = Resolve;\n})(TemplateLiteralResolver || (exports.TemplateLiteralResolver = TemplateLiteralResolver = {}));\n// --------------------------------------------------------------------------------------\n// TemplateLiteralParser\n// --------------------------------------------------------------------------------------\nclass TemplateLiteralParserError extends TypeBoxError {}\nexports.TemplateLiteralParserError = TemplateLiteralParserError;\nvar TemplateLiteralParser;\n(function (TemplateLiteralParser) {\n  function IsNonEscaped(pattern, index, char) {\n    return pattern[index] === char && pattern.charCodeAt(index - 1) !== 92;\n  }\n  function IsOpenParen(pattern, index) {\n    return IsNonEscaped(pattern, index, '(');\n  }\n  function IsCloseParen(pattern, index) {\n    return IsNonEscaped(pattern, index, ')');\n  }\n  function IsSeparator(pattern, index) {\n    return IsNonEscaped(pattern, index, '|');\n  }\n  function IsGroup(pattern) {\n    if (!(IsOpenParen(pattern, 0) && IsCloseParen(pattern, pattern.length - 1))) return false;\n    let count = 0;\n    for (let index = 0; index < pattern.length; index++) {\n      if (IsOpenParen(pattern, index)) count += 1;\n      if (IsCloseParen(pattern, index)) count -= 1;\n      if (count === 0 && index !== pattern.length - 1) return false;\n    }\n    return true;\n  }\n  function InGroup(pattern) {\n    return pattern.slice(1, pattern.length - 1);\n  }\n  function IsPrecedenceOr(pattern) {\n    let count = 0;\n    for (let index = 0; index < pattern.length; index++) {\n      if (IsOpenParen(pattern, index)) count += 1;\n      if (IsCloseParen(pattern, index)) count -= 1;\n      if (IsSeparator(pattern, index) && count === 0) return true;\n    }\n    return false;\n  }\n  function IsPrecedenceAnd(pattern) {\n    for (let index = 0; index < pattern.length; index++) {\n      if (IsOpenParen(pattern, index)) return true;\n    }\n    return false;\n  }\n  function Or(pattern) {\n    let [count, start] = [0, 0];\n    const expressions = [];\n    for (let index = 0; index < pattern.length; index++) {\n      if (IsOpenParen(pattern, index)) count += 1;\n      if (IsCloseParen(pattern, index)) count -= 1;\n      if (IsSeparator(pattern, index) && count === 0) {\n        const range = pattern.slice(start, index);\n        if (range.length > 0) expressions.push(Parse(range));\n        start = index + 1;\n      }\n    }\n    const range = pattern.slice(start);\n    if (range.length > 0) expressions.push(Parse(range));\n    if (expressions.length === 0) return {\n      type: 'const',\n      const: ''\n    };\n    if (expressions.length === 1) return expressions[0];\n    return {\n      type: 'or',\n      expr: expressions\n    };\n  }\n  function And(pattern) {\n    function Group(value, index) {\n      if (!IsOpenParen(value, index)) throw new TemplateLiteralParserError(`TemplateLiteralParser: Index must point to open parens`);\n      let count = 0;\n      for (let scan = index; scan < value.length; scan++) {\n        if (IsOpenParen(value, scan)) count += 1;\n        if (IsCloseParen(value, scan)) count -= 1;\n        if (count === 0) return [index, scan];\n      }\n      throw new TemplateLiteralParserError(`TemplateLiteralParser: Unclosed group parens in expression`);\n    }\n    function Range(pattern, index) {\n      for (let scan = index; scan < pattern.length; scan++) {\n        if (IsOpenParen(pattern, scan)) return [index, scan];\n      }\n      return [index, pattern.length];\n    }\n    const expressions = [];\n    for (let index = 0; index < pattern.length; index++) {\n      if (IsOpenParen(pattern, index)) {\n        const [start, end] = Group(pattern, index);\n        const range = pattern.slice(start, end + 1);\n        expressions.push(Parse(range));\n        index = end;\n      } else {\n        const [start, end] = Range(pattern, index);\n        const range = pattern.slice(start, end);\n        if (range.length > 0) expressions.push(Parse(range));\n        index = end - 1;\n      }\n    }\n    // prettier-ignore\n    return expressions.length === 0 ? {\n      type: 'const',\n      const: ''\n    } : expressions.length === 1 ? expressions[0] : {\n      type: 'and',\n      expr: expressions\n    };\n  }\n  /** Parses a pattern and returns an expression tree */\n  function Parse(pattern) {\n    // prettier-ignore\n    return IsGroup(pattern) ? Parse(InGroup(pattern)) : IsPrecedenceOr(pattern) ? Or(pattern) : IsPrecedenceAnd(pattern) ? And(pattern) : {\n      type: 'const',\n      const: pattern\n    };\n  }\n  TemplateLiteralParser.Parse = Parse;\n  /** Parses a pattern and strips forward and trailing ^ and $ */\n  function ParseExact(pattern) {\n    return Parse(pattern.slice(1, pattern.length - 1));\n  }\n  TemplateLiteralParser.ParseExact = ParseExact;\n})(TemplateLiteralParser || (exports.TemplateLiteralParser = TemplateLiteralParser = {}));\n// --------------------------------------------------------------------------------------\n// TemplateLiteralFinite\n// --------------------------------------------------------------------------------------\nclass TemplateLiteralFiniteError extends TypeBoxError {}\nexports.TemplateLiteralFiniteError = TemplateLiteralFiniteError;\nvar TemplateLiteralFinite;\n(function (TemplateLiteralFinite) {\n  function Throw(message) {\n    throw new TemplateLiteralFiniteError(message);\n  }\n  function IsNumber(expression) {\n    // prettier-ignore\n    return expression.type === 'or' && expression.expr.length === 2 && expression.expr[0].type === 'const' && expression.expr[0].const === '0' && expression.expr[1].type === 'const' && expression.expr[1].const === '[1-9][0-9]*';\n  }\n  function IsBoolean(expression) {\n    // prettier-ignore\n    return expression.type === 'or' && expression.expr.length === 2 && expression.expr[0].type === 'const' && expression.expr[0].const === 'true' && expression.expr[1].type === 'const' && expression.expr[1].const === 'false';\n  }\n  function IsString(expression) {\n    return expression.type === 'const' && expression.const === '.*';\n  }\n  function Check(expression) {\n    // prettier-ignore\n    return IsBoolean(expression) ? true : IsNumber(expression) || IsString(expression) ? false : expression.type === 'and' ? expression.expr.every(expr => Check(expr)) : expression.type === 'or' ? expression.expr.every(expr => Check(expr)) : expression.type === 'const' ? true : Throw(`Unknown expression type`);\n  }\n  TemplateLiteralFinite.Check = Check;\n})(TemplateLiteralFinite || (exports.TemplateLiteralFinite = TemplateLiteralFinite = {}));\n// --------------------------------------------------------------------------------------\n// TemplateLiteralGenerator\n// --------------------------------------------------------------------------------------\nclass TemplateLiteralGeneratorError extends TypeBoxError {}\nexports.TemplateLiteralGeneratorError = TemplateLiteralGeneratorError;\nvar TemplateLiteralGenerator;\n(function (TemplateLiteralGenerator) {\n  function* Reduce(buffer) {\n    if (buffer.length === 1) return yield* buffer[0];\n    for (const left of buffer[0]) {\n      for (const right of Reduce(buffer.slice(1))) {\n        yield `${left}${right}`;\n      }\n    }\n  }\n  function* And(expression) {\n    return yield* Reduce(expression.expr.map(expr => [...Generate(expr)]));\n  }\n  function* Or(expression) {\n    for (const expr of expression.expr) yield* Generate(expr);\n  }\n  function* Const(expression) {\n    return yield expression.const;\n  }\n  function* Generate(expression) {\n    // prettier-ignore\n    return expression.type === 'and' ? yield* And(expression) : expression.type === 'or' ? yield* Or(expression) : expression.type === 'const' ? yield* Const(expression) : (() => {\n      throw new TemplateLiteralGeneratorError('Unknown expression');\n    })();\n  }\n  TemplateLiteralGenerator.Generate = Generate;\n})(TemplateLiteralGenerator || (exports.TemplateLiteralGenerator = TemplateLiteralGenerator = {}));\n// ---------------------------------------------------------------------\n// TemplateLiteralDslParser\n// ---------------------------------------------------------------------\nvar TemplateLiteralDslParser;\n(function (TemplateLiteralDslParser) {\n  function* ParseUnion(template) {\n    const trim = template.trim().replace(/\"|'/g, '');\n    // prettier-ignore\n    return trim === 'boolean' ? yield exports.Type.Boolean() : trim === 'number' ? yield exports.Type.Number() : trim === 'bigint' ? yield exports.Type.BigInt() : trim === 'string' ? yield exports.Type.String() : yield (() => {\n      const literals = trim.split('|').map(literal => exports.Type.Literal(literal.trim()));\n      return literals.length === 0 ? exports.Type.Never() : literals.length === 1 ? literals[0] : exports.Type.Union(literals);\n    })();\n  }\n  function* ParseTerminal(template) {\n    if (template[1] !== '{') {\n      const L = exports.Type.Literal('$');\n      const R = ParseLiteral(template.slice(1));\n      return yield* [L, ...R];\n    }\n    for (let i = 2; i < template.length; i++) {\n      if (template[i] === '}') {\n        const L = ParseUnion(template.slice(2, i));\n        const R = ParseLiteral(template.slice(i + 1));\n        return yield* [...L, ...R];\n      }\n    }\n    yield exports.Type.Literal(template);\n  }\n  function* ParseLiteral(template) {\n    for (let i = 0; i < template.length; i++) {\n      if (template[i] === '$') {\n        const L = exports.Type.Literal(template.slice(0, i));\n        const R = ParseTerminal(template.slice(i));\n        return yield* [L, ...R];\n      }\n    }\n    yield exports.Type.Literal(template);\n  }\n  function Parse(template_dsl) {\n    return [...ParseLiteral(template_dsl)];\n  }\n  TemplateLiteralDslParser.Parse = Parse;\n})(TemplateLiteralDslParser || (exports.TemplateLiteralDslParser = TemplateLiteralDslParser = {}));\n// ---------------------------------------------------------------------\n// TransformBuilder\n// ---------------------------------------------------------------------\nclass TransformDecodeBuilder {\n  constructor(schema) {\n    this.schema = schema;\n  }\n  Decode(decode) {\n    return new TransformEncodeBuilder(this.schema, decode);\n  }\n}\nexports.TransformDecodeBuilder = TransformDecodeBuilder;\nclass TransformEncodeBuilder {\n  constructor(schema, decode) {\n    this.schema = schema;\n    this.decode = decode;\n  }\n  Encode(encode) {\n    const schema = TypeClone.Type(this.schema);\n    // prettier-ignore\n    return TypeGuard.TTransform(schema) ? (() => {\n      const Encode = value => schema[exports.Transform].Encode(encode(value));\n      const Decode = value => this.decode(schema[exports.Transform].Decode(value));\n      const Codec = {\n        Encode: Encode,\n        Decode: Decode\n      };\n      return {\n        ...schema,\n        [exports.Transform]: Codec\n      };\n    })() : (() => {\n      const Codec = {\n        Decode: this.decode,\n        Encode: encode\n      };\n      return {\n        ...schema,\n        [exports.Transform]: Codec\n      };\n    })();\n  }\n}\nexports.TransformEncodeBuilder = TransformEncodeBuilder;\n// --------------------------------------------------------------------------\n// TypeOrdinal: Used for auto $id generation\n// --------------------------------------------------------------------------\nlet TypeOrdinal = 0;\n// --------------------------------------------------------------------------\n// TypeBuilder\n// --------------------------------------------------------------------------\nclass TypeBuilderError extends TypeBoxError {}\nexports.TypeBuilderError = TypeBuilderError;\nclass TypeBuilder {\n  /** `[Internal]` Creates a schema without `static` and `params` types */\n  Create(schema) {\n    return schema;\n  }\n  /** `[Internal]` Throws a TypeBuilder error with the given message */\n  Throw(message) {\n    throw new TypeBuilderError(message);\n  }\n  /** `[Internal]` Discards property keys from the given record type */\n  Discard(record, keys) {\n    return keys.reduce((acc, key) => {\n      const {\n        [key]: _,\n        ...rest\n      } = acc;\n      return rest;\n    }, record);\n  }\n  /** `[Json]` Omits compositing symbols from this schema */\n  Strict(schema) {\n    return JSON.parse(JSON.stringify(schema));\n  }\n}\nexports.TypeBuilder = TypeBuilder;\n// --------------------------------------------------------------------------\n// JsonTypeBuilder\n// --------------------------------------------------------------------------\nclass JsonTypeBuilder extends TypeBuilder {\n  // ------------------------------------------------------------------------\n  // Modifiers\n  // ------------------------------------------------------------------------\n  /** `[Json]` Creates a Readonly and Optional property */\n  ReadonlyOptional(schema) {\n    return this.Readonly(this.Optional(schema));\n  }\n  /** `[Json]` Creates a Readonly property */\n  Readonly(schema) {\n    return {\n      ...TypeClone.Type(schema),\n      [exports.Readonly]: 'Readonly'\n    };\n  }\n  /** `[Json]` Creates an Optional property */\n  Optional(schema) {\n    return {\n      ...TypeClone.Type(schema),\n      [exports.Optional]: 'Optional'\n    };\n  }\n  // ------------------------------------------------------------------------\n  // Types\n  // ------------------------------------------------------------------------\n  /** `[Json]` Creates an Any type */\n  Any(options = {}) {\n    return this.Create({\n      ...options,\n      [exports.Kind]: 'Any'\n    });\n  }\n  /** `[Json]` Creates an Array type */\n  Array(schema, options = {}) {\n    return this.Create({\n      ...options,\n      [exports.Kind]: 'Array',\n      type: 'array',\n      items: TypeClone.Type(schema)\n    });\n  }\n  /** `[Json]` Creates a Boolean type */\n  Boolean(options = {}) {\n    return this.Create({\n      ...options,\n      [exports.Kind]: 'Boolean',\n      type: 'boolean'\n    });\n  }\n  /** `[Json]` Intrinsic function to Capitalize LiteralString types */\n  Capitalize(schema, options = {}) {\n    return {\n      ...Intrinsic.Map(TypeClone.Type(schema), 'Capitalize'),\n      ...options\n    };\n  }\n  /** `[Json]` Creates a Composite object type */\n  Composite(objects, options) {\n    const intersect = exports.Type.Intersect(objects, {});\n    const keys = KeyResolver.ResolveKeys(intersect, {\n      includePatterns: false\n    });\n    const properties = keys.reduce((acc, key) => ({\n      ...acc,\n      [key]: exports.Type.Index(intersect, [key])\n    }), {});\n    return exports.Type.Object(properties, options);\n  }\n  /** `[Json]` Creates a Enum type */\n  Enum(item, options = {}) {\n    if (ValueGuard.IsUndefined(item)) return this.Throw('Enum undefined or empty');\n    // prettier-ignore\n    const values1 = Object.getOwnPropertyNames(item).filter(key => isNaN(key)).map(key => item[key]);\n    const values2 = [...new Set(values1)];\n    const anyOf = values2.map(value => exports.Type.Literal(value));\n    return this.Union(anyOf, {\n      ...options,\n      [exports.Hint]: 'Enum'\n    });\n  }\n  /** `[Json]` Creates a Conditional type */\n  Extends(left, right, trueType, falseType, options = {}) {\n    switch (TypeExtends.Extends(left, right)) {\n      case TypeExtendsResult.Union:\n        return this.Union([TypeClone.Type(trueType, options), TypeClone.Type(falseType, options)]);\n      case TypeExtendsResult.True:\n        return TypeClone.Type(trueType, options);\n      case TypeExtendsResult.False:\n        return TypeClone.Type(falseType, options);\n    }\n  }\n  /** `[Json]` Constructs a type by excluding from unionType all union members that are assignable to excludedMembers */\n  Exclude(unionType, excludedMembers, options = {}) {\n    // prettier-ignore\n    return TypeGuard.TTemplateLiteral(unionType) ? this.Exclude(TemplateLiteralResolver.Resolve(unionType), excludedMembers, options) : TypeGuard.TTemplateLiteral(excludedMembers) ? this.Exclude(unionType, TemplateLiteralResolver.Resolve(excludedMembers), options) : TypeGuard.TUnion(unionType) ? (() => {\n      const narrowed = unionType.anyOf.filter(inner => TypeExtends.Extends(inner, excludedMembers) === TypeExtendsResult.False);\n      return narrowed.length === 1 ? TypeClone.Type(narrowed[0], options) : this.Union(narrowed, options);\n    })() : TypeExtends.Extends(unionType, excludedMembers) !== TypeExtendsResult.False ? this.Never(options) : TypeClone.Type(unionType, options);\n  }\n  /** `[Json]` Constructs a type by extracting from type all union members that are assignable to union */\n  Extract(type, union, options = {}) {\n    // prettier-ignore\n    return TypeGuard.TTemplateLiteral(type) ? this.Extract(TemplateLiteralResolver.Resolve(type), union, options) : TypeGuard.TTemplateLiteral(union) ? this.Extract(type, TemplateLiteralResolver.Resolve(union), options) : TypeGuard.TUnion(type) ? (() => {\n      const narrowed = type.anyOf.filter(inner => TypeExtends.Extends(inner, union) !== TypeExtendsResult.False);\n      return narrowed.length === 1 ? TypeClone.Type(narrowed[0], options) : this.Union(narrowed, options);\n    })() : TypeExtends.Extends(type, union) !== TypeExtendsResult.False ? TypeClone.Type(type, options) : this.Never(options);\n  }\n  /** `[Json]` Returns an Indexed property type for the given keys */\n  Index(schema, unresolved, options = {}) {\n    // prettier-ignore\n    return TypeGuard.TArray(schema) && TypeGuard.TNumber(unresolved) ? (() => {\n      return TypeClone.Type(schema.items, options);\n    })() : TypeGuard.TTuple(schema) && TypeGuard.TNumber(unresolved) ? (() => {\n      const items = ValueGuard.IsUndefined(schema.items) ? [] : schema.items;\n      const cloned = items.map(schema => TypeClone.Type(schema));\n      return this.Union(cloned, options);\n    })() : (() => {\n      const keys = KeyArrayResolver.Resolve(unresolved);\n      const clone = TypeClone.Type(schema);\n      return IndexedAccessor.Resolve(clone, keys, options);\n    })();\n  }\n  /** `[Json]` Creates an Integer type */\n  Integer(options = {}) {\n    return this.Create({\n      ...options,\n      [exports.Kind]: 'Integer',\n      type: 'integer'\n    });\n  }\n  /** `[Json]` Creates an Intersect type */\n  Intersect(allOf, options = {}) {\n    if (allOf.length === 0) return exports.Type.Never();\n    if (allOf.length === 1) return TypeClone.Type(allOf[0], options);\n    if (allOf.some(schema => TypeGuard.TTransform(schema))) this.Throw('Cannot intersect transform types');\n    const objects = allOf.every(schema => TypeGuard.TObject(schema));\n    const cloned = TypeClone.Rest(allOf);\n    // prettier-ignore\n    const clonedUnevaluatedProperties = TypeGuard.TSchema(options.unevaluatedProperties) ? {\n      unevaluatedProperties: TypeClone.Type(options.unevaluatedProperties)\n    } : {};\n    return options.unevaluatedProperties === false || TypeGuard.TSchema(options.unevaluatedProperties) || objects ? this.Create({\n      ...options,\n      ...clonedUnevaluatedProperties,\n      [exports.Kind]: 'Intersect',\n      type: 'object',\n      allOf: cloned\n    }) : this.Create({\n      ...options,\n      ...clonedUnevaluatedProperties,\n      [exports.Kind]: 'Intersect',\n      allOf: cloned\n    });\n  }\n  /** `[Json]` Creates a KeyOf type */\n  KeyOf(schema, options = {}) {\n    // prettier-ignore\n    return TypeGuard.TRecord(schema) ? (() => {\n      const pattern = Object.getOwnPropertyNames(schema.patternProperties)[0];\n      return pattern === exports.PatternNumberExact ? this.Number(options) : pattern === exports.PatternStringExact ? this.String(options) : this.Throw('Unable to resolve key type from Record key pattern');\n    })() : TypeGuard.TTuple(schema) ? (() => {\n      const items = ValueGuard.IsUndefined(schema.items) ? [] : schema.items;\n      const literals = items.map((_, index) => exports.Type.Literal(index.toString()));\n      return this.Union(literals, options);\n    })() : TypeGuard.TArray(schema) ? (() => {\n      return this.Number(options);\n    })() : (() => {\n      const keys = KeyResolver.ResolveKeys(schema, {\n        includePatterns: false\n      });\n      if (keys.length === 0) return this.Never(options);\n      const literals = keys.map(key => this.Literal(key));\n      return this.Union(literals, options);\n    })();\n  }\n  /** `[Json]` Creates a Literal type */\n  Literal(value, options = {}) {\n    return this.Create({\n      ...options,\n      [exports.Kind]: 'Literal',\n      const: value,\n      type: typeof value\n    });\n  }\n  /** `[Json]` Intrinsic function to Lowercase LiteralString types */\n  Lowercase(schema, options = {}) {\n    return {\n      ...Intrinsic.Map(TypeClone.Type(schema), 'Lowercase'),\n      ...options\n    };\n  }\n  /** `[Json]` Creates a Never type */\n  Never(options = {}) {\n    return this.Create({\n      ...options,\n      [exports.Kind]: 'Never',\n      not: {}\n    });\n  }\n  /** `[Json]` Creates a Not type */\n  Not(schema, options) {\n    return this.Create({\n      ...options,\n      [exports.Kind]: 'Not',\n      not: TypeClone.Type(schema)\n    });\n  }\n  /** `[Json]` Creates a Null type */\n  Null(options = {}) {\n    return this.Create({\n      ...options,\n      [exports.Kind]: 'Null',\n      type: 'null'\n    });\n  }\n  /** `[Json]` Creates a Number type */\n  Number(options = {}) {\n    return this.Create({\n      ...options,\n      [exports.Kind]: 'Number',\n      type: 'number'\n    });\n  }\n  /** `[Json]` Creates an Object type */\n  Object(properties, options = {}) {\n    const propertyKeys = Object.getOwnPropertyNames(properties);\n    const optionalKeys = propertyKeys.filter(key => TypeGuard.TOptional(properties[key]));\n    const requiredKeys = propertyKeys.filter(name => !optionalKeys.includes(name));\n    const clonedAdditionalProperties = TypeGuard.TSchema(options.additionalProperties) ? {\n      additionalProperties: TypeClone.Type(options.additionalProperties)\n    } : {};\n    const clonedProperties = propertyKeys.reduce((acc, key) => ({\n      ...acc,\n      [key]: TypeClone.Type(properties[key])\n    }), {});\n    return requiredKeys.length > 0 ? this.Create({\n      ...options,\n      ...clonedAdditionalProperties,\n      [exports.Kind]: 'Object',\n      type: 'object',\n      properties: clonedProperties,\n      required: requiredKeys\n    }) : this.Create({\n      ...options,\n      ...clonedAdditionalProperties,\n      [exports.Kind]: 'Object',\n      type: 'object',\n      properties: clonedProperties\n    });\n  }\n  /** `[Json]` Constructs a type whose keys are omitted from the given type */\n  Omit(schema, unresolved, options = {}) {\n    const keys = KeyArrayResolver.Resolve(unresolved);\n    // prettier-ignore\n    return ObjectMap.Map(this.Discard(TypeClone.Type(schema), ['$id', exports.Transform]), object => {\n      if (ValueGuard.IsArray(object.required)) {\n        object.required = object.required.filter(key => !keys.includes(key));\n        if (object.required.length === 0) delete object.required;\n      }\n      for (const key of Object.getOwnPropertyNames(object.properties)) {\n        if (keys.includes(key)) delete object.properties[key];\n      }\n      return this.Create(object);\n    }, options);\n  }\n  /** `[Json]` Constructs a type where all properties are optional */\n  Partial(schema, options = {}) {\n    // prettier-ignore\n    return ObjectMap.Map(this.Discard(TypeClone.Type(schema), ['$id', exports.Transform]), object => {\n      const properties = Object.getOwnPropertyNames(object.properties).reduce((acc, key) => {\n        return {\n          ...acc,\n          [key]: this.Optional(object.properties[key])\n        };\n      }, {});\n      return this.Object(properties, this.Discard(object, ['required']) /* object used as options to retain other constraints */);\n    }, options);\n  }\n  /** `[Json]` Constructs a type whose keys are picked from the given type */\n  Pick(schema, unresolved, options = {}) {\n    const keys = KeyArrayResolver.Resolve(unresolved);\n    // prettier-ignore\n    return ObjectMap.Map(this.Discard(TypeClone.Type(schema), ['$id', exports.Transform]), object => {\n      if (ValueGuard.IsArray(object.required)) {\n        object.required = object.required.filter(key => keys.includes(key));\n        if (object.required.length === 0) delete object.required;\n      }\n      for (const key of Object.getOwnPropertyNames(object.properties)) {\n        if (!keys.includes(key)) delete object.properties[key];\n      }\n      return this.Create(object);\n    }, options);\n  }\n  /** `[Json]` Creates a Record type */\n  Record(key, schema, options = {}) {\n    // prettier-ignore\n    return TypeGuard.TTemplateLiteral(key) ? (() => {\n      const expression = TemplateLiteralParser.ParseExact(key.pattern);\n      // prettier-ignore\n      return TemplateLiteralFinite.Check(expression) ? this.Object([...TemplateLiteralGenerator.Generate(expression)].reduce((acc, key) => ({\n        ...acc,\n        [key]: TypeClone.Type(schema)\n      }), {}), options) : this.Create({\n        ...options,\n        [exports.Kind]: 'Record',\n        type: 'object',\n        patternProperties: {\n          [key.pattern]: TypeClone.Type(schema)\n        }\n      });\n    })() : TypeGuard.TUnion(key) ? (() => {\n      const union = UnionResolver.Resolve(key);\n      if (TypeGuard.TUnionLiteral(union)) {\n        const properties = union.anyOf.reduce((acc, literal) => ({\n          ...acc,\n          [literal.const]: TypeClone.Type(schema)\n        }), {});\n        return this.Object(properties, {\n          ...options,\n          [exports.Hint]: 'Record'\n        });\n      } else this.Throw('Record key of type union contains non-literal types');\n    })() : TypeGuard.TLiteral(key) ? (() => {\n      // prettier-ignore\n      return ValueGuard.IsString(key.const) || ValueGuard.IsNumber(key.const) ? this.Object({\n        [key.const]: TypeClone.Type(schema)\n      }, options) : this.Throw('Record key of type literal is not of type string or number');\n    })() : TypeGuard.TInteger(key) || TypeGuard.TNumber(key) ? (() => {\n      return this.Create({\n        ...options,\n        [exports.Kind]: 'Record',\n        type: 'object',\n        patternProperties: {\n          [exports.PatternNumberExact]: TypeClone.Type(schema)\n        }\n      });\n    })() : TypeGuard.TString(key) ? (() => {\n      const pattern = ValueGuard.IsUndefined(key.pattern) ? exports.PatternStringExact : key.pattern;\n      return this.Create({\n        ...options,\n        [exports.Kind]: 'Record',\n        type: 'object',\n        patternProperties: {\n          [pattern]: TypeClone.Type(schema)\n        }\n      });\n    })() : this.Never();\n  }\n  /** `[Json]` Creates a Recursive type */\n  Recursive(callback, options = {}) {\n    if (ValueGuard.IsUndefined(options.$id)) options.$id = `T${TypeOrdinal++}`;\n    const thisType = callback({\n      [exports.Kind]: 'This',\n      $ref: `${options.$id}`\n    });\n    thisType.$id = options.$id;\n    return this.Create({\n      ...options,\n      [exports.Hint]: 'Recursive',\n      ...thisType\n    });\n  }\n  /** `[Json]` Creates a Ref type. */\n  Ref(unresolved, options = {}) {\n    if (ValueGuard.IsString(unresolved)) return this.Create({\n      ...options,\n      [exports.Kind]: 'Ref',\n      $ref: unresolved\n    });\n    if (ValueGuard.IsUndefined(unresolved.$id)) this.Throw('Reference target type must specify an $id');\n    return this.Create({\n      ...options,\n      [exports.Kind]: 'Ref',\n      $ref: unresolved.$id\n    });\n  }\n  /** `[Json]` Constructs a type where all properties are required */\n  Required(schema, options = {}) {\n    // prettier-ignore\n    return ObjectMap.Map(this.Discard(TypeClone.Type(schema), ['$id', exports.Transform]), object => {\n      const properties = Object.getOwnPropertyNames(object.properties).reduce((acc, key) => {\n        return {\n          ...acc,\n          [key]: this.Discard(object.properties[key], [exports.Optional])\n        };\n      }, {});\n      return this.Object(properties, object /* object used as options to retain other constraints  */);\n    }, options);\n  }\n  /** `[Json]` Extracts interior Rest elements from Tuple, Intersect and Union types */\n  Rest(schema) {\n    return TypeGuard.TTuple(schema) && !ValueGuard.IsUndefined(schema.items) ? TypeClone.Rest(schema.items) : TypeGuard.TIntersect(schema) ? TypeClone.Rest(schema.allOf) : TypeGuard.TUnion(schema) ? TypeClone.Rest(schema.anyOf) : [];\n  }\n  /** `[Json]` Creates a String type */\n  String(options = {}) {\n    return this.Create({\n      ...options,\n      [exports.Kind]: 'String',\n      type: 'string'\n    });\n  }\n  /** `[Json]` Creates a TemplateLiteral type */\n  TemplateLiteral(unresolved, options = {}) {\n    // prettier-ignore\n    const pattern = ValueGuard.IsString(unresolved) ? TemplateLiteralPattern.Create(TemplateLiteralDslParser.Parse(unresolved)) : TemplateLiteralPattern.Create(unresolved);\n    return this.Create({\n      ...options,\n      [exports.Kind]: 'TemplateLiteral',\n      type: 'string',\n      pattern\n    });\n  }\n  /** `[Json]` Creates a Transform type */\n  Transform(schema) {\n    return new TransformDecodeBuilder(schema);\n  }\n  /** `[Json]` Creates a Tuple type */\n  Tuple(items, options = {}) {\n    const [additionalItems, minItems, maxItems] = [false, items.length, items.length];\n    const clonedItems = TypeClone.Rest(items);\n    // prettier-ignore\n    const schema = items.length > 0 ? {\n      ...options,\n      [exports.Kind]: 'Tuple',\n      type: 'array',\n      items: clonedItems,\n      additionalItems,\n      minItems,\n      maxItems\n    } : {\n      ...options,\n      [exports.Kind]: 'Tuple',\n      type: 'array',\n      minItems,\n      maxItems\n    };\n    return this.Create(schema);\n  }\n  /** `[Json]` Intrinsic function to Uncapitalize LiteralString types */\n  Uncapitalize(schema, options = {}) {\n    return {\n      ...Intrinsic.Map(TypeClone.Type(schema), 'Uncapitalize'),\n      ...options\n    };\n  }\n  /** `[Json]` Creates a Union type */\n  Union(union, options = {}) {\n    // prettier-ignore\n    return TypeGuard.TTemplateLiteral(union) ? TemplateLiteralResolver.Resolve(union) : (() => {\n      const anyOf = union;\n      if (anyOf.length === 0) return this.Never(options);\n      if (anyOf.length === 1) return this.Create(TypeClone.Type(anyOf[0], options));\n      const clonedAnyOf = TypeClone.Rest(anyOf);\n      return this.Create({\n        ...options,\n        [exports.Kind]: 'Union',\n        anyOf: clonedAnyOf\n      });\n    })();\n  }\n  /** `[Json]` Creates an Unknown type */\n  Unknown(options = {}) {\n    return this.Create({\n      ...options,\n      [exports.Kind]: 'Unknown'\n    });\n  }\n  /** `[Json]` Creates a Unsafe type that will infers as the generic argument T */\n  Unsafe(options = {}) {\n    return this.Create({\n      ...options,\n      [exports.Kind]: options[exports.Kind] || 'Unsafe'\n    });\n  }\n  /** `[Json]` Intrinsic function to Uppercase LiteralString types */\n  Uppercase(schema, options = {}) {\n    return {\n      ...Intrinsic.Map(TypeClone.Type(schema), 'Uppercase'),\n      ...options\n    };\n  }\n}\nexports.JsonTypeBuilder = JsonTypeBuilder;\n// --------------------------------------------------------------------------\n// JavaScriptTypeBuilder\n// --------------------------------------------------------------------------\nclass JavaScriptTypeBuilder extends JsonTypeBuilder {\n  /** `[JavaScript]` Creates a AsyncIterator type */\n  AsyncIterator(items, options = {}) {\n    return this.Create({\n      ...options,\n      [exports.Kind]: 'AsyncIterator',\n      type: 'AsyncIterator',\n      items: TypeClone.Type(items)\n    });\n  }\n  /** `[JavaScript]` Constructs a type by recursively unwrapping Promise types */\n  Awaited(schema, options = {}) {\n    // prettier-ignore\n    const Unwrap = rest => rest.length > 0 ? (() => {\n      const [L, ...R] = rest;\n      return [this.Awaited(L), ...Unwrap(R)];\n    })() : rest;\n    // prettier-ignore\n    return TypeGuard.TIntersect(schema) ? exports.Type.Intersect(Unwrap(schema.allOf)) : TypeGuard.TUnion(schema) ? exports.Type.Union(Unwrap(schema.anyOf)) : TypeGuard.TPromise(schema) ? this.Awaited(schema.item) : TypeClone.Type(schema, options);\n  }\n  /** `[JavaScript]` Creates a BigInt type */\n  BigInt(options = {}) {\n    return this.Create({\n      ...options,\n      [exports.Kind]: 'BigInt',\n      type: 'bigint'\n    });\n  }\n  /** `[JavaScript]` Extracts the ConstructorParameters from the given Constructor type */\n  ConstructorParameters(schema, options = {}) {\n    return this.Tuple([...schema.parameters], {\n      ...options\n    });\n  }\n  /** `[JavaScript]` Creates a Constructor type */\n  Constructor(parameters, returns, options) {\n    const [clonedParameters, clonedReturns] = [TypeClone.Rest(parameters), TypeClone.Type(returns)];\n    return this.Create({\n      ...options,\n      [exports.Kind]: 'Constructor',\n      type: 'Constructor',\n      parameters: clonedParameters,\n      returns: clonedReturns\n    });\n  }\n  /** `[JavaScript]` Creates a Date type */\n  Date(options = {}) {\n    return this.Create({\n      ...options,\n      [exports.Kind]: 'Date',\n      type: 'Date'\n    });\n  }\n  /** `[JavaScript]` Creates a Function type */\n  Function(parameters, returns, options) {\n    const [clonedParameters, clonedReturns] = [TypeClone.Rest(parameters), TypeClone.Type(returns)];\n    return this.Create({\n      ...options,\n      [exports.Kind]: 'Function',\n      type: 'Function',\n      parameters: clonedParameters,\n      returns: clonedReturns\n    });\n  }\n  /** `[JavaScript]` Extracts the InstanceType from the given Constructor type */\n  InstanceType(schema, options = {}) {\n    return TypeClone.Type(schema.returns, options);\n  }\n  /** `[JavaScript]` Creates an Iterator type */\n  Iterator(items, options = {}) {\n    return this.Create({\n      ...options,\n      [exports.Kind]: 'Iterator',\n      type: 'Iterator',\n      items: TypeClone.Type(items)\n    });\n  }\n  /** `[JavaScript]` Extracts the Parameters from the given Function type */\n  Parameters(schema, options = {}) {\n    return this.Tuple(schema.parameters, {\n      ...options\n    });\n  }\n  /** `[JavaScript]` Creates a Promise type */\n  Promise(item, options = {}) {\n    return this.Create({\n      ...options,\n      [exports.Kind]: 'Promise',\n      type: 'Promise',\n      item: TypeClone.Type(item)\n    });\n  }\n  /** `[Extended]` Creates a String type */\n  RegExp(unresolved, options = {}) {\n    const pattern = ValueGuard.IsString(unresolved) ? unresolved : unresolved.source;\n    return this.Create({\n      ...options,\n      [exports.Kind]: 'String',\n      type: 'string',\n      pattern\n    });\n  }\n  /**\n   * @deprecated Use `Type.RegExp`\n   */\n  RegEx(regex, options = {}) {\n    return this.RegExp(regex, options);\n  }\n  /** `[JavaScript]` Extracts the ReturnType from the given Function type */\n  ReturnType(schema, options = {}) {\n    return TypeClone.Type(schema.returns, options);\n  }\n  /** `[JavaScript]` Creates a Symbol type */\n  Symbol(options) {\n    return this.Create({\n      ...options,\n      [exports.Kind]: 'Symbol',\n      type: 'symbol'\n    });\n  }\n  /** `[JavaScript]` Creates a Undefined type */\n  Undefined(options = {}) {\n    return this.Create({\n      ...options,\n      [exports.Kind]: 'Undefined',\n      type: 'undefined'\n    });\n  }\n  /** `[JavaScript]` Creates a Uint8Array type */\n  Uint8Array(options = {}) {\n    return this.Create({\n      ...options,\n      [exports.Kind]: 'Uint8Array',\n      type: 'Uint8Array'\n    });\n  }\n  /** `[JavaScript]` Creates a Void type */\n  Void(options = {}) {\n    return this.Create({\n      ...options,\n      [exports.Kind]: 'Void',\n      type: 'void'\n    });\n  }\n}\nexports.JavaScriptTypeBuilder = JavaScriptTypeBuilder;\n/** Json Type Builder with Static Resolution for TypeScript */\nexports.JsonType = new JsonTypeBuilder();\n/** JavaScript Type Builder with Static Resolution for TypeScript */\nexports.Type = new JavaScriptTypeBuilder();","map":{"version":3,"names":["Object","defineProperty","exports","value","Type","JsonType","JavaScriptTypeBuilder","JsonTypeBuilder","TypeBuilder","TypeBuilderError","TransformEncodeBuilder","TransformDecodeBuilder","TemplateLiteralDslParser","TemplateLiteralGenerator","TemplateLiteralGeneratorError","TemplateLiteralFinite","TemplateLiteralFiniteError","TemplateLiteralParser","TemplateLiteralParserError","TemplateLiteralResolver","TemplateLiteralPattern","TemplateLiteralPatternError","UnionResolver","KeyArrayResolver","KeyArrayResolverError","KeyResolver","ObjectMap","Intrinsic","IndexedAccessor","TypeClone","TypeExtends","TypeExtendsResult","TypeExtendsError","ExtendsUndefined","TypeGuard","TypeGuardUnknownTypeError","ValueGuard","FormatRegistry","TypeBoxError","TypeRegistry","PatternStringExact","PatternNumberExact","PatternBooleanExact","PatternString","PatternNumber","PatternBoolean","Kind","Hint","Optional","Readonly","Transform","Symbol","for","map","Map","Entries","Clear","clear","Delete","kind","delete","Has","has","Set","func","set","Get","get","Error","constructor","message","format","IsArray","Array","isArray","IsBigInt","IsBoolean","IsDate","globalThis","Date","IsNull","IsNumber","IsObject","IsString","IsUint8Array","Uint8Array","IsUndefined","undefined","IsPattern","RegExp","IsControlCharacterFree","i","length","code","charCodeAt","IsAdditionalProperties","IsOptionalBoolean","TSchema","IsOptionalBigInt","IsOptionalNumber","IsOptionalString","IsOptionalPattern","IsOptionalFormat","IsOptionalSchema","TAny","schema","TKindOf","$id","TArray","type","items","minItems","maxItems","uniqueItems","contains","minContains","maxContains","TAsyncIterator","TBigInt","exclusiveMaximum","exclusiveMinimum","maximum","minimum","multipleOf","TBoolean","TConstructor","parameters","every","returns","TDate","exclusiveMaximumTimestamp","exclusiveMinimumTimestamp","maximumTimestamp","minimumTimestamp","multipleOfTimestamp","TFunction","TInteger","TIntersect","allOf","TTransform","unevaluatedProperties","TIterator","TKind","TLiteralString","TLiteral","const","TLiteralNumber","TLiteralBoolean","TNever","not","getOwnPropertyNames","TNot","TNull","TNumber","TObject","properties","additionalProperties","minProperties","maxProperties","entries","key","TPromise","item","TRecord","patternProperties","keys","TRecursive","TRef","$ref","TString","minLength","maxLength","pattern","TSymbol","TTemplateLiteral","TThis","TTuple","additionalItems","TUndefined","TUnionLiteral","TUnion","anyOf","TUint8Array","minByteLength","maxByteLength","TUnknown","TUnsafe","TVoid","TReadonly","TOptional","Check","some","IntoBooleanResult","result","False","True","Throw","IsStructuralRight","right","StructuralRight","left","TNeverRight","TIntersectRight","TUnionRight","TUnknownRight","TAnyRight","Union","TArrayRight","IsObjectArrayLike","Visit","TObjectRight","TRecordRight","TBooleanRight","index","TIntegerRight","TStringRight","TNumberRight","UnwrapTNot","current","depth","Unknown","IsObjectPropertyCount","count","IsObjectStringLike","IsObjectSymbolLike","description","IsObjectNumberLike","IsObjectBooleanLike","IsObjectBigIntLike","IsObjectDateLike","IsObjectUint8ArrayLike","IsObjectFunctionLike","Number","IsObjectConstructorLike","IsObjectPromiseLike","then","Function","Any","Property","RecordKey","String","RecordValue","Key","Value","Resolve","IsArrayOfTuple","TTupleRight","VoidRight","Extends","ArrayType","DateType","getTime","Uint8ArrayType","ObjectType","clonedProperties","reduce","acc","clonedSymbols","getOwnPropertySymbols","Rest","schemas","options","OptionalUnwrap","_","clone","IsIntersectOptional","IsUnionOptional","ResolveIntersect","Intersect","ResolveUnion","ResolveOptional","resolved","indexed","property","Never","element","toString","Uncapitalize","first","rest","slice","toLowerCase","Capitalize","toUpperCase","Uppercase","Lowercase","IntrinsicTemplateLiteral","mode","expression","ParseExact","finite","IntrinsicLiteral","strings","Generate","literals","Literal","mapped","IntrinsicRest","union","TemplateLiteral","L","R","callback","inner","UnwrapPattern","sets","outer","includes","add","includePatterns","ResolveKeys","ResolvePattern","join","Escape","replace","Create","kinds","template","IsNonEscaped","char","IsOpenParen","IsCloseParen","IsSeparator","IsGroup","InGroup","IsPrecedenceOr","IsPrecedenceAnd","Or","start","expressions","range","push","Parse","expr","And","Group","scan","Range","end","Reduce","buffer","Const","ParseUnion","trim","Boolean","BigInt","split","literal","ParseTerminal","ParseLiteral","template_dsl","Decode","decode","Encode","encode","Codec","TypeOrdinal","Discard","record","Strict","JSON","parse","stringify","ReadonlyOptional","Composite","objects","intersect","Index","Enum","values1","filter","isNaN","values2","trueType","falseType","Exclude","unionType","excludedMembers","narrowed","Extract","unresolved","cloned","Integer","clonedUnevaluatedProperties","KeyOf","Not","Null","propertyKeys","optionalKeys","requiredKeys","name","clonedAdditionalProperties","required","Omit","object","Partial","Pick","Record","Recursive","thisType","Ref","Required","Tuple","clonedItems","clonedAnyOf","Unsafe","AsyncIterator","Awaited","Unwrap","ConstructorParameters","Constructor","clonedParameters","clonedReturns","InstanceType","Iterator","Parameters","Promise","source","RegEx","regex","ReturnType","Undefined","Void"],"sources":["C:/Users/Administrator/solana-wallet-app/node_modules/@trezor/schema-utils/node_modules/@sinclair/typebox/typebox.js"],"sourcesContent":["\"use strict\";\n/*--------------------------------------------------------------------------\n\n@sinclair/typebox\n\nThe MIT License (MIT)\n\nCopyright (c) 2017-2023 Haydn Paterson (sinclair) <haydn.developer@gmail.com>\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n\n---------------------------------------------------------------------------*/\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Type = exports.JsonType = exports.JavaScriptTypeBuilder = exports.JsonTypeBuilder = exports.TypeBuilder = exports.TypeBuilderError = exports.TransformEncodeBuilder = exports.TransformDecodeBuilder = exports.TemplateLiteralDslParser = exports.TemplateLiteralGenerator = exports.TemplateLiteralGeneratorError = exports.TemplateLiteralFinite = exports.TemplateLiteralFiniteError = exports.TemplateLiteralParser = exports.TemplateLiteralParserError = exports.TemplateLiteralResolver = exports.TemplateLiteralPattern = exports.TemplateLiteralPatternError = exports.UnionResolver = exports.KeyArrayResolver = exports.KeyArrayResolverError = exports.KeyResolver = exports.ObjectMap = exports.Intrinsic = exports.IndexedAccessor = exports.TypeClone = exports.TypeExtends = exports.TypeExtendsResult = exports.TypeExtendsError = exports.ExtendsUndefined = exports.TypeGuard = exports.TypeGuardUnknownTypeError = exports.ValueGuard = exports.FormatRegistry = exports.TypeBoxError = exports.TypeRegistry = exports.PatternStringExact = exports.PatternNumberExact = exports.PatternBooleanExact = exports.PatternString = exports.PatternNumber = exports.PatternBoolean = exports.Kind = exports.Hint = exports.Optional = exports.Readonly = exports.Transform = void 0;\n// --------------------------------------------------------------------------\n// Symbols\n// --------------------------------------------------------------------------\nexports.Transform = Symbol.for('TypeBox.Transform');\nexports.Readonly = Symbol.for('TypeBox.Readonly');\nexports.Optional = Symbol.for('TypeBox.Optional');\nexports.Hint = Symbol.for('TypeBox.Hint');\nexports.Kind = Symbol.for('TypeBox.Kind');\n// --------------------------------------------------------------------------\n// Patterns\n// --------------------------------------------------------------------------\nexports.PatternBoolean = '(true|false)';\nexports.PatternNumber = '(0|[1-9][0-9]*)';\nexports.PatternString = '(.*)';\nexports.PatternBooleanExact = `^${exports.PatternBoolean}$`;\nexports.PatternNumberExact = `^${exports.PatternNumber}$`;\nexports.PatternStringExact = `^${exports.PatternString}$`;\n/** A registry for user defined types */\nvar TypeRegistry;\n(function (TypeRegistry) {\n    const map = new Map();\n    /** Returns the entries in this registry */\n    function Entries() {\n        return new Map(map);\n    }\n    TypeRegistry.Entries = Entries;\n    /** Clears all user defined types */\n    function Clear() {\n        return map.clear();\n    }\n    TypeRegistry.Clear = Clear;\n    /** Deletes a registered type */\n    function Delete(kind) {\n        return map.delete(kind);\n    }\n    TypeRegistry.Delete = Delete;\n    /** Returns true if this registry contains this kind */\n    function Has(kind) {\n        return map.has(kind);\n    }\n    TypeRegistry.Has = Has;\n    /** Sets a validation function for a user defined type */\n    function Set(kind, func) {\n        map.set(kind, func);\n    }\n    TypeRegistry.Set = Set;\n    /** Gets a custom validation function for a user defined type */\n    function Get(kind) {\n        return map.get(kind);\n    }\n    TypeRegistry.Get = Get;\n})(TypeRegistry || (exports.TypeRegistry = TypeRegistry = {}));\n// --------------------------------------------------------------------------\n// TypeBoxError\n// --------------------------------------------------------------------------\nclass TypeBoxError extends Error {\n    constructor(message) {\n        super(message);\n    }\n}\nexports.TypeBoxError = TypeBoxError;\n/** A registry for user defined string formats */\nvar FormatRegistry;\n(function (FormatRegistry) {\n    const map = new Map();\n    /** Returns the entries in this registry */\n    function Entries() {\n        return new Map(map);\n    }\n    FormatRegistry.Entries = Entries;\n    /** Clears all user defined string formats */\n    function Clear() {\n        return map.clear();\n    }\n    FormatRegistry.Clear = Clear;\n    /** Deletes a registered format */\n    function Delete(format) {\n        return map.delete(format);\n    }\n    FormatRegistry.Delete = Delete;\n    /** Returns true if the user defined string format exists */\n    function Has(format) {\n        return map.has(format);\n    }\n    FormatRegistry.Has = Has;\n    /** Sets a validation function for a user defined string format */\n    function Set(format, func) {\n        map.set(format, func);\n    }\n    FormatRegistry.Set = Set;\n    /** Gets a validation function for a user defined string format */\n    function Get(format) {\n        return map.get(format);\n    }\n    FormatRegistry.Get = Get;\n})(FormatRegistry || (exports.FormatRegistry = FormatRegistry = {}));\n// --------------------------------------------------------------------------\n// ValueGuard\n// --------------------------------------------------------------------------\n/** Provides functions to type guard raw JavaScript values */\nvar ValueGuard;\n(function (ValueGuard) {\n    /** Returns true if this value is an array */\n    function IsArray(value) {\n        return Array.isArray(value);\n    }\n    ValueGuard.IsArray = IsArray;\n    /** Returns true if this value is bigint */\n    function IsBigInt(value) {\n        return typeof value === 'bigint';\n    }\n    ValueGuard.IsBigInt = IsBigInt;\n    /** Returns true if this value is a boolean */\n    function IsBoolean(value) {\n        return typeof value === 'boolean';\n    }\n    ValueGuard.IsBoolean = IsBoolean;\n    /** Returns true if this value is a Date object */\n    function IsDate(value) {\n        return value instanceof globalThis.Date;\n    }\n    ValueGuard.IsDate = IsDate;\n    /** Returns true if this value is null */\n    function IsNull(value) {\n        return value === null;\n    }\n    ValueGuard.IsNull = IsNull;\n    /** Returns true if this value is number */\n    function IsNumber(value) {\n        return typeof value === 'number';\n    }\n    ValueGuard.IsNumber = IsNumber;\n    /** Returns true if this value is an object */\n    function IsObject(value) {\n        return typeof value === 'object' && value !== null;\n    }\n    ValueGuard.IsObject = IsObject;\n    /** Returns true if this value is string */\n    function IsString(value) {\n        return typeof value === 'string';\n    }\n    ValueGuard.IsString = IsString;\n    /** Returns true if this value is a Uint8Array */\n    function IsUint8Array(value) {\n        return value instanceof globalThis.Uint8Array;\n    }\n    ValueGuard.IsUint8Array = IsUint8Array;\n    /** Returns true if this value is undefined */\n    function IsUndefined(value) {\n        return value === undefined;\n    }\n    ValueGuard.IsUndefined = IsUndefined;\n})(ValueGuard || (exports.ValueGuard = ValueGuard = {}));\n// --------------------------------------------------------------------------\n// TypeGuard\n// --------------------------------------------------------------------------\nclass TypeGuardUnknownTypeError extends TypeBoxError {\n}\nexports.TypeGuardUnknownTypeError = TypeGuardUnknownTypeError;\n/** Provides functions to test if JavaScript values are TypeBox types */\nvar TypeGuard;\n(function (TypeGuard) {\n    function IsPattern(value) {\n        try {\n            new RegExp(value);\n            return true;\n        }\n        catch {\n            return false;\n        }\n    }\n    function IsControlCharacterFree(value) {\n        if (!ValueGuard.IsString(value))\n            return false;\n        for (let i = 0; i < value.length; i++) {\n            const code = value.charCodeAt(i);\n            if ((code >= 7 && code <= 13) || code === 27 || code === 127) {\n                return false;\n            }\n        }\n        return true;\n    }\n    function IsAdditionalProperties(value) {\n        return IsOptionalBoolean(value) || TSchema(value);\n    }\n    function IsOptionalBigInt(value) {\n        return ValueGuard.IsUndefined(value) || ValueGuard.IsBigInt(value);\n    }\n    function IsOptionalNumber(value) {\n        return ValueGuard.IsUndefined(value) || ValueGuard.IsNumber(value);\n    }\n    function IsOptionalBoolean(value) {\n        return ValueGuard.IsUndefined(value) || ValueGuard.IsBoolean(value);\n    }\n    function IsOptionalString(value) {\n        return ValueGuard.IsUndefined(value) || ValueGuard.IsString(value);\n    }\n    function IsOptionalPattern(value) {\n        return ValueGuard.IsUndefined(value) || (ValueGuard.IsString(value) && IsControlCharacterFree(value) && IsPattern(value));\n    }\n    function IsOptionalFormat(value) {\n        return ValueGuard.IsUndefined(value) || (ValueGuard.IsString(value) && IsControlCharacterFree(value));\n    }\n    function IsOptionalSchema(value) {\n        return ValueGuard.IsUndefined(value) || TSchema(value);\n    }\n    // ----------------------------------------------------------------\n    // Types\n    // ----------------------------------------------------------------\n    /** Returns true if the given value is TAny */\n    function TAny(schema) {\n        // prettier-ignore\n        return (TKindOf(schema, 'Any') &&\n            IsOptionalString(schema.$id));\n    }\n    TypeGuard.TAny = TAny;\n    /** Returns true if the given value is TArray */\n    function TArray(schema) {\n        return (TKindOf(schema, 'Array') &&\n            schema.type === 'array' &&\n            IsOptionalString(schema.$id) &&\n            TSchema(schema.items) &&\n            IsOptionalNumber(schema.minItems) &&\n            IsOptionalNumber(schema.maxItems) &&\n            IsOptionalBoolean(schema.uniqueItems) &&\n            IsOptionalSchema(schema.contains) &&\n            IsOptionalNumber(schema.minContains) &&\n            IsOptionalNumber(schema.maxContains));\n    }\n    TypeGuard.TArray = TArray;\n    /** Returns true if the given value is TAsyncIterator */\n    function TAsyncIterator(schema) {\n        // prettier-ignore\n        return (TKindOf(schema, 'AsyncIterator') &&\n            schema.type === 'AsyncIterator' &&\n            IsOptionalString(schema.$id) &&\n            TSchema(schema.items));\n    }\n    TypeGuard.TAsyncIterator = TAsyncIterator;\n    /** Returns true if the given value is TBigInt */\n    function TBigInt(schema) {\n        // prettier-ignore\n        return (TKindOf(schema, 'BigInt') &&\n            schema.type === 'bigint' &&\n            IsOptionalString(schema.$id) &&\n            IsOptionalBigInt(schema.exclusiveMaximum) &&\n            IsOptionalBigInt(schema.exclusiveMinimum) &&\n            IsOptionalBigInt(schema.maximum) &&\n            IsOptionalBigInt(schema.minimum) &&\n            IsOptionalBigInt(schema.multipleOf));\n    }\n    TypeGuard.TBigInt = TBigInt;\n    /** Returns true if the given value is TBoolean */\n    function TBoolean(schema) {\n        // prettier-ignore\n        return (TKindOf(schema, 'Boolean') &&\n            schema.type === 'boolean' &&\n            IsOptionalString(schema.$id));\n    }\n    TypeGuard.TBoolean = TBoolean;\n    /** Returns true if the given value is TConstructor */\n    function TConstructor(schema) {\n        // prettier-ignore\n        return (TKindOf(schema, 'Constructor') &&\n            schema.type === 'Constructor' &&\n            IsOptionalString(schema.$id) &&\n            ValueGuard.IsArray(schema.parameters) &&\n            schema.parameters.every(schema => TSchema(schema)) &&\n            TSchema(schema.returns));\n    }\n    TypeGuard.TConstructor = TConstructor;\n    /** Returns true if the given value is TDate */\n    function TDate(schema) {\n        return (TKindOf(schema, 'Date') &&\n            schema.type === 'Date' &&\n            IsOptionalString(schema.$id) &&\n            IsOptionalNumber(schema.exclusiveMaximumTimestamp) &&\n            IsOptionalNumber(schema.exclusiveMinimumTimestamp) &&\n            IsOptionalNumber(schema.maximumTimestamp) &&\n            IsOptionalNumber(schema.minimumTimestamp) &&\n            IsOptionalNumber(schema.multipleOfTimestamp));\n    }\n    TypeGuard.TDate = TDate;\n    /** Returns true if the given value is TFunction */\n    function TFunction(schema) {\n        // prettier-ignore\n        return (TKindOf(schema, 'Function') &&\n            schema.type === 'Function' &&\n            IsOptionalString(schema.$id) &&\n            ValueGuard.IsArray(schema.parameters) &&\n            schema.parameters.every(schema => TSchema(schema)) &&\n            TSchema(schema.returns));\n    }\n    TypeGuard.TFunction = TFunction;\n    /** Returns true if the given value is TInteger */\n    function TInteger(schema) {\n        return (TKindOf(schema, 'Integer') &&\n            schema.type === 'integer' &&\n            IsOptionalString(schema.$id) &&\n            IsOptionalNumber(schema.exclusiveMaximum) &&\n            IsOptionalNumber(schema.exclusiveMinimum) &&\n            IsOptionalNumber(schema.maximum) &&\n            IsOptionalNumber(schema.minimum) &&\n            IsOptionalNumber(schema.multipleOf));\n    }\n    TypeGuard.TInteger = TInteger;\n    /** Returns true if the given value is TIntersect */\n    function TIntersect(schema) {\n        // prettier-ignore\n        return (TKindOf(schema, 'Intersect') &&\n            (ValueGuard.IsString(schema.type) && schema.type !== 'object' ? false : true) &&\n            ValueGuard.IsArray(schema.allOf) &&\n            schema.allOf.every(schema => TSchema(schema) && !TTransform(schema)) &&\n            IsOptionalString(schema.type) &&\n            (IsOptionalBoolean(schema.unevaluatedProperties) || IsOptionalSchema(schema.unevaluatedProperties)) &&\n            IsOptionalString(schema.$id));\n    }\n    TypeGuard.TIntersect = TIntersect;\n    /** Returns true if the given value is TIterator */\n    function TIterator(schema) {\n        // prettier-ignore\n        return (TKindOf(schema, 'Iterator') &&\n            schema.type === 'Iterator' &&\n            IsOptionalString(schema.$id) &&\n            TSchema(schema.items));\n    }\n    TypeGuard.TIterator = TIterator;\n    /** Returns true if the given value is a TKind with the given name. */\n    function TKindOf(schema, kind) {\n        return TKind(schema) && schema[exports.Kind] === kind;\n    }\n    TypeGuard.TKindOf = TKindOf;\n    /** Returns true if the given value is TKind */\n    function TKind(schema) {\n        return ValueGuard.IsObject(schema) && exports.Kind in schema && ValueGuard.IsString(schema[exports.Kind]);\n    }\n    TypeGuard.TKind = TKind;\n    /** Returns true if the given value is TLiteral<string> */\n    function TLiteralString(schema) {\n        return TLiteral(schema) && ValueGuard.IsString(schema.const);\n    }\n    TypeGuard.TLiteralString = TLiteralString;\n    /** Returns true if the given value is TLiteral<number> */\n    function TLiteralNumber(schema) {\n        return TLiteral(schema) && ValueGuard.IsNumber(schema.const);\n    }\n    TypeGuard.TLiteralNumber = TLiteralNumber;\n    /** Returns true if the given value is TLiteral<boolean> */\n    function TLiteralBoolean(schema) {\n        return TLiteral(schema) && ValueGuard.IsBoolean(schema.const);\n    }\n    TypeGuard.TLiteralBoolean = TLiteralBoolean;\n    /** Returns true if the given value is TLiteral */\n    function TLiteral(schema) {\n        // prettier-ignore\n        return (TKindOf(schema, 'Literal') &&\n            IsOptionalString(schema.$id) && (ValueGuard.IsBoolean(schema.const) ||\n            ValueGuard.IsNumber(schema.const) ||\n            ValueGuard.IsString(schema.const)));\n    }\n    TypeGuard.TLiteral = TLiteral;\n    /** Returns true if the given value is TNever */\n    function TNever(schema) {\n        // prettier-ignore\n        return (TKindOf(schema, 'Never') &&\n            ValueGuard.IsObject(schema.not) &&\n            Object.getOwnPropertyNames(schema.not).length === 0);\n    }\n    TypeGuard.TNever = TNever;\n    /** Returns true if the given value is TNot */\n    function TNot(schema) {\n        // prettier-ignore\n        return (TKindOf(schema, 'Not') &&\n            TSchema(schema.not));\n    }\n    TypeGuard.TNot = TNot;\n    /** Returns true if the given value is TNull */\n    function TNull(schema) {\n        // prettier-ignore\n        return (TKindOf(schema, 'Null') &&\n            schema.type === 'null' &&\n            IsOptionalString(schema.$id));\n    }\n    TypeGuard.TNull = TNull;\n    /** Returns true if the given value is TNumber */\n    function TNumber(schema) {\n        return (TKindOf(schema, 'Number') &&\n            schema.type === 'number' &&\n            IsOptionalString(schema.$id) &&\n            IsOptionalNumber(schema.exclusiveMaximum) &&\n            IsOptionalNumber(schema.exclusiveMinimum) &&\n            IsOptionalNumber(schema.maximum) &&\n            IsOptionalNumber(schema.minimum) &&\n            IsOptionalNumber(schema.multipleOf));\n    }\n    TypeGuard.TNumber = TNumber;\n    /** Returns true if the given value is TObject */\n    function TObject(schema) {\n        // prettier-ignore\n        return (TKindOf(schema, 'Object') &&\n            schema.type === 'object' &&\n            IsOptionalString(schema.$id) &&\n            ValueGuard.IsObject(schema.properties) &&\n            IsAdditionalProperties(schema.additionalProperties) &&\n            IsOptionalNumber(schema.minProperties) &&\n            IsOptionalNumber(schema.maxProperties) &&\n            Object.entries(schema.properties).every(([key, schema]) => IsControlCharacterFree(key) && TSchema(schema)));\n    }\n    TypeGuard.TObject = TObject;\n    /** Returns true if the given value is TPromise */\n    function TPromise(schema) {\n        // prettier-ignore\n        return (TKindOf(schema, 'Promise') &&\n            schema.type === 'Promise' &&\n            IsOptionalString(schema.$id) &&\n            TSchema(schema.item));\n    }\n    TypeGuard.TPromise = TPromise;\n    /** Returns true if the given value is TRecord */\n    function TRecord(schema) {\n        // prettier-ignore\n        return (TKindOf(schema, 'Record') &&\n            schema.type === 'object' &&\n            IsOptionalString(schema.$id) &&\n            IsAdditionalProperties(schema.additionalProperties) &&\n            ValueGuard.IsObject(schema.patternProperties) &&\n            ((schema) => {\n                const keys = Object.getOwnPropertyNames(schema.patternProperties);\n                return (keys.length === 1 &&\n                    IsPattern(keys[0]) &&\n                    ValueGuard.IsObject(schema.patternProperties) &&\n                    TSchema(schema.patternProperties[keys[0]]));\n            })(schema));\n    }\n    TypeGuard.TRecord = TRecord;\n    /** Returns true if this value is TRecursive */\n    function TRecursive(schema) {\n        return ValueGuard.IsObject(schema) && exports.Hint in schema && schema[exports.Hint] === 'Recursive';\n    }\n    TypeGuard.TRecursive = TRecursive;\n    /** Returns true if the given value is TRef */\n    function TRef(schema) {\n        // prettier-ignore\n        return (TKindOf(schema, 'Ref') &&\n            IsOptionalString(schema.$id) &&\n            ValueGuard.IsString(schema.$ref));\n    }\n    TypeGuard.TRef = TRef;\n    /** Returns true if the given value is TString */\n    function TString(schema) {\n        // prettier-ignore\n        return (TKindOf(schema, 'String') &&\n            schema.type === 'string' &&\n            IsOptionalString(schema.$id) &&\n            IsOptionalNumber(schema.minLength) &&\n            IsOptionalNumber(schema.maxLength) &&\n            IsOptionalPattern(schema.pattern) &&\n            IsOptionalFormat(schema.format));\n    }\n    TypeGuard.TString = TString;\n    /** Returns true if the given value is TSymbol */\n    function TSymbol(schema) {\n        // prettier-ignore\n        return (TKindOf(schema, 'Symbol') &&\n            schema.type === 'symbol' &&\n            IsOptionalString(schema.$id));\n    }\n    TypeGuard.TSymbol = TSymbol;\n    /** Returns true if the given value is TTemplateLiteral */\n    function TTemplateLiteral(schema) {\n        // prettier-ignore\n        return (TKindOf(schema, 'TemplateLiteral') &&\n            schema.type === 'string' &&\n            ValueGuard.IsString(schema.pattern) &&\n            schema.pattern[0] === '^' &&\n            schema.pattern[schema.pattern.length - 1] === '$');\n    }\n    TypeGuard.TTemplateLiteral = TTemplateLiteral;\n    /** Returns true if the given value is TThis */\n    function TThis(schema) {\n        // prettier-ignore\n        return (TKindOf(schema, 'This') &&\n            IsOptionalString(schema.$id) &&\n            ValueGuard.IsString(schema.$ref));\n    }\n    TypeGuard.TThis = TThis;\n    /** Returns true of this value is TTransform */\n    function TTransform(schema) {\n        return ValueGuard.IsObject(schema) && exports.Transform in schema;\n    }\n    TypeGuard.TTransform = TTransform;\n    /** Returns true if the given value is TTuple */\n    function TTuple(schema) {\n        // prettier-ignore\n        return (TKindOf(schema, 'Tuple') &&\n            schema.type === 'array' &&\n            IsOptionalString(schema.$id) &&\n            ValueGuard.IsNumber(schema.minItems) &&\n            ValueGuard.IsNumber(schema.maxItems) &&\n            schema.minItems === schema.maxItems &&\n            (( // empty\n            ValueGuard.IsUndefined(schema.items) &&\n                ValueGuard.IsUndefined(schema.additionalItems) &&\n                schema.minItems === 0) || (ValueGuard.IsArray(schema.items) &&\n                schema.items.every(schema => TSchema(schema)))));\n    }\n    TypeGuard.TTuple = TTuple;\n    /** Returns true if the given value is TUndefined */\n    function TUndefined(schema) {\n        // prettier-ignore\n        return (TKindOf(schema, 'Undefined') &&\n            schema.type === 'undefined' &&\n            IsOptionalString(schema.$id));\n    }\n    TypeGuard.TUndefined = TUndefined;\n    /** Returns true if the given value is TUnion<Literal<string | number>[]> */\n    function TUnionLiteral(schema) {\n        return TUnion(schema) && schema.anyOf.every((schema) => TLiteralString(schema) || TLiteralNumber(schema));\n    }\n    TypeGuard.TUnionLiteral = TUnionLiteral;\n    /** Returns true if the given value is TUnion */\n    function TUnion(schema) {\n        // prettier-ignore\n        return (TKindOf(schema, 'Union') &&\n            IsOptionalString(schema.$id) &&\n            ValueGuard.IsObject(schema) &&\n            ValueGuard.IsArray(schema.anyOf) &&\n            schema.anyOf.every(schema => TSchema(schema)));\n    }\n    TypeGuard.TUnion = TUnion;\n    /** Returns true if the given value is TUint8Array */\n    function TUint8Array(schema) {\n        // prettier-ignore\n        return (TKindOf(schema, 'Uint8Array') &&\n            schema.type === 'Uint8Array' &&\n            IsOptionalString(schema.$id) &&\n            IsOptionalNumber(schema.minByteLength) &&\n            IsOptionalNumber(schema.maxByteLength));\n    }\n    TypeGuard.TUint8Array = TUint8Array;\n    /** Returns true if the given value is TUnknown */\n    function TUnknown(schema) {\n        // prettier-ignore\n        return (TKindOf(schema, 'Unknown') &&\n            IsOptionalString(schema.$id));\n    }\n    TypeGuard.TUnknown = TUnknown;\n    /** Returns true if the given value is a raw TUnsafe */\n    function TUnsafe(schema) {\n        return TKindOf(schema, 'Unsafe');\n    }\n    TypeGuard.TUnsafe = TUnsafe;\n    /** Returns true if the given value is TVoid */\n    function TVoid(schema) {\n        // prettier-ignore\n        return (TKindOf(schema, 'Void') &&\n            schema.type === 'void' &&\n            IsOptionalString(schema.$id));\n    }\n    TypeGuard.TVoid = TVoid;\n    /** Returns true if this value has a Readonly symbol */\n    function TReadonly(schema) {\n        return ValueGuard.IsObject(schema) && schema[exports.Readonly] === 'Readonly';\n    }\n    TypeGuard.TReadonly = TReadonly;\n    /** Returns true if this value has a Optional symbol */\n    function TOptional(schema) {\n        return ValueGuard.IsObject(schema) && schema[exports.Optional] === 'Optional';\n    }\n    TypeGuard.TOptional = TOptional;\n    /** Returns true if the given value is TSchema */\n    function TSchema(schema) {\n        // prettier-ignore\n        return (ValueGuard.IsObject(schema)) && (TAny(schema) ||\n            TArray(schema) ||\n            TBoolean(schema) ||\n            TBigInt(schema) ||\n            TAsyncIterator(schema) ||\n            TConstructor(schema) ||\n            TDate(schema) ||\n            TFunction(schema) ||\n            TInteger(schema) ||\n            TIntersect(schema) ||\n            TIterator(schema) ||\n            TLiteral(schema) ||\n            TNever(schema) ||\n            TNot(schema) ||\n            TNull(schema) ||\n            TNumber(schema) ||\n            TObject(schema) ||\n            TPromise(schema) ||\n            TRecord(schema) ||\n            TRef(schema) ||\n            TString(schema) ||\n            TSymbol(schema) ||\n            TTemplateLiteral(schema) ||\n            TThis(schema) ||\n            TTuple(schema) ||\n            TUndefined(schema) ||\n            TUnion(schema) ||\n            TUint8Array(schema) ||\n            TUnknown(schema) ||\n            TUnsafe(schema) ||\n            TVoid(schema) ||\n            (TKind(schema) && TypeRegistry.Has(schema[exports.Kind])));\n    }\n    TypeGuard.TSchema = TSchema;\n})(TypeGuard || (exports.TypeGuard = TypeGuard = {}));\n// --------------------------------------------------------------------------\n// ExtendsUndefined\n// --------------------------------------------------------------------------\n/** Fast undefined check used for properties of type undefined */\nvar ExtendsUndefined;\n(function (ExtendsUndefined) {\n    function Check(schema) {\n        return schema[exports.Kind] === 'Intersect'\n            ? schema.allOf.every((schema) => Check(schema))\n            : schema[exports.Kind] === 'Union'\n                ? schema.anyOf.some((schema) => Check(schema))\n                : schema[exports.Kind] === 'Undefined'\n                    ? true\n                    : schema[exports.Kind] === 'Not'\n                        ? !Check(schema.not)\n                        : false;\n    }\n    ExtendsUndefined.Check = Check;\n})(ExtendsUndefined || (exports.ExtendsUndefined = ExtendsUndefined = {}));\n// --------------------------------------------------------------------------\n// TypeExtends\n// --------------------------------------------------------------------------\nclass TypeExtendsError extends TypeBoxError {\n}\nexports.TypeExtendsError = TypeExtendsError;\nvar TypeExtendsResult;\n(function (TypeExtendsResult) {\n    TypeExtendsResult[TypeExtendsResult[\"Union\"] = 0] = \"Union\";\n    TypeExtendsResult[TypeExtendsResult[\"True\"] = 1] = \"True\";\n    TypeExtendsResult[TypeExtendsResult[\"False\"] = 2] = \"False\";\n})(TypeExtendsResult || (exports.TypeExtendsResult = TypeExtendsResult = {}));\nvar TypeExtends;\n(function (TypeExtends) {\n    // --------------------------------------------------------------------------\n    // IntoBooleanResult\n    // --------------------------------------------------------------------------\n    function IntoBooleanResult(result) {\n        return result === TypeExtendsResult.False ? result : TypeExtendsResult.True;\n    }\n    // --------------------------------------------------------------------------\n    // Throw\n    // --------------------------------------------------------------------------\n    function Throw(message) {\n        throw new TypeExtendsError(message);\n    }\n    // --------------------------------------------------------------------------\n    // StructuralRight\n    // --------------------------------------------------------------------------\n    function IsStructuralRight(right) {\n        // prettier-ignore\n        return (TypeGuard.TNever(right) ||\n            TypeGuard.TIntersect(right) ||\n            TypeGuard.TUnion(right) ||\n            TypeGuard.TUnknown(right) ||\n            TypeGuard.TAny(right));\n    }\n    function StructuralRight(left, right) {\n        // prettier-ignore\n        return (TypeGuard.TNever(right) ? TNeverRight(left, right) :\n            TypeGuard.TIntersect(right) ? TIntersectRight(left, right) :\n                TypeGuard.TUnion(right) ? TUnionRight(left, right) :\n                    TypeGuard.TUnknown(right) ? TUnknownRight(left, right) :\n                        TypeGuard.TAny(right) ? TAnyRight(left, right) :\n                            Throw('StructuralRight'));\n    }\n    // --------------------------------------------------------------------------\n    // Any\n    // --------------------------------------------------------------------------\n    function TAnyRight(left, right) {\n        return TypeExtendsResult.True;\n    }\n    function TAny(left, right) {\n        // prettier-ignore\n        return (TypeGuard.TIntersect(right) ? TIntersectRight(left, right) :\n            (TypeGuard.TUnion(right) && right.anyOf.some((schema) => TypeGuard.TAny(schema) || TypeGuard.TUnknown(schema))) ? TypeExtendsResult.True :\n                TypeGuard.TUnion(right) ? TypeExtendsResult.Union :\n                    TypeGuard.TUnknown(right) ? TypeExtendsResult.True :\n                        TypeGuard.TAny(right) ? TypeExtendsResult.True :\n                            TypeExtendsResult.Union);\n    }\n    // --------------------------------------------------------------------------\n    // Array\n    // --------------------------------------------------------------------------\n    function TArrayRight(left, right) {\n        // prettier-ignore\n        return (TypeGuard.TUnknown(left) ? TypeExtendsResult.False :\n            TypeGuard.TAny(left) ? TypeExtendsResult.Union :\n                TypeGuard.TNever(left) ? TypeExtendsResult.True :\n                    TypeExtendsResult.False);\n    }\n    function TArray(left, right) {\n        // prettier-ignore\n        return (TypeGuard.TObject(right) && IsObjectArrayLike(right) ? TypeExtendsResult.True :\n            IsStructuralRight(right) ? StructuralRight(left, right) :\n                !TypeGuard.TArray(right) ? TypeExtendsResult.False :\n                    IntoBooleanResult(Visit(left.items, right.items)));\n    }\n    // --------------------------------------------------------------------------\n    // AsyncIterator\n    // --------------------------------------------------------------------------\n    function TAsyncIterator(left, right) {\n        // prettier-ignore\n        return (IsStructuralRight(right) ? StructuralRight(left, right) :\n            !TypeGuard.TAsyncIterator(right) ? TypeExtendsResult.False :\n                IntoBooleanResult(Visit(left.items, right.items)));\n    }\n    // --------------------------------------------------------------------------\n    // BigInt\n    // --------------------------------------------------------------------------\n    function TBigInt(left, right) {\n        // prettier-ignore\n        return (IsStructuralRight(right) ? StructuralRight(left, right) :\n            TypeGuard.TObject(right) ? TObjectRight(left, right) :\n                TypeGuard.TRecord(right) ? TRecordRight(left, right) :\n                    TypeGuard.TBigInt(right) ? TypeExtendsResult.True :\n                        TypeExtendsResult.False);\n    }\n    // --------------------------------------------------------------------------\n    // Boolean\n    // --------------------------------------------------------------------------\n    function TBooleanRight(left, right) {\n        return TypeGuard.TLiteral(left) && ValueGuard.IsBoolean(left.const) ? TypeExtendsResult.True : TypeGuard.TBoolean(left) ? TypeExtendsResult.True : TypeExtendsResult.False;\n    }\n    function TBoolean(left, right) {\n        // prettier-ignore\n        return (IsStructuralRight(right) ? StructuralRight(left, right) :\n            TypeGuard.TObject(right) ? TObjectRight(left, right) :\n                TypeGuard.TRecord(right) ? TRecordRight(left, right) :\n                    TypeGuard.TBoolean(right) ? TypeExtendsResult.True :\n                        TypeExtendsResult.False);\n    }\n    // --------------------------------------------------------------------------\n    // Constructor\n    // --------------------------------------------------------------------------\n    function TConstructor(left, right) {\n        // prettier-ignore\n        return (IsStructuralRight(right) ? StructuralRight(left, right) :\n            TypeGuard.TObject(right) ? TObjectRight(left, right) :\n                !TypeGuard.TConstructor(right) ? TypeExtendsResult.False :\n                    left.parameters.length > right.parameters.length ? TypeExtendsResult.False :\n                        (!left.parameters.every((schema, index) => IntoBooleanResult(Visit(right.parameters[index], schema)) === TypeExtendsResult.True)) ? TypeExtendsResult.False :\n                            IntoBooleanResult(Visit(left.returns, right.returns)));\n    }\n    // --------------------------------------------------------------------------\n    // Date\n    // --------------------------------------------------------------------------\n    function TDate(left, right) {\n        // prettier-ignore\n        return (IsStructuralRight(right) ? StructuralRight(left, right) :\n            TypeGuard.TObject(right) ? TObjectRight(left, right) :\n                TypeGuard.TRecord(right) ? TRecordRight(left, right) :\n                    TypeGuard.TDate(right) ? TypeExtendsResult.True :\n                        TypeExtendsResult.False);\n    }\n    // --------------------------------------------------------------------------\n    // Function\n    // --------------------------------------------------------------------------\n    function TFunction(left, right) {\n        // prettier-ignore\n        return (IsStructuralRight(right) ? StructuralRight(left, right) :\n            TypeGuard.TObject(right) ? TObjectRight(left, right) :\n                !TypeGuard.TFunction(right) ? TypeExtendsResult.False :\n                    left.parameters.length > right.parameters.length ? TypeExtendsResult.False :\n                        (!left.parameters.every((schema, index) => IntoBooleanResult(Visit(right.parameters[index], schema)) === TypeExtendsResult.True)) ? TypeExtendsResult.False :\n                            IntoBooleanResult(Visit(left.returns, right.returns)));\n    }\n    // --------------------------------------------------------------------------\n    // Integer\n    // --------------------------------------------------------------------------\n    function TIntegerRight(left, right) {\n        // prettier-ignore\n        return (TypeGuard.TLiteral(left) && ValueGuard.IsNumber(left.const) ? TypeExtendsResult.True :\n            TypeGuard.TNumber(left) || TypeGuard.TInteger(left) ? TypeExtendsResult.True :\n                TypeExtendsResult.False);\n    }\n    function TInteger(left, right) {\n        // prettier-ignore\n        return (TypeGuard.TInteger(right) || TypeGuard.TNumber(right) ? TypeExtendsResult.True :\n            IsStructuralRight(right) ? StructuralRight(left, right) :\n                TypeGuard.TObject(right) ? TObjectRight(left, right) :\n                    TypeGuard.TRecord(right) ? TRecordRight(left, right) :\n                        TypeExtendsResult.False);\n    }\n    // --------------------------------------------------------------------------\n    // Intersect\n    // --------------------------------------------------------------------------\n    function TIntersectRight(left, right) {\n        // prettier-ignore\n        return right.allOf.every((schema) => Visit(left, schema) === TypeExtendsResult.True)\n            ? TypeExtendsResult.True\n            : TypeExtendsResult.False;\n    }\n    function TIntersect(left, right) {\n        // prettier-ignore\n        return left.allOf.some((schema) => Visit(schema, right) === TypeExtendsResult.True)\n            ? TypeExtendsResult.True\n            : TypeExtendsResult.False;\n    }\n    // --------------------------------------------------------------------------\n    // Iterator\n    // --------------------------------------------------------------------------\n    function TIterator(left, right) {\n        // prettier-ignore\n        return (IsStructuralRight(right) ? StructuralRight(left, right) :\n            !TypeGuard.TIterator(right) ? TypeExtendsResult.False :\n                IntoBooleanResult(Visit(left.items, right.items)));\n    }\n    // --------------------------------------------------------------------------\n    // Literal\n    // --------------------------------------------------------------------------\n    function TLiteral(left, right) {\n        // prettier-ignore\n        return (TypeGuard.TLiteral(right) && right.const === left.const ? TypeExtendsResult.True :\n            IsStructuralRight(right) ? StructuralRight(left, right) :\n                TypeGuard.TObject(right) ? TObjectRight(left, right) :\n                    TypeGuard.TRecord(right) ? TRecordRight(left, right) :\n                        TypeGuard.TString(right) ? TStringRight(left, right) :\n                            TypeGuard.TNumber(right) ? TNumberRight(left, right) :\n                                TypeGuard.TInteger(right) ? TIntegerRight(left, right) :\n                                    TypeGuard.TBoolean(right) ? TBooleanRight(left, right) :\n                                        TypeExtendsResult.False);\n    }\n    // --------------------------------------------------------------------------\n    // Never\n    // --------------------------------------------------------------------------\n    function TNeverRight(left, right) {\n        return TypeExtendsResult.False;\n    }\n    function TNever(left, right) {\n        return TypeExtendsResult.True;\n    }\n    // --------------------------------------------------------------------------\n    // Not\n    // --------------------------------------------------------------------------\n    function UnwrapTNot(schema) {\n        let [current, depth] = [schema, 0];\n        while (true) {\n            if (!TypeGuard.TNot(current))\n                break;\n            current = current.not;\n            depth += 1;\n        }\n        return depth % 2 === 0 ? current : exports.Type.Unknown();\n    }\n    function TNot(left, right) {\n        // TypeScript has no concept of negated types, and attempts to correctly check the negated\n        // type at runtime would put TypeBox at odds with TypeScripts ability to statically infer\n        // the type. Instead we unwrap to either unknown or T and continue evaluating.\n        // prettier-ignore\n        return (TypeGuard.TNot(left) ? Visit(UnwrapTNot(left), right) :\n            TypeGuard.TNot(right) ? Visit(left, UnwrapTNot(right)) :\n                Throw('Invalid fallthrough for Not'));\n    }\n    // --------------------------------------------------------------------------\n    // Null\n    // --------------------------------------------------------------------------\n    function TNull(left, right) {\n        // prettier-ignore\n        return (IsStructuralRight(right) ? StructuralRight(left, right) :\n            TypeGuard.TObject(right) ? TObjectRight(left, right) :\n                TypeGuard.TRecord(right) ? TRecordRight(left, right) :\n                    TypeGuard.TNull(right) ? TypeExtendsResult.True :\n                        TypeExtendsResult.False);\n    }\n    // --------------------------------------------------------------------------\n    // Number\n    // --------------------------------------------------------------------------\n    function TNumberRight(left, right) {\n        // prettier-ignore\n        return (TypeGuard.TLiteralNumber(left) ? TypeExtendsResult.True :\n            TypeGuard.TNumber(left) || TypeGuard.TInteger(left) ? TypeExtendsResult.True :\n                TypeExtendsResult.False);\n    }\n    function TNumber(left, right) {\n        // prettier-ignore\n        return (IsStructuralRight(right) ? StructuralRight(left, right) :\n            TypeGuard.TObject(right) ? TObjectRight(left, right) :\n                TypeGuard.TRecord(right) ? TRecordRight(left, right) :\n                    TypeGuard.TInteger(right) || TypeGuard.TNumber(right) ? TypeExtendsResult.True :\n                        TypeExtendsResult.False);\n    }\n    // --------------------------------------------------------------------------\n    // Object\n    // --------------------------------------------------------------------------\n    function IsObjectPropertyCount(schema, count) {\n        return Object.getOwnPropertyNames(schema.properties).length === count;\n    }\n    function IsObjectStringLike(schema) {\n        return IsObjectArrayLike(schema);\n    }\n    function IsObjectSymbolLike(schema) {\n        // prettier-ignore\n        return IsObjectPropertyCount(schema, 0) || (IsObjectPropertyCount(schema, 1) && 'description' in schema.properties && TypeGuard.TUnion(schema.properties.description) && schema.properties.description.anyOf.length === 2 && ((TypeGuard.TString(schema.properties.description.anyOf[0]) &&\n            TypeGuard.TUndefined(schema.properties.description.anyOf[1])) || (TypeGuard.TString(schema.properties.description.anyOf[1]) &&\n            TypeGuard.TUndefined(schema.properties.description.anyOf[0]))));\n    }\n    function IsObjectNumberLike(schema) {\n        return IsObjectPropertyCount(schema, 0);\n    }\n    function IsObjectBooleanLike(schema) {\n        return IsObjectPropertyCount(schema, 0);\n    }\n    function IsObjectBigIntLike(schema) {\n        return IsObjectPropertyCount(schema, 0);\n    }\n    function IsObjectDateLike(schema) {\n        return IsObjectPropertyCount(schema, 0);\n    }\n    function IsObjectUint8ArrayLike(schema) {\n        return IsObjectArrayLike(schema);\n    }\n    function IsObjectFunctionLike(schema) {\n        const length = exports.Type.Number();\n        return IsObjectPropertyCount(schema, 0) || (IsObjectPropertyCount(schema, 1) && 'length' in schema.properties && IntoBooleanResult(Visit(schema.properties['length'], length)) === TypeExtendsResult.True);\n    }\n    function IsObjectConstructorLike(schema) {\n        return IsObjectPropertyCount(schema, 0);\n    }\n    function IsObjectArrayLike(schema) {\n        const length = exports.Type.Number();\n        return IsObjectPropertyCount(schema, 0) || (IsObjectPropertyCount(schema, 1) && 'length' in schema.properties && IntoBooleanResult(Visit(schema.properties['length'], length)) === TypeExtendsResult.True);\n    }\n    function IsObjectPromiseLike(schema) {\n        const then = exports.Type.Function([exports.Type.Any()], exports.Type.Any());\n        return IsObjectPropertyCount(schema, 0) || (IsObjectPropertyCount(schema, 1) && 'then' in schema.properties && IntoBooleanResult(Visit(schema.properties['then'], then)) === TypeExtendsResult.True);\n    }\n    // --------------------------------------------------------------------------\n    // Property\n    // --------------------------------------------------------------------------\n    function Property(left, right) {\n        // prettier-ignore\n        return (Visit(left, right) === TypeExtendsResult.False ? TypeExtendsResult.False :\n            TypeGuard.TOptional(left) && !TypeGuard.TOptional(right) ? TypeExtendsResult.False :\n                TypeExtendsResult.True);\n    }\n    function TObjectRight(left, right) {\n        // prettier-ignore\n        return (TypeGuard.TUnknown(left) ? TypeExtendsResult.False :\n            TypeGuard.TAny(left) ? TypeExtendsResult.Union : (TypeGuard.TNever(left) ||\n                (TypeGuard.TLiteralString(left) && IsObjectStringLike(right)) ||\n                (TypeGuard.TLiteralNumber(left) && IsObjectNumberLike(right)) ||\n                (TypeGuard.TLiteralBoolean(left) && IsObjectBooleanLike(right)) ||\n                (TypeGuard.TSymbol(left) && IsObjectSymbolLike(right)) ||\n                (TypeGuard.TBigInt(left) && IsObjectBigIntLike(right)) ||\n                (TypeGuard.TString(left) && IsObjectStringLike(right)) ||\n                (TypeGuard.TSymbol(left) && IsObjectSymbolLike(right)) ||\n                (TypeGuard.TNumber(left) && IsObjectNumberLike(right)) ||\n                (TypeGuard.TInteger(left) && IsObjectNumberLike(right)) ||\n                (TypeGuard.TBoolean(left) && IsObjectBooleanLike(right)) ||\n                (TypeGuard.TUint8Array(left) && IsObjectUint8ArrayLike(right)) ||\n                (TypeGuard.TDate(left) && IsObjectDateLike(right)) ||\n                (TypeGuard.TConstructor(left) && IsObjectConstructorLike(right)) ||\n                (TypeGuard.TFunction(left) && IsObjectFunctionLike(right))) ? TypeExtendsResult.True :\n                (TypeGuard.TRecord(left) && TypeGuard.TString(RecordKey(left))) ? (() => {\n                    // When expressing a Record with literal key values, the Record is converted into a Object with\n                    // the Hint assigned as `Record`. This is used to invert the extends logic.\n                    return right[exports.Hint] === 'Record' ? TypeExtendsResult.True : TypeExtendsResult.False;\n                })() :\n                    (TypeGuard.TRecord(left) && TypeGuard.TNumber(RecordKey(left))) ? (() => {\n                        return IsObjectPropertyCount(right, 0)\n                            ? TypeExtendsResult.True\n                            : TypeExtendsResult.False;\n                    })() :\n                        TypeExtendsResult.False);\n    }\n    function TObject(left, right) {\n        // prettier-ignore\n        return (IsStructuralRight(right) ? StructuralRight(left, right) :\n            TypeGuard.TRecord(right) ? TRecordRight(left, right) :\n                !TypeGuard.TObject(right) ? TypeExtendsResult.False :\n                    (() => {\n                        for (const key of Object.getOwnPropertyNames(right.properties)) {\n                            if (!(key in left.properties) && !TypeGuard.TOptional(right.properties[key])) {\n                                return TypeExtendsResult.False;\n                            }\n                            if (TypeGuard.TOptional(right.properties[key])) {\n                                return TypeExtendsResult.True;\n                            }\n                            if (Property(left.properties[key], right.properties[key]) === TypeExtendsResult.False) {\n                                return TypeExtendsResult.False;\n                            }\n                        }\n                        return TypeExtendsResult.True;\n                    })());\n    }\n    // --------------------------------------------------------------------------\n    // Promise\n    // --------------------------------------------------------------------------\n    function TPromise(left, right) {\n        // prettier-ignore\n        return (IsStructuralRight(right) ? StructuralRight(left, right) :\n            TypeGuard.TObject(right) && IsObjectPromiseLike(right) ? TypeExtendsResult.True :\n                !TypeGuard.TPromise(right) ? TypeExtendsResult.False :\n                    IntoBooleanResult(Visit(left.item, right.item)));\n    }\n    // --------------------------------------------------------------------------\n    // Record\n    // --------------------------------------------------------------------------\n    function RecordKey(schema) {\n        // prettier-ignore\n        return (exports.PatternNumberExact in schema.patternProperties ? exports.Type.Number() :\n            exports.PatternStringExact in schema.patternProperties ? exports.Type.String() :\n                Throw('Unknown record key pattern'));\n    }\n    function RecordValue(schema) {\n        // prettier-ignore\n        return (exports.PatternNumberExact in schema.patternProperties ? schema.patternProperties[exports.PatternNumberExact] :\n            exports.PatternStringExact in schema.patternProperties ? schema.patternProperties[exports.PatternStringExact] :\n                Throw('Unable to get record value schema'));\n    }\n    function TRecordRight(left, right) {\n        const [Key, Value] = [RecordKey(right), RecordValue(right)];\n        // prettier-ignore\n        return ((TypeGuard.TLiteralString(left) && TypeGuard.TNumber(Key) && IntoBooleanResult(Visit(left, Value)) === TypeExtendsResult.True) ? TypeExtendsResult.True :\n            TypeGuard.TUint8Array(left) && TypeGuard.TNumber(Key) ? Visit(left, Value) :\n                TypeGuard.TString(left) && TypeGuard.TNumber(Key) ? Visit(left, Value) :\n                    TypeGuard.TArray(left) && TypeGuard.TNumber(Key) ? Visit(left, Value) :\n                        TypeGuard.TObject(left) ? (() => {\n                            for (const key of Object.getOwnPropertyNames(left.properties)) {\n                                if (Property(Value, left.properties[key]) === TypeExtendsResult.False) {\n                                    return TypeExtendsResult.False;\n                                }\n                            }\n                            return TypeExtendsResult.True;\n                        })() :\n                            TypeExtendsResult.False);\n    }\n    function TRecord(left, right) {\n        // prettier-ignore\n        return (IsStructuralRight(right) ? StructuralRight(left, right) :\n            TypeGuard.TObject(right) ? TObjectRight(left, right) :\n                !TypeGuard.TRecord(right) ? TypeExtendsResult.False :\n                    Visit(RecordValue(left), RecordValue(right)));\n    }\n    // --------------------------------------------------------------------------\n    // String\n    // --------------------------------------------------------------------------\n    function TStringRight(left, right) {\n        // prettier-ignore\n        return (TypeGuard.TLiteral(left) && ValueGuard.IsString(left.const) ? TypeExtendsResult.True :\n            TypeGuard.TString(left) ? TypeExtendsResult.True :\n                TypeExtendsResult.False);\n    }\n    function TString(left, right) {\n        // prettier-ignore\n        return (IsStructuralRight(right) ? StructuralRight(left, right) :\n            TypeGuard.TObject(right) ? TObjectRight(left, right) :\n                TypeGuard.TRecord(right) ? TRecordRight(left, right) :\n                    TypeGuard.TString(right) ? TypeExtendsResult.True :\n                        TypeExtendsResult.False);\n    }\n    // --------------------------------------------------------------------------\n    // Symbol\n    // --------------------------------------------------------------------------\n    function TSymbol(left, right) {\n        // prettier-ignore\n        return (IsStructuralRight(right) ? StructuralRight(left, right) :\n            TypeGuard.TObject(right) ? TObjectRight(left, right) :\n                TypeGuard.TRecord(right) ? TRecordRight(left, right) :\n                    TypeGuard.TSymbol(right) ? TypeExtendsResult.True :\n                        TypeExtendsResult.False);\n    }\n    // --------------------------------------------------------------------------\n    // TemplateLiteral\n    // --------------------------------------------------------------------------\n    function TTemplateLiteral(left, right) {\n        // TemplateLiteral types are resolved to either unions for finite expressions or string\n        // for infinite expressions. Here we call to TemplateLiteralResolver to resolve for\n        // either type and continue evaluating.\n        // prettier-ignore\n        return (TypeGuard.TTemplateLiteral(left) ? Visit(TemplateLiteralResolver.Resolve(left), right) :\n            TypeGuard.TTemplateLiteral(right) ? Visit(left, TemplateLiteralResolver.Resolve(right)) :\n                Throw('Invalid fallthrough for TemplateLiteral'));\n    }\n    // --------------------------------------------------------------------------\n    // Tuple\n    // --------------------------------------------------------------------------\n    function IsArrayOfTuple(left, right) {\n        // prettier-ignore\n        return (TypeGuard.TArray(right) &&\n            left.items !== undefined &&\n            left.items.every((schema) => Visit(schema, right.items) === TypeExtendsResult.True));\n    }\n    function TTupleRight(left, right) {\n        // prettier-ignore\n        return (TypeGuard.TNever(left) ? TypeExtendsResult.True :\n            TypeGuard.TUnknown(left) ? TypeExtendsResult.False :\n                TypeGuard.TAny(left) ? TypeExtendsResult.Union :\n                    TypeExtendsResult.False);\n    }\n    function TTuple(left, right) {\n        // prettier-ignore\n        return (IsStructuralRight(right) ? StructuralRight(left, right) :\n            TypeGuard.TObject(right) && IsObjectArrayLike(right) ? TypeExtendsResult.True :\n                TypeGuard.TArray(right) && IsArrayOfTuple(left, right) ? TypeExtendsResult.True :\n                    !TypeGuard.TTuple(right) ? TypeExtendsResult.False :\n                        (ValueGuard.IsUndefined(left.items) && !ValueGuard.IsUndefined(right.items)) || (!ValueGuard.IsUndefined(left.items) && ValueGuard.IsUndefined(right.items)) ? TypeExtendsResult.False :\n                            (ValueGuard.IsUndefined(left.items) && !ValueGuard.IsUndefined(right.items)) ? TypeExtendsResult.True :\n                                left.items.every((schema, index) => Visit(schema, right.items[index]) === TypeExtendsResult.True) ? TypeExtendsResult.True :\n                                    TypeExtendsResult.False);\n    }\n    // --------------------------------------------------------------------------\n    // Uint8Array\n    // --------------------------------------------------------------------------\n    function TUint8Array(left, right) {\n        // prettier-ignore\n        return (IsStructuralRight(right) ? StructuralRight(left, right) :\n            TypeGuard.TObject(right) ? TObjectRight(left, right) :\n                TypeGuard.TRecord(right) ? TRecordRight(left, right) :\n                    TypeGuard.TUint8Array(right) ? TypeExtendsResult.True :\n                        TypeExtendsResult.False);\n    }\n    // --------------------------------------------------------------------------\n    // Undefined\n    // --------------------------------------------------------------------------\n    function TUndefined(left, right) {\n        // prettier-ignore\n        return (IsStructuralRight(right) ? StructuralRight(left, right) :\n            TypeGuard.TObject(right) ? TObjectRight(left, right) :\n                TypeGuard.TRecord(right) ? TRecordRight(left, right) :\n                    TypeGuard.TVoid(right) ? VoidRight(left, right) :\n                        TypeGuard.TUndefined(right) ? TypeExtendsResult.True :\n                            TypeExtendsResult.False);\n    }\n    // --------------------------------------------------------------------------\n    // Union\n    // --------------------------------------------------------------------------\n    function TUnionRight(left, right) {\n        // prettier-ignore\n        return right.anyOf.some((schema) => Visit(left, schema) === TypeExtendsResult.True)\n            ? TypeExtendsResult.True\n            : TypeExtendsResult.False;\n    }\n    function TUnion(left, right) {\n        // prettier-ignore\n        return left.anyOf.every((schema) => Visit(schema, right) === TypeExtendsResult.True)\n            ? TypeExtendsResult.True\n            : TypeExtendsResult.False;\n    }\n    // --------------------------------------------------------------------------\n    // Unknown\n    // --------------------------------------------------------------------------\n    function TUnknownRight(left, right) {\n        return TypeExtendsResult.True;\n    }\n    function TUnknown(left, right) {\n        // prettier-ignore\n        return (TypeGuard.TNever(right) ? TNeverRight(left, right) :\n            TypeGuard.TIntersect(right) ? TIntersectRight(left, right) :\n                TypeGuard.TUnion(right) ? TUnionRight(left, right) :\n                    TypeGuard.TAny(right) ? TAnyRight(left, right) :\n                        TypeGuard.TString(right) ? TStringRight(left, right) :\n                            TypeGuard.TNumber(right) ? TNumberRight(left, right) :\n                                TypeGuard.TInteger(right) ? TIntegerRight(left, right) :\n                                    TypeGuard.TBoolean(right) ? TBooleanRight(left, right) :\n                                        TypeGuard.TArray(right) ? TArrayRight(left, right) :\n                                            TypeGuard.TTuple(right) ? TTupleRight(left, right) :\n                                                TypeGuard.TObject(right) ? TObjectRight(left, right) :\n                                                    TypeGuard.TUnknown(right) ? TypeExtendsResult.True :\n                                                        TypeExtendsResult.False);\n    }\n    // --------------------------------------------------------------------------\n    // Void\n    // --------------------------------------------------------------------------\n    function VoidRight(left, right) {\n        // prettier-ignore\n        return TypeGuard.TUndefined(left) ? TypeExtendsResult.True :\n            TypeGuard.TUndefined(left) ? TypeExtendsResult.True :\n                TypeExtendsResult.False;\n    }\n    function TVoid(left, right) {\n        // prettier-ignore\n        return TypeGuard.TIntersect(right) ? TIntersectRight(left, right) :\n            TypeGuard.TUnion(right) ? TUnionRight(left, right) :\n                TypeGuard.TUnknown(right) ? TUnknownRight(left, right) :\n                    TypeGuard.TAny(right) ? TAnyRight(left, right) :\n                        TypeGuard.TObject(right) ? TObjectRight(left, right) :\n                            TypeGuard.TVoid(right) ? TypeExtendsResult.True :\n                                TypeExtendsResult.False;\n    }\n    function Visit(left, right) {\n        // prettier-ignore\n        return (\n        // resolvable\n        (TypeGuard.TTemplateLiteral(left) || TypeGuard.TTemplateLiteral(right)) ? TTemplateLiteral(left, right) :\n            (TypeGuard.TNot(left) || TypeGuard.TNot(right)) ? TNot(left, right) :\n                // standard\n                TypeGuard.TAny(left) ? TAny(left, right) :\n                    TypeGuard.TArray(left) ? TArray(left, right) :\n                        TypeGuard.TBigInt(left) ? TBigInt(left, right) :\n                            TypeGuard.TBoolean(left) ? TBoolean(left, right) :\n                                TypeGuard.TAsyncIterator(left) ? TAsyncIterator(left, right) :\n                                    TypeGuard.TConstructor(left) ? TConstructor(left, right) :\n                                        TypeGuard.TDate(left) ? TDate(left, right) :\n                                            TypeGuard.TFunction(left) ? TFunction(left, right) :\n                                                TypeGuard.TInteger(left) ? TInteger(left, right) :\n                                                    TypeGuard.TIntersect(left) ? TIntersect(left, right) :\n                                                        TypeGuard.TIterator(left) ? TIterator(left, right) :\n                                                            TypeGuard.TLiteral(left) ? TLiteral(left, right) :\n                                                                TypeGuard.TNever(left) ? TNever(left, right) :\n                                                                    TypeGuard.TNull(left) ? TNull(left, right) :\n                                                                        TypeGuard.TNumber(left) ? TNumber(left, right) :\n                                                                            TypeGuard.TObject(left) ? TObject(left, right) :\n                                                                                TypeGuard.TRecord(left) ? TRecord(left, right) :\n                                                                                    TypeGuard.TString(left) ? TString(left, right) :\n                                                                                        TypeGuard.TSymbol(left) ? TSymbol(left, right) :\n                                                                                            TypeGuard.TTuple(left) ? TTuple(left, right) :\n                                                                                                TypeGuard.TPromise(left) ? TPromise(left, right) :\n                                                                                                    TypeGuard.TUint8Array(left) ? TUint8Array(left, right) :\n                                                                                                        TypeGuard.TUndefined(left) ? TUndefined(left, right) :\n                                                                                                            TypeGuard.TUnion(left) ? TUnion(left, right) :\n                                                                                                                TypeGuard.TUnknown(left) ? TUnknown(left, right) :\n                                                                                                                    TypeGuard.TVoid(left) ? TVoid(left, right) :\n                                                                                                                        Throw(`Unknown left type operand '${left[exports.Kind]}'`));\n    }\n    function Extends(left, right) {\n        return Visit(left, right);\n    }\n    TypeExtends.Extends = Extends;\n})(TypeExtends || (exports.TypeExtends = TypeExtends = {}));\n// --------------------------------------------------------------------------\n// TypeClone\n// --------------------------------------------------------------------------\n/** Specialized Clone for Types */\nvar TypeClone;\n(function (TypeClone) {\n    function ArrayType(value) {\n        return value.map((value) => Visit(value));\n    }\n    function DateType(value) {\n        return new Date(value.getTime());\n    }\n    function Uint8ArrayType(value) {\n        return new Uint8Array(value);\n    }\n    function ObjectType(value) {\n        const clonedProperties = Object.getOwnPropertyNames(value).reduce((acc, key) => ({ ...acc, [key]: Visit(value[key]) }), {});\n        const clonedSymbols = Object.getOwnPropertySymbols(value).reduce((acc, key) => ({ ...acc, [key]: Visit(value[key]) }), {});\n        return { ...clonedProperties, ...clonedSymbols };\n    }\n    function Visit(value) {\n        // prettier-ignore\n        return (ValueGuard.IsArray(value) ? ArrayType(value) :\n            ValueGuard.IsDate(value) ? DateType(value) :\n                ValueGuard.IsUint8Array(value) ? Uint8ArrayType(value) :\n                    ValueGuard.IsObject(value) ? ObjectType(value) :\n                        value);\n    }\n    /** Clones a Rest */\n    function Rest(schemas) {\n        return schemas.map((schema) => Type(schema));\n    }\n    TypeClone.Rest = Rest;\n    /** Clones a Type */\n    function Type(schema, options = {}) {\n        return { ...Visit(schema), ...options };\n    }\n    TypeClone.Type = Type;\n})(TypeClone || (exports.TypeClone = TypeClone = {}));\n// --------------------------------------------------------------------------\n// IndexedAccessor\n// --------------------------------------------------------------------------\nvar IndexedAccessor;\n(function (IndexedAccessor) {\n    function OptionalUnwrap(schema) {\n        return schema.map((schema) => {\n            const { [exports.Optional]: _, ...clone } = TypeClone.Type(schema);\n            return clone;\n        });\n    }\n    function IsIntersectOptional(schema) {\n        return schema.every((schema) => TypeGuard.TOptional(schema));\n    }\n    function IsUnionOptional(schema) {\n        return schema.some((schema) => TypeGuard.TOptional(schema));\n    }\n    function ResolveIntersect(schema) {\n        return IsIntersectOptional(schema.allOf) ? exports.Type.Optional(exports.Type.Intersect(OptionalUnwrap(schema.allOf))) : schema;\n    }\n    function ResolveUnion(schema) {\n        return IsUnionOptional(schema.anyOf) ? exports.Type.Optional(exports.Type.Union(OptionalUnwrap(schema.anyOf))) : schema;\n    }\n    function ResolveOptional(schema) {\n        // prettier-ignore\n        return schema[exports.Kind] === 'Intersect' ? ResolveIntersect(schema) :\n            schema[exports.Kind] === 'Union' ? ResolveUnion(schema) :\n                schema;\n    }\n    function TIntersect(schema, key) {\n        const resolved = schema.allOf.reduce((acc, schema) => {\n            const indexed = Visit(schema, key);\n            return indexed[exports.Kind] === 'Never' ? acc : [...acc, indexed];\n        }, []);\n        return ResolveOptional(exports.Type.Intersect(resolved));\n    }\n    function TUnion(schema, key) {\n        const resolved = schema.anyOf.map((schema) => Visit(schema, key));\n        return ResolveOptional(exports.Type.Union(resolved));\n    }\n    function TObject(schema, key) {\n        const property = schema.properties[key];\n        return ValueGuard.IsUndefined(property) ? exports.Type.Never() : exports.Type.Union([property]);\n    }\n    function TTuple(schema, key) {\n        const items = schema.items;\n        if (ValueGuard.IsUndefined(items))\n            return exports.Type.Never();\n        const element = items[key]; //\n        if (ValueGuard.IsUndefined(element))\n            return exports.Type.Never();\n        return element;\n    }\n    function Visit(schema, key) {\n        // prettier-ignore\n        return schema[exports.Kind] === 'Intersect' ? TIntersect(schema, key) :\n            schema[exports.Kind] === 'Union' ? TUnion(schema, key) :\n                schema[exports.Kind] === 'Object' ? TObject(schema, key) :\n                    schema[exports.Kind] === 'Tuple' ? TTuple(schema, key) :\n                        exports.Type.Never();\n    }\n    function Resolve(schema, keys, options = {}) {\n        const resolved = keys.map((key) => Visit(schema, key.toString()));\n        return ResolveOptional(exports.Type.Union(resolved, options));\n    }\n    IndexedAccessor.Resolve = Resolve;\n})(IndexedAccessor || (exports.IndexedAccessor = IndexedAccessor = {}));\n// --------------------------------------------------------------------------\n// Intrinsic\n// --------------------------------------------------------------------------\nvar Intrinsic;\n(function (Intrinsic) {\n    function Uncapitalize(value) {\n        const [first, rest] = [value.slice(0, 1), value.slice(1)];\n        return `${first.toLowerCase()}${rest}`;\n    }\n    function Capitalize(value) {\n        const [first, rest] = [value.slice(0, 1), value.slice(1)];\n        return `${first.toUpperCase()}${rest}`;\n    }\n    function Uppercase(value) {\n        return value.toUpperCase();\n    }\n    function Lowercase(value) {\n        return value.toLowerCase();\n    }\n    function IntrinsicTemplateLiteral(schema, mode) {\n        // note: template literals require special runtime handling as they are encoded in string patterns.\n        // This diverges from the mapped type which would otherwise map on the template literal kind.\n        const expression = TemplateLiteralParser.ParseExact(schema.pattern);\n        const finite = TemplateLiteralFinite.Check(expression);\n        if (!finite)\n            return { ...schema, pattern: IntrinsicLiteral(schema.pattern, mode) };\n        const strings = [...TemplateLiteralGenerator.Generate(expression)];\n        const literals = strings.map((value) => exports.Type.Literal(value));\n        const mapped = IntrinsicRest(literals, mode);\n        const union = exports.Type.Union(mapped);\n        return exports.Type.TemplateLiteral([union]);\n    }\n    function IntrinsicLiteral(value, mode) {\n        // prettier-ignore\n        return typeof value === 'string' ? (mode === 'Uncapitalize' ? Uncapitalize(value) :\n            mode === 'Capitalize' ? Capitalize(value) :\n                mode === 'Uppercase' ? Uppercase(value) :\n                    mode === 'Lowercase' ? Lowercase(value) :\n                        value) : value.toString();\n    }\n    function IntrinsicRest(schema, mode) {\n        if (schema.length === 0)\n            return [];\n        const [L, ...R] = schema;\n        return [Map(L, mode), ...IntrinsicRest(R, mode)];\n    }\n    function Visit(schema, mode) {\n        // prettier-ignore\n        return TypeGuard.TTemplateLiteral(schema) ? IntrinsicTemplateLiteral(schema, mode) :\n            TypeGuard.TUnion(schema) ? exports.Type.Union(IntrinsicRest(schema.anyOf, mode)) :\n                TypeGuard.TLiteral(schema) ? exports.Type.Literal(IntrinsicLiteral(schema.const, mode)) :\n                    schema;\n    }\n    /** Applies an intrinsic string manipulation to the given type. */\n    function Map(schema, mode) {\n        return Visit(schema, mode);\n    }\n    Intrinsic.Map = Map;\n})(Intrinsic || (exports.Intrinsic = Intrinsic = {}));\n// --------------------------------------------------------------------------\n// ObjectMap\n// --------------------------------------------------------------------------\nvar ObjectMap;\n(function (ObjectMap) {\n    function TIntersect(schema, callback) {\n        // prettier-ignore\n        return exports.Type.Intersect(schema.allOf.map((inner) => Visit(inner, callback)), { ...schema });\n    }\n    function TUnion(schema, callback) {\n        // prettier-ignore\n        return exports.Type.Union(schema.anyOf.map((inner) => Visit(inner, callback)), { ...schema });\n    }\n    function TObject(schema, callback) {\n        return callback(schema);\n    }\n    function Visit(schema, callback) {\n        // There are cases where users need to map objects with unregistered kinds. Using a TypeGuard here would\n        // prevent sub schema mapping as unregistered kinds will not pass TSchema checks. This is notable in the\n        // case of TObject where unregistered property kinds cause the TObject check to fail. As mapping is only\n        // used for composition, we use explicit checks instead.\n        // prettier-ignore\n        return (schema[exports.Kind] === 'Intersect' ? TIntersect(schema, callback) :\n            schema[exports.Kind] === 'Union' ? TUnion(schema, callback) :\n                schema[exports.Kind] === 'Object' ? TObject(schema, callback) :\n                    schema);\n    }\n    function Map(schema, callback, options) {\n        return { ...Visit(TypeClone.Type(schema), callback), ...options };\n    }\n    ObjectMap.Map = Map;\n})(ObjectMap || (exports.ObjectMap = ObjectMap = {}));\nvar KeyResolver;\n(function (KeyResolver) {\n    function UnwrapPattern(key) {\n        return key[0] === '^' && key[key.length - 1] === '$' ? key.slice(1, key.length - 1) : key;\n    }\n    function TIntersect(schema, options) {\n        return schema.allOf.reduce((acc, schema) => [...acc, ...Visit(schema, options)], []);\n    }\n    function TUnion(schema, options) {\n        const sets = schema.anyOf.map((inner) => Visit(inner, options));\n        return [...sets.reduce((set, outer) => outer.map((key) => (sets.every((inner) => inner.includes(key)) ? set.add(key) : set))[0], new Set())];\n    }\n    function TObject(schema, options) {\n        return Object.getOwnPropertyNames(schema.properties);\n    }\n    function TRecord(schema, options) {\n        return options.includePatterns ? Object.getOwnPropertyNames(schema.patternProperties) : [];\n    }\n    function Visit(schema, options) {\n        // prettier-ignore\n        return (TypeGuard.TIntersect(schema) ? TIntersect(schema, options) :\n            TypeGuard.TUnion(schema) ? TUnion(schema, options) :\n                TypeGuard.TObject(schema) ? TObject(schema, options) :\n                    TypeGuard.TRecord(schema) ? TRecord(schema, options) :\n                        []);\n    }\n    /** Resolves an array of keys in this schema */\n    function ResolveKeys(schema, options) {\n        return [...new Set(Visit(schema, options))];\n    }\n    KeyResolver.ResolveKeys = ResolveKeys;\n    /** Resolves a regular expression pattern matching all keys in this schema */\n    function ResolvePattern(schema) {\n        const keys = ResolveKeys(schema, { includePatterns: true });\n        const pattern = keys.map((key) => `(${UnwrapPattern(key)})`);\n        return `^(${pattern.join('|')})$`;\n    }\n    KeyResolver.ResolvePattern = ResolvePattern;\n})(KeyResolver || (exports.KeyResolver = KeyResolver = {}));\n// --------------------------------------------------------------------------\n// KeyArrayResolver\n// --------------------------------------------------------------------------\nclass KeyArrayResolverError extends TypeBoxError {\n}\nexports.KeyArrayResolverError = KeyArrayResolverError;\nvar KeyArrayResolver;\n(function (KeyArrayResolver) {\n    /** Resolves an array of string[] keys from the given schema or array type. */\n    function Resolve(schema) {\n        // prettier-ignore\n        return Array.isArray(schema) ? schema :\n            TypeGuard.TUnionLiteral(schema) ? schema.anyOf.map((schema) => schema.const.toString()) :\n                TypeGuard.TLiteral(schema) ? [schema.const] :\n                    TypeGuard.TTemplateLiteral(schema) ? (() => {\n                        const expression = TemplateLiteralParser.ParseExact(schema.pattern);\n                        if (!TemplateLiteralFinite.Check(expression))\n                            throw new KeyArrayResolverError('Cannot resolve keys from infinite template expression');\n                        return [...TemplateLiteralGenerator.Generate(expression)];\n                    })() : [];\n    }\n    KeyArrayResolver.Resolve = Resolve;\n})(KeyArrayResolver || (exports.KeyArrayResolver = KeyArrayResolver = {}));\n// --------------------------------------------------------------------------\n// UnionResolver\n// --------------------------------------------------------------------------\nvar UnionResolver;\n(function (UnionResolver) {\n    function* TUnion(union) {\n        for (const schema of union.anyOf) {\n            if (schema[exports.Kind] === 'Union') {\n                yield* TUnion(schema);\n            }\n            else {\n                yield schema;\n            }\n        }\n    }\n    /** Returns a resolved union with interior unions flattened */\n    function Resolve(union) {\n        return exports.Type.Union([...TUnion(union)], { ...union });\n    }\n    UnionResolver.Resolve = Resolve;\n})(UnionResolver || (exports.UnionResolver = UnionResolver = {}));\n// --------------------------------------------------------------------------\n// TemplateLiteralPattern\n// --------------------------------------------------------------------------\nclass TemplateLiteralPatternError extends TypeBoxError {\n}\nexports.TemplateLiteralPatternError = TemplateLiteralPatternError;\nvar TemplateLiteralPattern;\n(function (TemplateLiteralPattern) {\n    function Throw(message) {\n        throw new TemplateLiteralPatternError(message);\n    }\n    function Escape(value) {\n        return value.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&');\n    }\n    function Visit(schema, acc) {\n        // prettier-ignore\n        return (TypeGuard.TTemplateLiteral(schema) ? schema.pattern.slice(1, schema.pattern.length - 1) :\n            TypeGuard.TUnion(schema) ? `(${schema.anyOf.map((schema) => Visit(schema, acc)).join('|')})` :\n                TypeGuard.TNumber(schema) ? `${acc}${exports.PatternNumber}` :\n                    TypeGuard.TInteger(schema) ? `${acc}${exports.PatternNumber}` :\n                        TypeGuard.TBigInt(schema) ? `${acc}${exports.PatternNumber}` :\n                            TypeGuard.TString(schema) ? `${acc}${exports.PatternString}` :\n                                TypeGuard.TLiteral(schema) ? `${acc}${Escape(schema.const.toString())}` :\n                                    TypeGuard.TBoolean(schema) ? `${acc}${exports.PatternBoolean}` :\n                                        Throw(`Unexpected Kind '${schema[exports.Kind]}'`));\n    }\n    function Create(kinds) {\n        return `^${kinds.map((schema) => Visit(schema, '')).join('')}\\$`;\n    }\n    TemplateLiteralPattern.Create = Create;\n})(TemplateLiteralPattern || (exports.TemplateLiteralPattern = TemplateLiteralPattern = {}));\n// --------------------------------------------------------------------------------------\n// TemplateLiteralResolver\n// --------------------------------------------------------------------------------------\nvar TemplateLiteralResolver;\n(function (TemplateLiteralResolver) {\n    /** Resolves a template literal as a TUnion */\n    function Resolve(template) {\n        const expression = TemplateLiteralParser.ParseExact(template.pattern);\n        if (!TemplateLiteralFinite.Check(expression))\n            return exports.Type.String();\n        const literals = [...TemplateLiteralGenerator.Generate(expression)].map((value) => exports.Type.Literal(value));\n        return exports.Type.Union(literals);\n    }\n    TemplateLiteralResolver.Resolve = Resolve;\n})(TemplateLiteralResolver || (exports.TemplateLiteralResolver = TemplateLiteralResolver = {}));\n// --------------------------------------------------------------------------------------\n// TemplateLiteralParser\n// --------------------------------------------------------------------------------------\nclass TemplateLiteralParserError extends TypeBoxError {\n}\nexports.TemplateLiteralParserError = TemplateLiteralParserError;\nvar TemplateLiteralParser;\n(function (TemplateLiteralParser) {\n    function IsNonEscaped(pattern, index, char) {\n        return pattern[index] === char && pattern.charCodeAt(index - 1) !== 92;\n    }\n    function IsOpenParen(pattern, index) {\n        return IsNonEscaped(pattern, index, '(');\n    }\n    function IsCloseParen(pattern, index) {\n        return IsNonEscaped(pattern, index, ')');\n    }\n    function IsSeparator(pattern, index) {\n        return IsNonEscaped(pattern, index, '|');\n    }\n    function IsGroup(pattern) {\n        if (!(IsOpenParen(pattern, 0) && IsCloseParen(pattern, pattern.length - 1)))\n            return false;\n        let count = 0;\n        for (let index = 0; index < pattern.length; index++) {\n            if (IsOpenParen(pattern, index))\n                count += 1;\n            if (IsCloseParen(pattern, index))\n                count -= 1;\n            if (count === 0 && index !== pattern.length - 1)\n                return false;\n        }\n        return true;\n    }\n    function InGroup(pattern) {\n        return pattern.slice(1, pattern.length - 1);\n    }\n    function IsPrecedenceOr(pattern) {\n        let count = 0;\n        for (let index = 0; index < pattern.length; index++) {\n            if (IsOpenParen(pattern, index))\n                count += 1;\n            if (IsCloseParen(pattern, index))\n                count -= 1;\n            if (IsSeparator(pattern, index) && count === 0)\n                return true;\n        }\n        return false;\n    }\n    function IsPrecedenceAnd(pattern) {\n        for (let index = 0; index < pattern.length; index++) {\n            if (IsOpenParen(pattern, index))\n                return true;\n        }\n        return false;\n    }\n    function Or(pattern) {\n        let [count, start] = [0, 0];\n        const expressions = [];\n        for (let index = 0; index < pattern.length; index++) {\n            if (IsOpenParen(pattern, index))\n                count += 1;\n            if (IsCloseParen(pattern, index))\n                count -= 1;\n            if (IsSeparator(pattern, index) && count === 0) {\n                const range = pattern.slice(start, index);\n                if (range.length > 0)\n                    expressions.push(Parse(range));\n                start = index + 1;\n            }\n        }\n        const range = pattern.slice(start);\n        if (range.length > 0)\n            expressions.push(Parse(range));\n        if (expressions.length === 0)\n            return { type: 'const', const: '' };\n        if (expressions.length === 1)\n            return expressions[0];\n        return { type: 'or', expr: expressions };\n    }\n    function And(pattern) {\n        function Group(value, index) {\n            if (!IsOpenParen(value, index))\n                throw new TemplateLiteralParserError(`TemplateLiteralParser: Index must point to open parens`);\n            let count = 0;\n            for (let scan = index; scan < value.length; scan++) {\n                if (IsOpenParen(value, scan))\n                    count += 1;\n                if (IsCloseParen(value, scan))\n                    count -= 1;\n                if (count === 0)\n                    return [index, scan];\n            }\n            throw new TemplateLiteralParserError(`TemplateLiteralParser: Unclosed group parens in expression`);\n        }\n        function Range(pattern, index) {\n            for (let scan = index; scan < pattern.length; scan++) {\n                if (IsOpenParen(pattern, scan))\n                    return [index, scan];\n            }\n            return [index, pattern.length];\n        }\n        const expressions = [];\n        for (let index = 0; index < pattern.length; index++) {\n            if (IsOpenParen(pattern, index)) {\n                const [start, end] = Group(pattern, index);\n                const range = pattern.slice(start, end + 1);\n                expressions.push(Parse(range));\n                index = end;\n            }\n            else {\n                const [start, end] = Range(pattern, index);\n                const range = pattern.slice(start, end);\n                if (range.length > 0)\n                    expressions.push(Parse(range));\n                index = end - 1;\n            }\n        }\n        // prettier-ignore\n        return (expressions.length === 0) ? { type: 'const', const: '' } :\n            (expressions.length === 1) ? expressions[0] :\n                { type: 'and', expr: expressions };\n    }\n    /** Parses a pattern and returns an expression tree */\n    function Parse(pattern) {\n        // prettier-ignore\n        return IsGroup(pattern) ? Parse(InGroup(pattern)) :\n            IsPrecedenceOr(pattern) ? Or(pattern) :\n                IsPrecedenceAnd(pattern) ? And(pattern) :\n                    { type: 'const', const: pattern };\n    }\n    TemplateLiteralParser.Parse = Parse;\n    /** Parses a pattern and strips forward and trailing ^ and $ */\n    function ParseExact(pattern) {\n        return Parse(pattern.slice(1, pattern.length - 1));\n    }\n    TemplateLiteralParser.ParseExact = ParseExact;\n})(TemplateLiteralParser || (exports.TemplateLiteralParser = TemplateLiteralParser = {}));\n// --------------------------------------------------------------------------------------\n// TemplateLiteralFinite\n// --------------------------------------------------------------------------------------\nclass TemplateLiteralFiniteError extends TypeBoxError {\n}\nexports.TemplateLiteralFiniteError = TemplateLiteralFiniteError;\nvar TemplateLiteralFinite;\n(function (TemplateLiteralFinite) {\n    function Throw(message) {\n        throw new TemplateLiteralFiniteError(message);\n    }\n    function IsNumber(expression) {\n        // prettier-ignore\n        return (expression.type === 'or' &&\n            expression.expr.length === 2 &&\n            expression.expr[0].type === 'const' &&\n            expression.expr[0].const === '0' &&\n            expression.expr[1].type === 'const' &&\n            expression.expr[1].const === '[1-9][0-9]*');\n    }\n    function IsBoolean(expression) {\n        // prettier-ignore\n        return (expression.type === 'or' &&\n            expression.expr.length === 2 &&\n            expression.expr[0].type === 'const' &&\n            expression.expr[0].const === 'true' &&\n            expression.expr[1].type === 'const' &&\n            expression.expr[1].const === 'false');\n    }\n    function IsString(expression) {\n        return expression.type === 'const' && expression.const === '.*';\n    }\n    function Check(expression) {\n        // prettier-ignore\n        return IsBoolean(expression) ? true :\n            IsNumber(expression) || IsString(expression) ? false :\n                (expression.type === 'and') ? expression.expr.every((expr) => Check(expr)) :\n                    (expression.type === 'or') ? expression.expr.every((expr) => Check(expr)) :\n                        (expression.type === 'const') ? true :\n                            Throw(`Unknown expression type`);\n    }\n    TemplateLiteralFinite.Check = Check;\n})(TemplateLiteralFinite || (exports.TemplateLiteralFinite = TemplateLiteralFinite = {}));\n// --------------------------------------------------------------------------------------\n// TemplateLiteralGenerator\n// --------------------------------------------------------------------------------------\nclass TemplateLiteralGeneratorError extends TypeBoxError {\n}\nexports.TemplateLiteralGeneratorError = TemplateLiteralGeneratorError;\nvar TemplateLiteralGenerator;\n(function (TemplateLiteralGenerator) {\n    function* Reduce(buffer) {\n        if (buffer.length === 1)\n            return yield* buffer[0];\n        for (const left of buffer[0]) {\n            for (const right of Reduce(buffer.slice(1))) {\n                yield `${left}${right}`;\n            }\n        }\n    }\n    function* And(expression) {\n        return yield* Reduce(expression.expr.map((expr) => [...Generate(expr)]));\n    }\n    function* Or(expression) {\n        for (const expr of expression.expr)\n            yield* Generate(expr);\n    }\n    function* Const(expression) {\n        return yield expression.const;\n    }\n    function* Generate(expression) {\n        // prettier-ignore\n        return (expression.type === 'and' ? yield* And(expression) :\n            expression.type === 'or' ? yield* Or(expression) :\n                expression.type === 'const' ? yield* Const(expression) :\n                    (() => { throw new TemplateLiteralGeneratorError('Unknown expression'); })());\n    }\n    TemplateLiteralGenerator.Generate = Generate;\n})(TemplateLiteralGenerator || (exports.TemplateLiteralGenerator = TemplateLiteralGenerator = {}));\n// ---------------------------------------------------------------------\n// TemplateLiteralDslParser\n// ---------------------------------------------------------------------\nvar TemplateLiteralDslParser;\n(function (TemplateLiteralDslParser) {\n    function* ParseUnion(template) {\n        const trim = template.trim().replace(/\"|'/g, '');\n        // prettier-ignore\n        return (trim === 'boolean' ? yield exports.Type.Boolean() :\n            trim === 'number' ? yield exports.Type.Number() :\n                trim === 'bigint' ? yield exports.Type.BigInt() :\n                    trim === 'string' ? yield exports.Type.String() :\n                        yield (() => {\n                            const literals = trim.split('|').map((literal) => exports.Type.Literal(literal.trim()));\n                            return (literals.length === 0 ? exports.Type.Never() :\n                                literals.length === 1 ? literals[0] :\n                                    exports.Type.Union(literals));\n                        })());\n    }\n    function* ParseTerminal(template) {\n        if (template[1] !== '{') {\n            const L = exports.Type.Literal('$');\n            const R = ParseLiteral(template.slice(1));\n            return yield* [L, ...R];\n        }\n        for (let i = 2; i < template.length; i++) {\n            if (template[i] === '}') {\n                const L = ParseUnion(template.slice(2, i));\n                const R = ParseLiteral(template.slice(i + 1));\n                return yield* [...L, ...R];\n            }\n        }\n        yield exports.Type.Literal(template);\n    }\n    function* ParseLiteral(template) {\n        for (let i = 0; i < template.length; i++) {\n            if (template[i] === '$') {\n                const L = exports.Type.Literal(template.slice(0, i));\n                const R = ParseTerminal(template.slice(i));\n                return yield* [L, ...R];\n            }\n        }\n        yield exports.Type.Literal(template);\n    }\n    function Parse(template_dsl) {\n        return [...ParseLiteral(template_dsl)];\n    }\n    TemplateLiteralDslParser.Parse = Parse;\n})(TemplateLiteralDslParser || (exports.TemplateLiteralDslParser = TemplateLiteralDslParser = {}));\n// ---------------------------------------------------------------------\n// TransformBuilder\n// ---------------------------------------------------------------------\nclass TransformDecodeBuilder {\n    constructor(schema) {\n        this.schema = schema;\n    }\n    Decode(decode) {\n        return new TransformEncodeBuilder(this.schema, decode);\n    }\n}\nexports.TransformDecodeBuilder = TransformDecodeBuilder;\nclass TransformEncodeBuilder {\n    constructor(schema, decode) {\n        this.schema = schema;\n        this.decode = decode;\n    }\n    Encode(encode) {\n        const schema = TypeClone.Type(this.schema);\n        // prettier-ignore\n        return (TypeGuard.TTransform(schema) ? (() => {\n            const Encode = (value) => schema[exports.Transform].Encode(encode(value));\n            const Decode = (value) => this.decode(schema[exports.Transform].Decode(value));\n            const Codec = { Encode: Encode, Decode: Decode };\n            return { ...schema, [exports.Transform]: Codec };\n        })() : (() => {\n            const Codec = { Decode: this.decode, Encode: encode };\n            return { ...schema, [exports.Transform]: Codec };\n        })());\n    }\n}\nexports.TransformEncodeBuilder = TransformEncodeBuilder;\n// --------------------------------------------------------------------------\n// TypeOrdinal: Used for auto $id generation\n// --------------------------------------------------------------------------\nlet TypeOrdinal = 0;\n// --------------------------------------------------------------------------\n// TypeBuilder\n// --------------------------------------------------------------------------\nclass TypeBuilderError extends TypeBoxError {\n}\nexports.TypeBuilderError = TypeBuilderError;\nclass TypeBuilder {\n    /** `[Internal]` Creates a schema without `static` and `params` types */\n    Create(schema) {\n        return schema;\n    }\n    /** `[Internal]` Throws a TypeBuilder error with the given message */\n    Throw(message) {\n        throw new TypeBuilderError(message);\n    }\n    /** `[Internal]` Discards property keys from the given record type */\n    Discard(record, keys) {\n        return keys.reduce((acc, key) => {\n            const { [key]: _, ...rest } = acc;\n            return rest;\n        }, record);\n    }\n    /** `[Json]` Omits compositing symbols from this schema */\n    Strict(schema) {\n        return JSON.parse(JSON.stringify(schema));\n    }\n}\nexports.TypeBuilder = TypeBuilder;\n// --------------------------------------------------------------------------\n// JsonTypeBuilder\n// --------------------------------------------------------------------------\nclass JsonTypeBuilder extends TypeBuilder {\n    // ------------------------------------------------------------------------\n    // Modifiers\n    // ------------------------------------------------------------------------\n    /** `[Json]` Creates a Readonly and Optional property */\n    ReadonlyOptional(schema) {\n        return this.Readonly(this.Optional(schema));\n    }\n    /** `[Json]` Creates a Readonly property */\n    Readonly(schema) {\n        return { ...TypeClone.Type(schema), [exports.Readonly]: 'Readonly' };\n    }\n    /** `[Json]` Creates an Optional property */\n    Optional(schema) {\n        return { ...TypeClone.Type(schema), [exports.Optional]: 'Optional' };\n    }\n    // ------------------------------------------------------------------------\n    // Types\n    // ------------------------------------------------------------------------\n    /** `[Json]` Creates an Any type */\n    Any(options = {}) {\n        return this.Create({ ...options, [exports.Kind]: 'Any' });\n    }\n    /** `[Json]` Creates an Array type */\n    Array(schema, options = {}) {\n        return this.Create({ ...options, [exports.Kind]: 'Array', type: 'array', items: TypeClone.Type(schema) });\n    }\n    /** `[Json]` Creates a Boolean type */\n    Boolean(options = {}) {\n        return this.Create({ ...options, [exports.Kind]: 'Boolean', type: 'boolean' });\n    }\n    /** `[Json]` Intrinsic function to Capitalize LiteralString types */\n    Capitalize(schema, options = {}) {\n        return { ...Intrinsic.Map(TypeClone.Type(schema), 'Capitalize'), ...options };\n    }\n    /** `[Json]` Creates a Composite object type */\n    Composite(objects, options) {\n        const intersect = exports.Type.Intersect(objects, {});\n        const keys = KeyResolver.ResolveKeys(intersect, { includePatterns: false });\n        const properties = keys.reduce((acc, key) => ({ ...acc, [key]: exports.Type.Index(intersect, [key]) }), {});\n        return exports.Type.Object(properties, options);\n    }\n    /** `[Json]` Creates a Enum type */\n    Enum(item, options = {}) {\n        if (ValueGuard.IsUndefined(item))\n            return this.Throw('Enum undefined or empty');\n        // prettier-ignore\n        const values1 = Object.getOwnPropertyNames(item).filter((key) => isNaN(key)).map((key) => item[key]);\n        const values2 = [...new Set(values1)];\n        const anyOf = values2.map((value) => exports.Type.Literal(value));\n        return this.Union(anyOf, { ...options, [exports.Hint]: 'Enum' });\n    }\n    /** `[Json]` Creates a Conditional type */\n    Extends(left, right, trueType, falseType, options = {}) {\n        switch (TypeExtends.Extends(left, right)) {\n            case TypeExtendsResult.Union:\n                return this.Union([TypeClone.Type(trueType, options), TypeClone.Type(falseType, options)]);\n            case TypeExtendsResult.True:\n                return TypeClone.Type(trueType, options);\n            case TypeExtendsResult.False:\n                return TypeClone.Type(falseType, options);\n        }\n    }\n    /** `[Json]` Constructs a type by excluding from unionType all union members that are assignable to excludedMembers */\n    Exclude(unionType, excludedMembers, options = {}) {\n        // prettier-ignore\n        return (TypeGuard.TTemplateLiteral(unionType) ? this.Exclude(TemplateLiteralResolver.Resolve(unionType), excludedMembers, options) :\n            TypeGuard.TTemplateLiteral(excludedMembers) ? this.Exclude(unionType, TemplateLiteralResolver.Resolve(excludedMembers), options) :\n                TypeGuard.TUnion(unionType) ? (() => {\n                    const narrowed = unionType.anyOf.filter((inner) => TypeExtends.Extends(inner, excludedMembers) === TypeExtendsResult.False);\n                    return (narrowed.length === 1 ? TypeClone.Type(narrowed[0], options) : this.Union(narrowed, options));\n                })() :\n                    TypeExtends.Extends(unionType, excludedMembers) !== TypeExtendsResult.False ? this.Never(options) :\n                        TypeClone.Type(unionType, options));\n    }\n    /** `[Json]` Constructs a type by extracting from type all union members that are assignable to union */\n    Extract(type, union, options = {}) {\n        // prettier-ignore\n        return (TypeGuard.TTemplateLiteral(type) ? this.Extract(TemplateLiteralResolver.Resolve(type), union, options) :\n            TypeGuard.TTemplateLiteral(union) ? this.Extract(type, TemplateLiteralResolver.Resolve(union), options) :\n                TypeGuard.TUnion(type) ? (() => {\n                    const narrowed = type.anyOf.filter((inner) => TypeExtends.Extends(inner, union) !== TypeExtendsResult.False);\n                    return (narrowed.length === 1 ? TypeClone.Type(narrowed[0], options) : this.Union(narrowed, options));\n                })() :\n                    TypeExtends.Extends(type, union) !== TypeExtendsResult.False ? TypeClone.Type(type, options) :\n                        this.Never(options));\n    }\n    /** `[Json]` Returns an Indexed property type for the given keys */\n    Index(schema, unresolved, options = {}) {\n        // prettier-ignore\n        return (TypeGuard.TArray(schema) && TypeGuard.TNumber(unresolved) ? (() => {\n            return TypeClone.Type(schema.items, options);\n        })() :\n            TypeGuard.TTuple(schema) && TypeGuard.TNumber(unresolved) ? (() => {\n                const items = ValueGuard.IsUndefined(schema.items) ? [] : schema.items;\n                const cloned = items.map((schema) => TypeClone.Type(schema));\n                return this.Union(cloned, options);\n            })() : (() => {\n                const keys = KeyArrayResolver.Resolve(unresolved);\n                const clone = TypeClone.Type(schema);\n                return IndexedAccessor.Resolve(clone, keys, options);\n            })());\n    }\n    /** `[Json]` Creates an Integer type */\n    Integer(options = {}) {\n        return this.Create({ ...options, [exports.Kind]: 'Integer', type: 'integer' });\n    }\n    /** `[Json]` Creates an Intersect type */\n    Intersect(allOf, options = {}) {\n        if (allOf.length === 0)\n            return exports.Type.Never();\n        if (allOf.length === 1)\n            return TypeClone.Type(allOf[0], options);\n        if (allOf.some((schema) => TypeGuard.TTransform(schema)))\n            this.Throw('Cannot intersect transform types');\n        const objects = allOf.every((schema) => TypeGuard.TObject(schema));\n        const cloned = TypeClone.Rest(allOf);\n        // prettier-ignore\n        const clonedUnevaluatedProperties = TypeGuard.TSchema(options.unevaluatedProperties)\n            ? { unevaluatedProperties: TypeClone.Type(options.unevaluatedProperties) }\n            : {};\n        return options.unevaluatedProperties === false || TypeGuard.TSchema(options.unevaluatedProperties) || objects\n            ? this.Create({ ...options, ...clonedUnevaluatedProperties, [exports.Kind]: 'Intersect', type: 'object', allOf: cloned })\n            : this.Create({ ...options, ...clonedUnevaluatedProperties, [exports.Kind]: 'Intersect', allOf: cloned });\n    }\n    /** `[Json]` Creates a KeyOf type */\n    KeyOf(schema, options = {}) {\n        // prettier-ignore\n        return (TypeGuard.TRecord(schema) ? (() => {\n            const pattern = Object.getOwnPropertyNames(schema.patternProperties)[0];\n            return (pattern === exports.PatternNumberExact ? this.Number(options) :\n                pattern === exports.PatternStringExact ? this.String(options) :\n                    this.Throw('Unable to resolve key type from Record key pattern'));\n        })() :\n            TypeGuard.TTuple(schema) ? (() => {\n                const items = ValueGuard.IsUndefined(schema.items) ? [] : schema.items;\n                const literals = items.map((_, index) => exports.Type.Literal(index.toString()));\n                return this.Union(literals, options);\n            })() :\n                TypeGuard.TArray(schema) ? (() => {\n                    return this.Number(options);\n                })() : (() => {\n                    const keys = KeyResolver.ResolveKeys(schema, { includePatterns: false });\n                    if (keys.length === 0)\n                        return this.Never(options);\n                    const literals = keys.map((key) => this.Literal(key));\n                    return this.Union(literals, options);\n                })());\n    }\n    /** `[Json]` Creates a Literal type */\n    Literal(value, options = {}) {\n        return this.Create({ ...options, [exports.Kind]: 'Literal', const: value, type: typeof value });\n    }\n    /** `[Json]` Intrinsic function to Lowercase LiteralString types */\n    Lowercase(schema, options = {}) {\n        return { ...Intrinsic.Map(TypeClone.Type(schema), 'Lowercase'), ...options };\n    }\n    /** `[Json]` Creates a Never type */\n    Never(options = {}) {\n        return this.Create({ ...options, [exports.Kind]: 'Never', not: {} });\n    }\n    /** `[Json]` Creates a Not type */\n    Not(schema, options) {\n        return this.Create({ ...options, [exports.Kind]: 'Not', not: TypeClone.Type(schema) });\n    }\n    /** `[Json]` Creates a Null type */\n    Null(options = {}) {\n        return this.Create({ ...options, [exports.Kind]: 'Null', type: 'null' });\n    }\n    /** `[Json]` Creates a Number type */\n    Number(options = {}) {\n        return this.Create({ ...options, [exports.Kind]: 'Number', type: 'number' });\n    }\n    /** `[Json]` Creates an Object type */\n    Object(properties, options = {}) {\n        const propertyKeys = Object.getOwnPropertyNames(properties);\n        const optionalKeys = propertyKeys.filter((key) => TypeGuard.TOptional(properties[key]));\n        const requiredKeys = propertyKeys.filter((name) => !optionalKeys.includes(name));\n        const clonedAdditionalProperties = TypeGuard.TSchema(options.additionalProperties) ? { additionalProperties: TypeClone.Type(options.additionalProperties) } : {};\n        const clonedProperties = propertyKeys.reduce((acc, key) => ({ ...acc, [key]: TypeClone.Type(properties[key]) }), {});\n        return requiredKeys.length > 0\n            ? this.Create({ ...options, ...clonedAdditionalProperties, [exports.Kind]: 'Object', type: 'object', properties: clonedProperties, required: requiredKeys })\n            : this.Create({ ...options, ...clonedAdditionalProperties, [exports.Kind]: 'Object', type: 'object', properties: clonedProperties });\n    }\n    /** `[Json]` Constructs a type whose keys are omitted from the given type */\n    Omit(schema, unresolved, options = {}) {\n        const keys = KeyArrayResolver.Resolve(unresolved);\n        // prettier-ignore\n        return ObjectMap.Map(this.Discard(TypeClone.Type(schema), ['$id', exports.Transform]), (object) => {\n            if (ValueGuard.IsArray(object.required)) {\n                object.required = object.required.filter((key) => !keys.includes(key));\n                if (object.required.length === 0)\n                    delete object.required;\n            }\n            for (const key of Object.getOwnPropertyNames(object.properties)) {\n                if (keys.includes(key))\n                    delete object.properties[key];\n            }\n            return this.Create(object);\n        }, options);\n    }\n    /** `[Json]` Constructs a type where all properties are optional */\n    Partial(schema, options = {}) {\n        // prettier-ignore\n        return ObjectMap.Map(this.Discard(TypeClone.Type(schema), ['$id', exports.Transform]), (object) => {\n            const properties = Object.getOwnPropertyNames(object.properties).reduce((acc, key) => {\n                return { ...acc, [key]: this.Optional(object.properties[key]) };\n            }, {});\n            return this.Object(properties, this.Discard(object, ['required']) /* object used as options to retain other constraints */);\n        }, options);\n    }\n    /** `[Json]` Constructs a type whose keys are picked from the given type */\n    Pick(schema, unresolved, options = {}) {\n        const keys = KeyArrayResolver.Resolve(unresolved);\n        // prettier-ignore\n        return ObjectMap.Map(this.Discard(TypeClone.Type(schema), ['$id', exports.Transform]), (object) => {\n            if (ValueGuard.IsArray(object.required)) {\n                object.required = object.required.filter((key) => keys.includes(key));\n                if (object.required.length === 0)\n                    delete object.required;\n            }\n            for (const key of Object.getOwnPropertyNames(object.properties)) {\n                if (!keys.includes(key))\n                    delete object.properties[key];\n            }\n            return this.Create(object);\n        }, options);\n    }\n    /** `[Json]` Creates a Record type */\n    Record(key, schema, options = {}) {\n        // prettier-ignore\n        return (TypeGuard.TTemplateLiteral(key) ? (() => {\n            const expression = TemplateLiteralParser.ParseExact(key.pattern);\n            // prettier-ignore\n            return TemplateLiteralFinite.Check(expression)\n                ? (this.Object([...TemplateLiteralGenerator.Generate(expression)].reduce((acc, key) => ({ ...acc, [key]: TypeClone.Type(schema) }), {}), options))\n                : this.Create({ ...options, [exports.Kind]: 'Record', type: 'object', patternProperties: { [key.pattern]: TypeClone.Type(schema) } });\n        })() :\n            TypeGuard.TUnion(key) ? (() => {\n                const union = UnionResolver.Resolve(key);\n                if (TypeGuard.TUnionLiteral(union)) {\n                    const properties = union.anyOf.reduce((acc, literal) => ({ ...acc, [literal.const]: TypeClone.Type(schema) }), {});\n                    return this.Object(properties, { ...options, [exports.Hint]: 'Record' });\n                }\n                else\n                    this.Throw('Record key of type union contains non-literal types');\n            })() :\n                TypeGuard.TLiteral(key) ? (() => {\n                    // prettier-ignore\n                    return (ValueGuard.IsString(key.const) || ValueGuard.IsNumber(key.const))\n                        ? this.Object({ [key.const]: TypeClone.Type(schema) }, options)\n                        : this.Throw('Record key of type literal is not of type string or number');\n                })() :\n                    TypeGuard.TInteger(key) || TypeGuard.TNumber(key) ? (() => {\n                        return this.Create({ ...options, [exports.Kind]: 'Record', type: 'object', patternProperties: { [exports.PatternNumberExact]: TypeClone.Type(schema) } });\n                    })() :\n                        TypeGuard.TString(key) ? (() => {\n                            const pattern = ValueGuard.IsUndefined(key.pattern) ? exports.PatternStringExact : key.pattern;\n                            return this.Create({ ...options, [exports.Kind]: 'Record', type: 'object', patternProperties: { [pattern]: TypeClone.Type(schema) } });\n                        })() :\n                            this.Never());\n    }\n    /** `[Json]` Creates a Recursive type */\n    Recursive(callback, options = {}) {\n        if (ValueGuard.IsUndefined(options.$id))\n            options.$id = `T${TypeOrdinal++}`;\n        const thisType = callback({ [exports.Kind]: 'This', $ref: `${options.$id}` });\n        thisType.$id = options.$id;\n        return this.Create({ ...options, [exports.Hint]: 'Recursive', ...thisType });\n    }\n    /** `[Json]` Creates a Ref type. */\n    Ref(unresolved, options = {}) {\n        if (ValueGuard.IsString(unresolved))\n            return this.Create({ ...options, [exports.Kind]: 'Ref', $ref: unresolved });\n        if (ValueGuard.IsUndefined(unresolved.$id))\n            this.Throw('Reference target type must specify an $id');\n        return this.Create({ ...options, [exports.Kind]: 'Ref', $ref: unresolved.$id });\n    }\n    /** `[Json]` Constructs a type where all properties are required */\n    Required(schema, options = {}) {\n        // prettier-ignore\n        return ObjectMap.Map(this.Discard(TypeClone.Type(schema), ['$id', exports.Transform]), (object) => {\n            const properties = Object.getOwnPropertyNames(object.properties).reduce((acc, key) => {\n                return { ...acc, [key]: this.Discard(object.properties[key], [exports.Optional]) };\n            }, {});\n            return this.Object(properties, object /* object used as options to retain other constraints  */);\n        }, options);\n    }\n    /** `[Json]` Extracts interior Rest elements from Tuple, Intersect and Union types */\n    Rest(schema) {\n        return (TypeGuard.TTuple(schema) && !ValueGuard.IsUndefined(schema.items) ? TypeClone.Rest(schema.items) : TypeGuard.TIntersect(schema) ? TypeClone.Rest(schema.allOf) : TypeGuard.TUnion(schema) ? TypeClone.Rest(schema.anyOf) : []);\n    }\n    /** `[Json]` Creates a String type */\n    String(options = {}) {\n        return this.Create({ ...options, [exports.Kind]: 'String', type: 'string' });\n    }\n    /** `[Json]` Creates a TemplateLiteral type */\n    TemplateLiteral(unresolved, options = {}) {\n        // prettier-ignore\n        const pattern = ValueGuard.IsString(unresolved)\n            ? TemplateLiteralPattern.Create(TemplateLiteralDslParser.Parse(unresolved))\n            : TemplateLiteralPattern.Create(unresolved);\n        return this.Create({ ...options, [exports.Kind]: 'TemplateLiteral', type: 'string', pattern });\n    }\n    /** `[Json]` Creates a Transform type */\n    Transform(schema) {\n        return new TransformDecodeBuilder(schema);\n    }\n    /** `[Json]` Creates a Tuple type */\n    Tuple(items, options = {}) {\n        const [additionalItems, minItems, maxItems] = [false, items.length, items.length];\n        const clonedItems = TypeClone.Rest(items);\n        // prettier-ignore\n        const schema = (items.length > 0 ?\n            { ...options, [exports.Kind]: 'Tuple', type: 'array', items: clonedItems, additionalItems, minItems, maxItems } :\n            { ...options, [exports.Kind]: 'Tuple', type: 'array', minItems, maxItems });\n        return this.Create(schema);\n    }\n    /** `[Json]` Intrinsic function to Uncapitalize LiteralString types */\n    Uncapitalize(schema, options = {}) {\n        return { ...Intrinsic.Map(TypeClone.Type(schema), 'Uncapitalize'), ...options };\n    }\n    /** `[Json]` Creates a Union type */\n    Union(union, options = {}) {\n        // prettier-ignore\n        return TypeGuard.TTemplateLiteral(union)\n            ? TemplateLiteralResolver.Resolve(union)\n            : (() => {\n                const anyOf = union;\n                if (anyOf.length === 0)\n                    return this.Never(options);\n                if (anyOf.length === 1)\n                    return this.Create(TypeClone.Type(anyOf[0], options));\n                const clonedAnyOf = TypeClone.Rest(anyOf);\n                return this.Create({ ...options, [exports.Kind]: 'Union', anyOf: clonedAnyOf });\n            })();\n    }\n    /** `[Json]` Creates an Unknown type */\n    Unknown(options = {}) {\n        return this.Create({ ...options, [exports.Kind]: 'Unknown' });\n    }\n    /** `[Json]` Creates a Unsafe type that will infers as the generic argument T */\n    Unsafe(options = {}) {\n        return this.Create({ ...options, [exports.Kind]: options[exports.Kind] || 'Unsafe' });\n    }\n    /** `[Json]` Intrinsic function to Uppercase LiteralString types */\n    Uppercase(schema, options = {}) {\n        return { ...Intrinsic.Map(TypeClone.Type(schema), 'Uppercase'), ...options };\n    }\n}\nexports.JsonTypeBuilder = JsonTypeBuilder;\n// --------------------------------------------------------------------------\n// JavaScriptTypeBuilder\n// --------------------------------------------------------------------------\nclass JavaScriptTypeBuilder extends JsonTypeBuilder {\n    /** `[JavaScript]` Creates a AsyncIterator type */\n    AsyncIterator(items, options = {}) {\n        return this.Create({ ...options, [exports.Kind]: 'AsyncIterator', type: 'AsyncIterator', items: TypeClone.Type(items) });\n    }\n    /** `[JavaScript]` Constructs a type by recursively unwrapping Promise types */\n    Awaited(schema, options = {}) {\n        // prettier-ignore\n        const Unwrap = (rest) => rest.length > 0 ? (() => {\n            const [L, ...R] = rest;\n            return [this.Awaited(L), ...Unwrap(R)];\n        })() : rest;\n        // prettier-ignore\n        return (TypeGuard.TIntersect(schema) ? exports.Type.Intersect(Unwrap(schema.allOf)) :\n            TypeGuard.TUnion(schema) ? exports.Type.Union(Unwrap(schema.anyOf)) :\n                TypeGuard.TPromise(schema) ? this.Awaited(schema.item) :\n                    TypeClone.Type(schema, options));\n    }\n    /** `[JavaScript]` Creates a BigInt type */\n    BigInt(options = {}) {\n        return this.Create({ ...options, [exports.Kind]: 'BigInt', type: 'bigint' });\n    }\n    /** `[JavaScript]` Extracts the ConstructorParameters from the given Constructor type */\n    ConstructorParameters(schema, options = {}) {\n        return this.Tuple([...schema.parameters], { ...options });\n    }\n    /** `[JavaScript]` Creates a Constructor type */\n    Constructor(parameters, returns, options) {\n        const [clonedParameters, clonedReturns] = [TypeClone.Rest(parameters), TypeClone.Type(returns)];\n        return this.Create({ ...options, [exports.Kind]: 'Constructor', type: 'Constructor', parameters: clonedParameters, returns: clonedReturns });\n    }\n    /** `[JavaScript]` Creates a Date type */\n    Date(options = {}) {\n        return this.Create({ ...options, [exports.Kind]: 'Date', type: 'Date' });\n    }\n    /** `[JavaScript]` Creates a Function type */\n    Function(parameters, returns, options) {\n        const [clonedParameters, clonedReturns] = [TypeClone.Rest(parameters), TypeClone.Type(returns)];\n        return this.Create({ ...options, [exports.Kind]: 'Function', type: 'Function', parameters: clonedParameters, returns: clonedReturns });\n    }\n    /** `[JavaScript]` Extracts the InstanceType from the given Constructor type */\n    InstanceType(schema, options = {}) {\n        return TypeClone.Type(schema.returns, options);\n    }\n    /** `[JavaScript]` Creates an Iterator type */\n    Iterator(items, options = {}) {\n        return this.Create({ ...options, [exports.Kind]: 'Iterator', type: 'Iterator', items: TypeClone.Type(items) });\n    }\n    /** `[JavaScript]` Extracts the Parameters from the given Function type */\n    Parameters(schema, options = {}) {\n        return this.Tuple(schema.parameters, { ...options });\n    }\n    /** `[JavaScript]` Creates a Promise type */\n    Promise(item, options = {}) {\n        return this.Create({ ...options, [exports.Kind]: 'Promise', type: 'Promise', item: TypeClone.Type(item) });\n    }\n    /** `[Extended]` Creates a String type */\n    RegExp(unresolved, options = {}) {\n        const pattern = ValueGuard.IsString(unresolved) ? unresolved : unresolved.source;\n        return this.Create({ ...options, [exports.Kind]: 'String', type: 'string', pattern });\n    }\n    /**\n     * @deprecated Use `Type.RegExp`\n     */\n    RegEx(regex, options = {}) {\n        return this.RegExp(regex, options);\n    }\n    /** `[JavaScript]` Extracts the ReturnType from the given Function type */\n    ReturnType(schema, options = {}) {\n        return TypeClone.Type(schema.returns, options);\n    }\n    /** `[JavaScript]` Creates a Symbol type */\n    Symbol(options) {\n        return this.Create({ ...options, [exports.Kind]: 'Symbol', type: 'symbol' });\n    }\n    /** `[JavaScript]` Creates a Undefined type */\n    Undefined(options = {}) {\n        return this.Create({ ...options, [exports.Kind]: 'Undefined', type: 'undefined' });\n    }\n    /** `[JavaScript]` Creates a Uint8Array type */\n    Uint8Array(options = {}) {\n        return this.Create({ ...options, [exports.Kind]: 'Uint8Array', type: 'Uint8Array' });\n    }\n    /** `[JavaScript]` Creates a Void type */\n    Void(options = {}) {\n        return this.Create({ ...options, [exports.Kind]: 'Void', type: 'void' });\n    }\n}\nexports.JavaScriptTypeBuilder = JavaScriptTypeBuilder;\n/** Json Type Builder with Static Resolution for TypeScript */\nexports.JsonType = new JsonTypeBuilder();\n/** JavaScript Type Builder with Static Resolution for TypeScript */\nexports.Type = new JavaScriptTypeBuilder();\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}