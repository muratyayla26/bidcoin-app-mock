{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.storage = void 0;\nconst utils_1 = require(\"@trezor/utils\");\nconst storageVersion = 2;\nconst storageName = `storage_v${storageVersion}`;\nconst getEmptyState = () => ({\n  origin: {}\n});\nlet memoryStorage = getEmptyState();\nconst getPermanentStorage = () => {\n  const ls = localStorage.getItem(storageName);\n  return ls ? JSON.parse(ls) : getEmptyState();\n};\nclass Storage extends utils_1.TypedEmitter {\n  save(getNewState) {\n    let temporary = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    if (temporary || !global.window) {\n      memoryStorage = getNewState(memoryStorage);\n      return;\n    }\n    try {\n      const newState = getNewState(getPermanentStorage());\n      localStorage.setItem(storageName, JSON.stringify(newState));\n      this.emit('changed', newState);\n    } catch (err) {\n      console.warn('long term storage not available');\n      memoryStorage = getNewState(memoryStorage);\n    }\n  }\n  saveForOrigin(getNewState, origin) {\n    let temporary = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    this.save(state => {\n      var _a;\n      return Object.assign(Object.assign({}, state), {\n        origin: Object.assign(Object.assign({}, state.origin), {\n          [origin]: getNewState(((_a = state.origin) === null || _a === void 0 ? void 0 : _a[origin]) || {})\n        })\n      });\n    }, temporary);\n  }\n  load() {\n    let temporary = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    var _a;\n    if (temporary || !((_a = global === null || global === void 0 ? void 0 : global.window) === null || _a === void 0 ? void 0 : _a.localStorage)) {\n      return memoryStorage;\n    }\n    try {\n      return getPermanentStorage();\n    } catch (err) {\n      console.warn('long term storage not available');\n      return memoryStorage;\n    }\n  }\n  loadForOrigin(origin) {\n    let temporary = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    var _a;\n    const state = this.load(temporary);\n    return ((_a = state.origin) === null || _a === void 0 ? void 0 : _a[origin]) || {};\n  }\n}\nconst storage = new Storage();\nexports.storage = storage;","map":{"version":3,"names":["Object","defineProperty","exports","value","storage","utils_1","require","storageVersion","storageName","getEmptyState","origin","memoryStorage","getPermanentStorage","ls","localStorage","getItem","JSON","parse","Storage","TypedEmitter","save","getNewState","temporary","arguments","length","undefined","global","window","newState","setItem","stringify","emit","err","console","warn","saveForOrigin","state","_a","assign","load","loadForOrigin"],"sources":["C:/Users/Administrator/solana-wallet-app/node_modules/@trezor/connect-common/lib/storage.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.storage = void 0;\nconst utils_1 = require(\"@trezor/utils\");\nconst storageVersion = 2;\nconst storageName = `storage_v${storageVersion}`;\nconst getEmptyState = () => ({\n    origin: {},\n});\nlet memoryStorage = getEmptyState();\nconst getPermanentStorage = () => {\n    const ls = localStorage.getItem(storageName);\n    return ls ? JSON.parse(ls) : getEmptyState();\n};\nclass Storage extends utils_1.TypedEmitter {\n    save(getNewState, temporary = false) {\n        if (temporary || !global.window) {\n            memoryStorage = getNewState(memoryStorage);\n            return;\n        }\n        try {\n            const newState = getNewState(getPermanentStorage());\n            localStorage.setItem(storageName, JSON.stringify(newState));\n            this.emit('changed', newState);\n        }\n        catch (err) {\n            console.warn('long term storage not available');\n            memoryStorage = getNewState(memoryStorage);\n        }\n    }\n    saveForOrigin(getNewState, origin, temporary = false) {\n        this.save(state => {\n            var _a;\n            return (Object.assign(Object.assign({}, state), { origin: Object.assign(Object.assign({}, state.origin), { [origin]: getNewState(((_a = state.origin) === null || _a === void 0 ? void 0 : _a[origin]) || {}) }) }));\n        }, temporary);\n    }\n    load(temporary = false) {\n        var _a;\n        if (temporary || !((_a = global === null || global === void 0 ? void 0 : global.window) === null || _a === void 0 ? void 0 : _a.localStorage)) {\n            return memoryStorage;\n        }\n        try {\n            return getPermanentStorage();\n        }\n        catch (err) {\n            console.warn('long term storage not available');\n            return memoryStorage;\n        }\n    }\n    loadForOrigin(origin, temporary = false) {\n        var _a;\n        const state = this.load(temporary);\n        return ((_a = state.origin) === null || _a === void 0 ? void 0 : _a[origin]) || {};\n    }\n}\nconst storage = new Storage();\nexports.storage = storage;\n//# sourceMappingURL=storage.js.map"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}