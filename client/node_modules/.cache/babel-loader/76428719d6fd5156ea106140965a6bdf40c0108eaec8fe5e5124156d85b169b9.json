{"ast":null,"code":"\"use strict\";\n\n/*--------------------------------------------------------------------------\n\n@sinclair/typebox/errors\n\nThe MIT License (MIT)\n\nCopyright (c) 2017-2023 Haydn Paterson (sinclair) <haydn.developer@gmail.com>\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n\n---------------------------------------------------------------------------*/\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Errors = exports.ValueErrorIterator = exports.EscapeKey = exports.ValueErrorsUnknownTypeError = exports.ValueErrorType = void 0;\nconst guard_1 = require(\"../value/guard\");\nconst system_1 = require(\"../system/system\");\nconst deref_1 = require(\"../value/deref\");\nconst hash_1 = require(\"../value/hash\");\nconst Types = require(\"../typebox\");\n// --------------------------------------------------------------------------\n// ValueErrorType\n// --------------------------------------------------------------------------\nvar ValueErrorType;\n(function (ValueErrorType) {\n  ValueErrorType[ValueErrorType[\"ArrayContains\"] = 0] = \"ArrayContains\";\n  ValueErrorType[ValueErrorType[\"ArrayMaxContains\"] = 1] = \"ArrayMaxContains\";\n  ValueErrorType[ValueErrorType[\"ArrayMaxItems\"] = 2] = \"ArrayMaxItems\";\n  ValueErrorType[ValueErrorType[\"ArrayMinContains\"] = 3] = \"ArrayMinContains\";\n  ValueErrorType[ValueErrorType[\"ArrayMinItems\"] = 4] = \"ArrayMinItems\";\n  ValueErrorType[ValueErrorType[\"ArrayUniqueItems\"] = 5] = \"ArrayUniqueItems\";\n  ValueErrorType[ValueErrorType[\"Array\"] = 6] = \"Array\";\n  ValueErrorType[ValueErrorType[\"AsyncIterator\"] = 7] = \"AsyncIterator\";\n  ValueErrorType[ValueErrorType[\"BigIntExclusiveMaximum\"] = 8] = \"BigIntExclusiveMaximum\";\n  ValueErrorType[ValueErrorType[\"BigIntExclusiveMinimum\"] = 9] = \"BigIntExclusiveMinimum\";\n  ValueErrorType[ValueErrorType[\"BigIntMaximum\"] = 10] = \"BigIntMaximum\";\n  ValueErrorType[ValueErrorType[\"BigIntMinimum\"] = 11] = \"BigIntMinimum\";\n  ValueErrorType[ValueErrorType[\"BigIntMultipleOf\"] = 12] = \"BigIntMultipleOf\";\n  ValueErrorType[ValueErrorType[\"BigInt\"] = 13] = \"BigInt\";\n  ValueErrorType[ValueErrorType[\"Boolean\"] = 14] = \"Boolean\";\n  ValueErrorType[ValueErrorType[\"DateExclusiveMaximumTimestamp\"] = 15] = \"DateExclusiveMaximumTimestamp\";\n  ValueErrorType[ValueErrorType[\"DateExclusiveMinimumTimestamp\"] = 16] = \"DateExclusiveMinimumTimestamp\";\n  ValueErrorType[ValueErrorType[\"DateMaximumTimestamp\"] = 17] = \"DateMaximumTimestamp\";\n  ValueErrorType[ValueErrorType[\"DateMinimumTimestamp\"] = 18] = \"DateMinimumTimestamp\";\n  ValueErrorType[ValueErrorType[\"DateMultipleOfTimestamp\"] = 19] = \"DateMultipleOfTimestamp\";\n  ValueErrorType[ValueErrorType[\"Date\"] = 20] = \"Date\";\n  ValueErrorType[ValueErrorType[\"Function\"] = 21] = \"Function\";\n  ValueErrorType[ValueErrorType[\"IntegerExclusiveMaximum\"] = 22] = \"IntegerExclusiveMaximum\";\n  ValueErrorType[ValueErrorType[\"IntegerExclusiveMinimum\"] = 23] = \"IntegerExclusiveMinimum\";\n  ValueErrorType[ValueErrorType[\"IntegerMaximum\"] = 24] = \"IntegerMaximum\";\n  ValueErrorType[ValueErrorType[\"IntegerMinimum\"] = 25] = \"IntegerMinimum\";\n  ValueErrorType[ValueErrorType[\"IntegerMultipleOf\"] = 26] = \"IntegerMultipleOf\";\n  ValueErrorType[ValueErrorType[\"Integer\"] = 27] = \"Integer\";\n  ValueErrorType[ValueErrorType[\"IntersectUnevaluatedProperties\"] = 28] = \"IntersectUnevaluatedProperties\";\n  ValueErrorType[ValueErrorType[\"Intersect\"] = 29] = \"Intersect\";\n  ValueErrorType[ValueErrorType[\"Iterator\"] = 30] = \"Iterator\";\n  ValueErrorType[ValueErrorType[\"Kind\"] = 31] = \"Kind\";\n  ValueErrorType[ValueErrorType[\"Literal\"] = 32] = \"Literal\";\n  ValueErrorType[ValueErrorType[\"Never\"] = 33] = \"Never\";\n  ValueErrorType[ValueErrorType[\"Not\"] = 34] = \"Not\";\n  ValueErrorType[ValueErrorType[\"Null\"] = 35] = \"Null\";\n  ValueErrorType[ValueErrorType[\"NumberExclusiveMaximum\"] = 36] = \"NumberExclusiveMaximum\";\n  ValueErrorType[ValueErrorType[\"NumberExclusiveMinimum\"] = 37] = \"NumberExclusiveMinimum\";\n  ValueErrorType[ValueErrorType[\"NumberMaximum\"] = 38] = \"NumberMaximum\";\n  ValueErrorType[ValueErrorType[\"NumberMinimum\"] = 39] = \"NumberMinimum\";\n  ValueErrorType[ValueErrorType[\"NumberMultipleOf\"] = 40] = \"NumberMultipleOf\";\n  ValueErrorType[ValueErrorType[\"Number\"] = 41] = \"Number\";\n  ValueErrorType[ValueErrorType[\"ObjectAdditionalProperties\"] = 42] = \"ObjectAdditionalProperties\";\n  ValueErrorType[ValueErrorType[\"ObjectMaxProperties\"] = 43] = \"ObjectMaxProperties\";\n  ValueErrorType[ValueErrorType[\"ObjectMinProperties\"] = 44] = \"ObjectMinProperties\";\n  ValueErrorType[ValueErrorType[\"ObjectRequiredProperty\"] = 45] = \"ObjectRequiredProperty\";\n  ValueErrorType[ValueErrorType[\"Object\"] = 46] = \"Object\";\n  ValueErrorType[ValueErrorType[\"Promise\"] = 47] = \"Promise\";\n  ValueErrorType[ValueErrorType[\"StringFormatUnknown\"] = 48] = \"StringFormatUnknown\";\n  ValueErrorType[ValueErrorType[\"StringFormat\"] = 49] = \"StringFormat\";\n  ValueErrorType[ValueErrorType[\"StringMaxLength\"] = 50] = \"StringMaxLength\";\n  ValueErrorType[ValueErrorType[\"StringMinLength\"] = 51] = \"StringMinLength\";\n  ValueErrorType[ValueErrorType[\"StringPattern\"] = 52] = \"StringPattern\";\n  ValueErrorType[ValueErrorType[\"String\"] = 53] = \"String\";\n  ValueErrorType[ValueErrorType[\"Symbol\"] = 54] = \"Symbol\";\n  ValueErrorType[ValueErrorType[\"TupleLength\"] = 55] = \"TupleLength\";\n  ValueErrorType[ValueErrorType[\"Tuple\"] = 56] = \"Tuple\";\n  ValueErrorType[ValueErrorType[\"Uint8ArrayMaxByteLength\"] = 57] = \"Uint8ArrayMaxByteLength\";\n  ValueErrorType[ValueErrorType[\"Uint8ArrayMinByteLength\"] = 58] = \"Uint8ArrayMinByteLength\";\n  ValueErrorType[ValueErrorType[\"Uint8Array\"] = 59] = \"Uint8Array\";\n  ValueErrorType[ValueErrorType[\"Undefined\"] = 60] = \"Undefined\";\n  ValueErrorType[ValueErrorType[\"Union\"] = 61] = \"Union\";\n  ValueErrorType[ValueErrorType[\"Void\"] = 62] = \"Void\";\n})(ValueErrorType || (exports.ValueErrorType = ValueErrorType = {}));\n// --------------------------------------------------------------------------\n// ValueErrors\n// --------------------------------------------------------------------------\nclass ValueErrorsUnknownTypeError extends Types.TypeBoxError {\n  constructor(schema) {\n    super('Unknown type');\n    this.schema = schema;\n  }\n}\nexports.ValueErrorsUnknownTypeError = ValueErrorsUnknownTypeError;\n// --------------------------------------------------------------------------\n// EscapeKey\n// --------------------------------------------------------------------------\nfunction EscapeKey(key) {\n  return key.replace(/~/g, '~0').replace(/\\//g, '~1'); // RFC6901 Path\n}\nexports.EscapeKey = EscapeKey;\n// --------------------------------------------------------------------------\n// Guards\n// --------------------------------------------------------------------------\nfunction IsDefined(value) {\n  return value !== undefined;\n}\n// --------------------------------------------------------------------------\n// ValueErrorIterator\n// --------------------------------------------------------------------------\nclass ValueErrorIterator {\n  constructor(iterator) {\n    this.iterator = iterator;\n  }\n  [Symbol.iterator]() {\n    return this.iterator;\n  }\n  /** Returns the first value error or undefined if no errors */\n  First() {\n    const next = this.iterator.next();\n    return next.done ? undefined : next.value;\n  }\n}\nexports.ValueErrorIterator = ValueErrorIterator;\n// --------------------------------------------------------------------------\n// Create\n// --------------------------------------------------------------------------\nfunction Create(type, schema, path, value) {\n  return {\n    type,\n    schema,\n    path,\n    value,\n    message: system_1.TypeSystemErrorFunction.Get()(schema, type)\n  };\n}\n// --------------------------------------------------------------------------\n// Types\n// --------------------------------------------------------------------------\nfunction* TAny(schema, references, path, value) {}\nfunction* TArray(schema, references, path, value) {\n  if (!(0, guard_1.IsArray)(value)) {\n    return yield Create(ValueErrorType.Array, schema, path, value);\n  }\n  if (IsDefined(schema.minItems) && !(value.length >= schema.minItems)) {\n    yield Create(ValueErrorType.ArrayMinItems, schema, path, value);\n  }\n  if (IsDefined(schema.maxItems) && !(value.length <= schema.maxItems)) {\n    yield Create(ValueErrorType.ArrayMaxItems, schema, path, value);\n  }\n  for (let i = 0; i < value.length; i++) {\n    yield* Visit(schema.items, references, `${path}/${i}`, value[i]);\n  }\n  // prettier-ignore\n  if (schema.uniqueItems === true && !function () {\n    const set = new Set();\n    for (const element of value) {\n      const hashed = (0, hash_1.Hash)(element);\n      if (set.has(hashed)) {\n        return false;\n      } else {\n        set.add(hashed);\n      }\n    }\n    return true;\n  }()) {\n    yield Create(ValueErrorType.ArrayUniqueItems, schema, path, value);\n  }\n  // contains\n  if (!(IsDefined(schema.contains) || IsDefined(schema.minContains) || IsDefined(schema.maxContains))) {\n    return;\n  }\n  const containsSchema = IsDefined(schema.contains) ? schema.contains : Types.Type.Never();\n  const containsCount = value.reduce((acc, value, index) => Visit(containsSchema, references, `${path}${index}`, value).next().done === true ? acc + 1 : acc, 0);\n  if (containsCount === 0) {\n    yield Create(ValueErrorType.ArrayContains, schema, path, value);\n  }\n  if ((0, guard_1.IsNumber)(schema.minContains) && containsCount < schema.minContains) {\n    yield Create(ValueErrorType.ArrayMinContains, schema, path, value);\n  }\n  if ((0, guard_1.IsNumber)(schema.maxContains) && containsCount > schema.maxContains) {\n    yield Create(ValueErrorType.ArrayMaxContains, schema, path, value);\n  }\n}\nfunction* TAsyncIterator(schema, references, path, value) {\n  if (!(0, guard_1.IsAsyncIterator)(value)) yield Create(ValueErrorType.AsyncIterator, schema, path, value);\n}\nfunction* TBigInt(schema, references, path, value) {\n  if (!(0, guard_1.IsBigInt)(value)) return yield Create(ValueErrorType.BigInt, schema, path, value);\n  if (IsDefined(schema.exclusiveMaximum) && !(value < schema.exclusiveMaximum)) {\n    yield Create(ValueErrorType.BigIntExclusiveMaximum, schema, path, value);\n  }\n  if (IsDefined(schema.exclusiveMinimum) && !(value > schema.exclusiveMinimum)) {\n    yield Create(ValueErrorType.BigIntExclusiveMinimum, schema, path, value);\n  }\n  if (IsDefined(schema.maximum) && !(value <= schema.maximum)) {\n    yield Create(ValueErrorType.BigIntMaximum, schema, path, value);\n  }\n  if (IsDefined(schema.minimum) && !(value >= schema.minimum)) {\n    yield Create(ValueErrorType.BigIntMinimum, schema, path, value);\n  }\n  if (IsDefined(schema.multipleOf) && !(value % schema.multipleOf === BigInt(0))) {\n    yield Create(ValueErrorType.BigIntMultipleOf, schema, path, value);\n  }\n}\nfunction* TBoolean(schema, references, path, value) {\n  if (!(0, guard_1.IsBoolean)(value)) yield Create(ValueErrorType.Boolean, schema, path, value);\n}\nfunction* TConstructor(schema, references, path, value) {\n  yield* Visit(schema.returns, references, path, value.prototype);\n}\nfunction* TDate(schema, references, path, value) {\n  if (!(0, guard_1.IsDate)(value)) return yield Create(ValueErrorType.Date, schema, path, value);\n  if (IsDefined(schema.exclusiveMaximumTimestamp) && !(value.getTime() < schema.exclusiveMaximumTimestamp)) {\n    yield Create(ValueErrorType.DateExclusiveMaximumTimestamp, schema, path, value);\n  }\n  if (IsDefined(schema.exclusiveMinimumTimestamp) && !(value.getTime() > schema.exclusiveMinimumTimestamp)) {\n    yield Create(ValueErrorType.DateExclusiveMinimumTimestamp, schema, path, value);\n  }\n  if (IsDefined(schema.maximumTimestamp) && !(value.getTime() <= schema.maximumTimestamp)) {\n    yield Create(ValueErrorType.DateMaximumTimestamp, schema, path, value);\n  }\n  if (IsDefined(schema.minimumTimestamp) && !(value.getTime() >= schema.minimumTimestamp)) {\n    yield Create(ValueErrorType.DateMinimumTimestamp, schema, path, value);\n  }\n  if (IsDefined(schema.multipleOfTimestamp) && !(value.getTime() % schema.multipleOfTimestamp === 0)) {\n    yield Create(ValueErrorType.DateMultipleOfTimestamp, schema, path, value);\n  }\n}\nfunction* TFunction(schema, references, path, value) {\n  if (!(0, guard_1.IsFunction)(value)) yield Create(ValueErrorType.Function, schema, path, value);\n}\nfunction* TInteger(schema, references, path, value) {\n  if (!(0, guard_1.IsInteger)(value)) return yield Create(ValueErrorType.Integer, schema, path, value);\n  if (IsDefined(schema.exclusiveMaximum) && !(value < schema.exclusiveMaximum)) {\n    yield Create(ValueErrorType.IntegerExclusiveMaximum, schema, path, value);\n  }\n  if (IsDefined(schema.exclusiveMinimum) && !(value > schema.exclusiveMinimum)) {\n    yield Create(ValueErrorType.IntegerExclusiveMinimum, schema, path, value);\n  }\n  if (IsDefined(schema.maximum) && !(value <= schema.maximum)) {\n    yield Create(ValueErrorType.IntegerMaximum, schema, path, value);\n  }\n  if (IsDefined(schema.minimum) && !(value >= schema.minimum)) {\n    yield Create(ValueErrorType.IntegerMinimum, schema, path, value);\n  }\n  if (IsDefined(schema.multipleOf) && !(value % schema.multipleOf === 0)) {\n    yield Create(ValueErrorType.IntegerMultipleOf, schema, path, value);\n  }\n}\nfunction* TIntersect(schema, references, path, value) {\n  for (const inner of schema.allOf) {\n    const next = Visit(inner, references, path, value).next();\n    if (!next.done) {\n      yield Create(ValueErrorType.Intersect, schema, path, value);\n      yield next.value;\n    }\n  }\n  if (schema.unevaluatedProperties === false) {\n    const keyCheck = new RegExp(Types.KeyResolver.ResolvePattern(schema));\n    for (const valueKey of Object.getOwnPropertyNames(value)) {\n      if (!keyCheck.test(valueKey)) {\n        yield Create(ValueErrorType.IntersectUnevaluatedProperties, schema, `${path}/${valueKey}`, value);\n      }\n    }\n  }\n  if (typeof schema.unevaluatedProperties === 'object') {\n    const keyCheck = new RegExp(Types.KeyResolver.ResolvePattern(schema));\n    for (const valueKey of Object.getOwnPropertyNames(value)) {\n      if (!keyCheck.test(valueKey)) {\n        const next = Visit(schema.unevaluatedProperties, references, `${path}/${valueKey}`, value[valueKey]).next();\n        if (!next.done) yield next.value; // yield interior\n      }\n    }\n  }\n}\nfunction* TIterator(schema, references, path, value) {\n  if (!(0, guard_1.IsIterator)(value)) yield Create(ValueErrorType.Iterator, schema, path, value);\n}\nfunction* TLiteral(schema, references, path, value) {\n  if (!(value === schema.const)) yield Create(ValueErrorType.Literal, schema, path, value);\n}\nfunction* TNever(schema, references, path, value) {\n  yield Create(ValueErrorType.Never, schema, path, value);\n}\nfunction* TNot(schema, references, path, value) {\n  if (Visit(schema.not, references, path, value).next().done === true) yield Create(ValueErrorType.Not, schema, path, value);\n}\nfunction* TNull(schema, references, path, value) {\n  if (!(0, guard_1.IsNull)(value)) yield Create(ValueErrorType.Null, schema, path, value);\n}\nfunction* TNumber(schema, references, path, value) {\n  if (!system_1.TypeSystemPolicy.IsNumberLike(value)) return yield Create(ValueErrorType.Number, schema, path, value);\n  if (IsDefined(schema.exclusiveMaximum) && !(value < schema.exclusiveMaximum)) {\n    yield Create(ValueErrorType.NumberExclusiveMaximum, schema, path, value);\n  }\n  if (IsDefined(schema.exclusiveMinimum) && !(value > schema.exclusiveMinimum)) {\n    yield Create(ValueErrorType.NumberExclusiveMinimum, schema, path, value);\n  }\n  if (IsDefined(schema.maximum) && !(value <= schema.maximum)) {\n    yield Create(ValueErrorType.NumberMaximum, schema, path, value);\n  }\n  if (IsDefined(schema.minimum) && !(value >= schema.minimum)) {\n    yield Create(ValueErrorType.NumberMinimum, schema, path, value);\n  }\n  if (IsDefined(schema.multipleOf) && !(value % schema.multipleOf === 0)) {\n    yield Create(ValueErrorType.NumberMultipleOf, schema, path, value);\n  }\n}\nfunction* TObject(schema, references, path, value) {\n  if (!system_1.TypeSystemPolicy.IsObjectLike(value)) return yield Create(ValueErrorType.Object, schema, path, value);\n  if (IsDefined(schema.minProperties) && !(Object.getOwnPropertyNames(value).length >= schema.minProperties)) {\n    yield Create(ValueErrorType.ObjectMinProperties, schema, path, value);\n  }\n  if (IsDefined(schema.maxProperties) && !(Object.getOwnPropertyNames(value).length <= schema.maxProperties)) {\n    yield Create(ValueErrorType.ObjectMaxProperties, schema, path, value);\n  }\n  const requiredKeys = Array.isArray(schema.required) ? schema.required : [];\n  const knownKeys = Object.getOwnPropertyNames(schema.properties);\n  const unknownKeys = Object.getOwnPropertyNames(value);\n  for (const requiredKey of requiredKeys) {\n    if (unknownKeys.includes(requiredKey)) continue;\n    yield Create(ValueErrorType.ObjectRequiredProperty, schema.properties[requiredKey], `${path}/${EscapeKey(requiredKey)}`, undefined);\n  }\n  if (schema.additionalProperties === false) {\n    for (const valueKey of unknownKeys) {\n      if (!knownKeys.includes(valueKey)) {\n        yield Create(ValueErrorType.ObjectAdditionalProperties, schema, `${path}/${EscapeKey(valueKey)}`, value[valueKey]);\n      }\n    }\n  }\n  if (typeof schema.additionalProperties === 'object') {\n    for (const valueKey of unknownKeys) {\n      if (knownKeys.includes(valueKey)) continue;\n      yield* Visit(schema.additionalProperties, references, `${path}/${EscapeKey(valueKey)}`, value[valueKey]);\n    }\n  }\n  for (const knownKey of knownKeys) {\n    const property = schema.properties[knownKey];\n    if (schema.required && schema.required.includes(knownKey)) {\n      yield* Visit(property, references, `${path}/${EscapeKey(knownKey)}`, value[knownKey]);\n      if (Types.ExtendsUndefined.Check(schema) && !(knownKey in value)) {\n        yield Create(ValueErrorType.ObjectRequiredProperty, property, `${path}/${EscapeKey(knownKey)}`, undefined);\n      }\n    } else {\n      if (system_1.TypeSystemPolicy.IsExactOptionalProperty(value, knownKey)) {\n        yield* Visit(property, references, `${path}/${EscapeKey(knownKey)}`, value[knownKey]);\n      }\n    }\n  }\n}\nfunction* TPromise(schema, references, path, value) {\n  if (!(0, guard_1.IsPromise)(value)) yield Create(ValueErrorType.Promise, schema, path, value);\n}\nfunction* TRecord(schema, references, path, value) {\n  if (!system_1.TypeSystemPolicy.IsRecordLike(value)) return yield Create(ValueErrorType.Object, schema, path, value);\n  if (IsDefined(schema.minProperties) && !(Object.getOwnPropertyNames(value).length >= schema.minProperties)) {\n    yield Create(ValueErrorType.ObjectMinProperties, schema, path, value);\n  }\n  if (IsDefined(schema.maxProperties) && !(Object.getOwnPropertyNames(value).length <= schema.maxProperties)) {\n    yield Create(ValueErrorType.ObjectMaxProperties, schema, path, value);\n  }\n  const [patternKey, patternSchema] = Object.entries(schema.patternProperties)[0];\n  const regex = new RegExp(patternKey);\n  for (const [propertyKey, propertyValue] of Object.entries(value)) {\n    if (regex.test(propertyKey)) yield* Visit(patternSchema, references, `${path}/${EscapeKey(propertyKey)}`, propertyValue);\n  }\n  if (typeof schema.additionalProperties === 'object') {\n    for (const [propertyKey, propertyValue] of Object.entries(value)) {\n      if (!regex.test(propertyKey)) yield* Visit(schema.additionalProperties, references, `${path}/${EscapeKey(propertyKey)}`, propertyValue);\n    }\n  }\n  if (schema.additionalProperties === false) {\n    for (const [propertyKey, propertyValue] of Object.entries(value)) {\n      if (regex.test(propertyKey)) continue;\n      return yield Create(ValueErrorType.ObjectAdditionalProperties, schema, `${path}/${EscapeKey(propertyKey)}`, propertyValue);\n    }\n  }\n}\nfunction* TRef(schema, references, path, value) {\n  yield* Visit((0, deref_1.Deref)(schema, references), references, path, value);\n}\nfunction* TString(schema, references, path, value) {\n  if (!(0, guard_1.IsString)(value)) return yield Create(ValueErrorType.String, schema, path, value);\n  if (IsDefined(schema.minLength) && !(value.length >= schema.minLength)) {\n    yield Create(ValueErrorType.StringMinLength, schema, path, value);\n  }\n  if (IsDefined(schema.maxLength) && !(value.length <= schema.maxLength)) {\n    yield Create(ValueErrorType.StringMaxLength, schema, path, value);\n  }\n  if ((0, guard_1.IsString)(schema.pattern)) {\n    const regex = new RegExp(schema.pattern);\n    if (!regex.test(value)) {\n      yield Create(ValueErrorType.StringPattern, schema, path, value);\n    }\n  }\n  if ((0, guard_1.IsString)(schema.format)) {\n    if (!Types.FormatRegistry.Has(schema.format)) {\n      yield Create(ValueErrorType.StringFormatUnknown, schema, path, value);\n    } else {\n      const format = Types.FormatRegistry.Get(schema.format);\n      if (!format(value)) {\n        yield Create(ValueErrorType.StringFormat, schema, path, value);\n      }\n    }\n  }\n}\nfunction* TSymbol(schema, references, path, value) {\n  if (!(0, guard_1.IsSymbol)(value)) yield Create(ValueErrorType.Symbol, schema, path, value);\n}\nfunction* TTemplateLiteral(schema, references, path, value) {\n  if (!(0, guard_1.IsString)(value)) return yield Create(ValueErrorType.String, schema, path, value);\n  const regex = new RegExp(schema.pattern);\n  if (!regex.test(value)) {\n    yield Create(ValueErrorType.StringPattern, schema, path, value);\n  }\n}\nfunction* TThis(schema, references, path, value) {\n  yield* Visit((0, deref_1.Deref)(schema, references), references, path, value);\n}\nfunction* TTuple(schema, references, path, value) {\n  if (!(0, guard_1.IsArray)(value)) return yield Create(ValueErrorType.Tuple, schema, path, value);\n  if (schema.items === undefined && !(value.length === 0)) {\n    return yield Create(ValueErrorType.TupleLength, schema, path, value);\n  }\n  if (!(value.length === schema.maxItems)) {\n    return yield Create(ValueErrorType.TupleLength, schema, path, value);\n  }\n  if (!schema.items) {\n    return;\n  }\n  for (let i = 0; i < schema.items.length; i++) {\n    yield* Visit(schema.items[i], references, `${path}/${i}`, value[i]);\n  }\n}\nfunction* TUndefined(schema, references, path, value) {\n  if (!(0, guard_1.IsUndefined)(value)) yield Create(ValueErrorType.Undefined, schema, path, value);\n}\nfunction* TUnion(schema, references, path, value) {\n  let count = 0;\n  for (const subschema of schema.anyOf) {\n    const errors = [...Visit(subschema, references, path, value)];\n    if (errors.length === 0) return; // matched\n    count += errors.length;\n  }\n  if (count > 0) {\n    yield Create(ValueErrorType.Union, schema, path, value);\n  }\n}\nfunction* TUint8Array(schema, references, path, value) {\n  if (!(0, guard_1.IsUint8Array)(value)) return yield Create(ValueErrorType.Uint8Array, schema, path, value);\n  if (IsDefined(schema.maxByteLength) && !(value.length <= schema.maxByteLength)) {\n    yield Create(ValueErrorType.Uint8ArrayMaxByteLength, schema, path, value);\n  }\n  if (IsDefined(schema.minByteLength) && !(value.length >= schema.minByteLength)) {\n    yield Create(ValueErrorType.Uint8ArrayMinByteLength, schema, path, value);\n  }\n}\nfunction* TUnknown(schema, references, path, value) {}\nfunction* TVoid(schema, references, path, value) {\n  if (!system_1.TypeSystemPolicy.IsVoidLike(value)) yield Create(ValueErrorType.Void, schema, path, value);\n}\nfunction* TKind(schema, references, path, value) {\n  const check = Types.TypeRegistry.Get(schema[Types.Kind]);\n  if (!check(schema, value)) yield Create(ValueErrorType.Kind, schema, path, value);\n}\nfunction* Visit(schema, references, path, value) {\n  const references_ = IsDefined(schema.$id) ? [...references, schema] : references;\n  const schema_ = schema;\n  switch (schema_[Types.Kind]) {\n    case 'Any':\n      return yield* TAny(schema_, references_, path, value);\n    case 'Array':\n      return yield* TArray(schema_, references_, path, value);\n    case 'AsyncIterator':\n      return yield* TAsyncIterator(schema_, references_, path, value);\n    case 'BigInt':\n      return yield* TBigInt(schema_, references_, path, value);\n    case 'Boolean':\n      return yield* TBoolean(schema_, references_, path, value);\n    case 'Constructor':\n      return yield* TConstructor(schema_, references_, path, value);\n    case 'Date':\n      return yield* TDate(schema_, references_, path, value);\n    case 'Function':\n      return yield* TFunction(schema_, references_, path, value);\n    case 'Integer':\n      return yield* TInteger(schema_, references_, path, value);\n    case 'Intersect':\n      return yield* TIntersect(schema_, references_, path, value);\n    case 'Iterator':\n      return yield* TIterator(schema_, references_, path, value);\n    case 'Literal':\n      return yield* TLiteral(schema_, references_, path, value);\n    case 'Never':\n      return yield* TNever(schema_, references_, path, value);\n    case 'Not':\n      return yield* TNot(schema_, references_, path, value);\n    case 'Null':\n      return yield* TNull(schema_, references_, path, value);\n    case 'Number':\n      return yield* TNumber(schema_, references_, path, value);\n    case 'Object':\n      return yield* TObject(schema_, references_, path, value);\n    case 'Promise':\n      return yield* TPromise(schema_, references_, path, value);\n    case 'Record':\n      return yield* TRecord(schema_, references_, path, value);\n    case 'Ref':\n      return yield* TRef(schema_, references_, path, value);\n    case 'String':\n      return yield* TString(schema_, references_, path, value);\n    case 'Symbol':\n      return yield* TSymbol(schema_, references_, path, value);\n    case 'TemplateLiteral':\n      return yield* TTemplateLiteral(schema_, references_, path, value);\n    case 'This':\n      return yield* TThis(schema_, references_, path, value);\n    case 'Tuple':\n      return yield* TTuple(schema_, references_, path, value);\n    case 'Undefined':\n      return yield* TUndefined(schema_, references_, path, value);\n    case 'Union':\n      return yield* TUnion(schema_, references_, path, value);\n    case 'Uint8Array':\n      return yield* TUint8Array(schema_, references_, path, value);\n    case 'Unknown':\n      return yield* TUnknown(schema_, references_, path, value);\n    case 'Void':\n      return yield* TVoid(schema_, references_, path, value);\n    default:\n      if (!Types.TypeRegistry.Has(schema_[Types.Kind])) throw new ValueErrorsUnknownTypeError(schema);\n      return yield* TKind(schema_, references_, path, value);\n  }\n}\n/** Returns an iterator for each error in this value. */\nfunction Errors(...args) {\n  const iterator = args.length === 3 ? Visit(args[0], args[1], '', args[2]) : Visit(args[0], [], '', args[1]);\n  return new ValueErrorIterator(iterator);\n}\nexports.Errors = Errors;","map":{"version":3,"names":["Object","defineProperty","exports","value","Errors","ValueErrorIterator","EscapeKey","ValueErrorsUnknownTypeError","ValueErrorType","guard_1","require","system_1","deref_1","hash_1","Types","TypeBoxError","constructor","schema","key","replace","IsDefined","undefined","iterator","Symbol","First","next","done","Create","type","path","message","TypeSystemErrorFunction","Get","TAny","references","TArray","IsArray","Array","minItems","length","ArrayMinItems","maxItems","ArrayMaxItems","i","Visit","items","uniqueItems","set","Set","element","hashed","Hash","has","add","ArrayUniqueItems","contains","minContains","maxContains","containsSchema","Type","Never","containsCount","reduce","acc","index","ArrayContains","IsNumber","ArrayMinContains","ArrayMaxContains","TAsyncIterator","IsAsyncIterator","AsyncIterator","TBigInt","IsBigInt","BigInt","exclusiveMaximum","BigIntExclusiveMaximum","exclusiveMinimum","BigIntExclusiveMinimum","maximum","BigIntMaximum","minimum","BigIntMinimum","multipleOf","BigIntMultipleOf","TBoolean","IsBoolean","Boolean","TConstructor","returns","prototype","TDate","IsDate","Date","exclusiveMaximumTimestamp","getTime","DateExclusiveMaximumTimestamp","exclusiveMinimumTimestamp","DateExclusiveMinimumTimestamp","maximumTimestamp","DateMaximumTimestamp","minimumTimestamp","DateMinimumTimestamp","multipleOfTimestamp","DateMultipleOfTimestamp","TFunction","IsFunction","Function","TInteger","IsInteger","Integer","IntegerExclusiveMaximum","IntegerExclusiveMinimum","IntegerMaximum","IntegerMinimum","IntegerMultipleOf","TIntersect","inner","allOf","Intersect","unevaluatedProperties","keyCheck","RegExp","KeyResolver","ResolvePattern","valueKey","getOwnPropertyNames","test","IntersectUnevaluatedProperties","TIterator","IsIterator","Iterator","TLiteral","const","Literal","TNever","TNot","not","Not","TNull","IsNull","Null","TNumber","TypeSystemPolicy","IsNumberLike","Number","NumberExclusiveMaximum","NumberExclusiveMinimum","NumberMaximum","NumberMinimum","NumberMultipleOf","TObject","IsObjectLike","minProperties","ObjectMinProperties","maxProperties","ObjectMaxProperties","requiredKeys","isArray","required","knownKeys","properties","unknownKeys","requiredKey","includes","ObjectRequiredProperty","additionalProperties","ObjectAdditionalProperties","knownKey","property","ExtendsUndefined","Check","IsExactOptionalProperty","TPromise","IsPromise","Promise","TRecord","IsRecordLike","patternKey","patternSchema","entries","patternProperties","regex","propertyKey","propertyValue","TRef","Deref","TString","IsString","String","minLength","StringMinLength","maxLength","StringMaxLength","pattern","StringPattern","format","FormatRegistry","Has","StringFormatUnknown","StringFormat","TSymbol","IsSymbol","TTemplateLiteral","TThis","TTuple","Tuple","TupleLength","TUndefined","IsUndefined","Undefined","TUnion","count","subschema","anyOf","errors","Union","TUint8Array","IsUint8Array","Uint8Array","maxByteLength","Uint8ArrayMaxByteLength","minByteLength","Uint8ArrayMinByteLength","TUnknown","TVoid","IsVoidLike","Void","TKind","check","TypeRegistry","Kind","references_","$id","schema_","args"],"sources":["C:/Users/Administrator/solana-wallet-app/node_modules/@trezor/schema-utils/node_modules/@sinclair/typebox/errors/errors.js"],"sourcesContent":["\"use strict\";\n/*--------------------------------------------------------------------------\n\n@sinclair/typebox/errors\n\nThe MIT License (MIT)\n\nCopyright (c) 2017-2023 Haydn Paterson (sinclair) <haydn.developer@gmail.com>\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n\n---------------------------------------------------------------------------*/\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Errors = exports.ValueErrorIterator = exports.EscapeKey = exports.ValueErrorsUnknownTypeError = exports.ValueErrorType = void 0;\nconst guard_1 = require(\"../value/guard\");\nconst system_1 = require(\"../system/system\");\nconst deref_1 = require(\"../value/deref\");\nconst hash_1 = require(\"../value/hash\");\nconst Types = require(\"../typebox\");\n// --------------------------------------------------------------------------\n// ValueErrorType\n// --------------------------------------------------------------------------\nvar ValueErrorType;\n(function (ValueErrorType) {\n    ValueErrorType[ValueErrorType[\"ArrayContains\"] = 0] = \"ArrayContains\";\n    ValueErrorType[ValueErrorType[\"ArrayMaxContains\"] = 1] = \"ArrayMaxContains\";\n    ValueErrorType[ValueErrorType[\"ArrayMaxItems\"] = 2] = \"ArrayMaxItems\";\n    ValueErrorType[ValueErrorType[\"ArrayMinContains\"] = 3] = \"ArrayMinContains\";\n    ValueErrorType[ValueErrorType[\"ArrayMinItems\"] = 4] = \"ArrayMinItems\";\n    ValueErrorType[ValueErrorType[\"ArrayUniqueItems\"] = 5] = \"ArrayUniqueItems\";\n    ValueErrorType[ValueErrorType[\"Array\"] = 6] = \"Array\";\n    ValueErrorType[ValueErrorType[\"AsyncIterator\"] = 7] = \"AsyncIterator\";\n    ValueErrorType[ValueErrorType[\"BigIntExclusiveMaximum\"] = 8] = \"BigIntExclusiveMaximum\";\n    ValueErrorType[ValueErrorType[\"BigIntExclusiveMinimum\"] = 9] = \"BigIntExclusiveMinimum\";\n    ValueErrorType[ValueErrorType[\"BigIntMaximum\"] = 10] = \"BigIntMaximum\";\n    ValueErrorType[ValueErrorType[\"BigIntMinimum\"] = 11] = \"BigIntMinimum\";\n    ValueErrorType[ValueErrorType[\"BigIntMultipleOf\"] = 12] = \"BigIntMultipleOf\";\n    ValueErrorType[ValueErrorType[\"BigInt\"] = 13] = \"BigInt\";\n    ValueErrorType[ValueErrorType[\"Boolean\"] = 14] = \"Boolean\";\n    ValueErrorType[ValueErrorType[\"DateExclusiveMaximumTimestamp\"] = 15] = \"DateExclusiveMaximumTimestamp\";\n    ValueErrorType[ValueErrorType[\"DateExclusiveMinimumTimestamp\"] = 16] = \"DateExclusiveMinimumTimestamp\";\n    ValueErrorType[ValueErrorType[\"DateMaximumTimestamp\"] = 17] = \"DateMaximumTimestamp\";\n    ValueErrorType[ValueErrorType[\"DateMinimumTimestamp\"] = 18] = \"DateMinimumTimestamp\";\n    ValueErrorType[ValueErrorType[\"DateMultipleOfTimestamp\"] = 19] = \"DateMultipleOfTimestamp\";\n    ValueErrorType[ValueErrorType[\"Date\"] = 20] = \"Date\";\n    ValueErrorType[ValueErrorType[\"Function\"] = 21] = \"Function\";\n    ValueErrorType[ValueErrorType[\"IntegerExclusiveMaximum\"] = 22] = \"IntegerExclusiveMaximum\";\n    ValueErrorType[ValueErrorType[\"IntegerExclusiveMinimum\"] = 23] = \"IntegerExclusiveMinimum\";\n    ValueErrorType[ValueErrorType[\"IntegerMaximum\"] = 24] = \"IntegerMaximum\";\n    ValueErrorType[ValueErrorType[\"IntegerMinimum\"] = 25] = \"IntegerMinimum\";\n    ValueErrorType[ValueErrorType[\"IntegerMultipleOf\"] = 26] = \"IntegerMultipleOf\";\n    ValueErrorType[ValueErrorType[\"Integer\"] = 27] = \"Integer\";\n    ValueErrorType[ValueErrorType[\"IntersectUnevaluatedProperties\"] = 28] = \"IntersectUnevaluatedProperties\";\n    ValueErrorType[ValueErrorType[\"Intersect\"] = 29] = \"Intersect\";\n    ValueErrorType[ValueErrorType[\"Iterator\"] = 30] = \"Iterator\";\n    ValueErrorType[ValueErrorType[\"Kind\"] = 31] = \"Kind\";\n    ValueErrorType[ValueErrorType[\"Literal\"] = 32] = \"Literal\";\n    ValueErrorType[ValueErrorType[\"Never\"] = 33] = \"Never\";\n    ValueErrorType[ValueErrorType[\"Not\"] = 34] = \"Not\";\n    ValueErrorType[ValueErrorType[\"Null\"] = 35] = \"Null\";\n    ValueErrorType[ValueErrorType[\"NumberExclusiveMaximum\"] = 36] = \"NumberExclusiveMaximum\";\n    ValueErrorType[ValueErrorType[\"NumberExclusiveMinimum\"] = 37] = \"NumberExclusiveMinimum\";\n    ValueErrorType[ValueErrorType[\"NumberMaximum\"] = 38] = \"NumberMaximum\";\n    ValueErrorType[ValueErrorType[\"NumberMinimum\"] = 39] = \"NumberMinimum\";\n    ValueErrorType[ValueErrorType[\"NumberMultipleOf\"] = 40] = \"NumberMultipleOf\";\n    ValueErrorType[ValueErrorType[\"Number\"] = 41] = \"Number\";\n    ValueErrorType[ValueErrorType[\"ObjectAdditionalProperties\"] = 42] = \"ObjectAdditionalProperties\";\n    ValueErrorType[ValueErrorType[\"ObjectMaxProperties\"] = 43] = \"ObjectMaxProperties\";\n    ValueErrorType[ValueErrorType[\"ObjectMinProperties\"] = 44] = \"ObjectMinProperties\";\n    ValueErrorType[ValueErrorType[\"ObjectRequiredProperty\"] = 45] = \"ObjectRequiredProperty\";\n    ValueErrorType[ValueErrorType[\"Object\"] = 46] = \"Object\";\n    ValueErrorType[ValueErrorType[\"Promise\"] = 47] = \"Promise\";\n    ValueErrorType[ValueErrorType[\"StringFormatUnknown\"] = 48] = \"StringFormatUnknown\";\n    ValueErrorType[ValueErrorType[\"StringFormat\"] = 49] = \"StringFormat\";\n    ValueErrorType[ValueErrorType[\"StringMaxLength\"] = 50] = \"StringMaxLength\";\n    ValueErrorType[ValueErrorType[\"StringMinLength\"] = 51] = \"StringMinLength\";\n    ValueErrorType[ValueErrorType[\"StringPattern\"] = 52] = \"StringPattern\";\n    ValueErrorType[ValueErrorType[\"String\"] = 53] = \"String\";\n    ValueErrorType[ValueErrorType[\"Symbol\"] = 54] = \"Symbol\";\n    ValueErrorType[ValueErrorType[\"TupleLength\"] = 55] = \"TupleLength\";\n    ValueErrorType[ValueErrorType[\"Tuple\"] = 56] = \"Tuple\";\n    ValueErrorType[ValueErrorType[\"Uint8ArrayMaxByteLength\"] = 57] = \"Uint8ArrayMaxByteLength\";\n    ValueErrorType[ValueErrorType[\"Uint8ArrayMinByteLength\"] = 58] = \"Uint8ArrayMinByteLength\";\n    ValueErrorType[ValueErrorType[\"Uint8Array\"] = 59] = \"Uint8Array\";\n    ValueErrorType[ValueErrorType[\"Undefined\"] = 60] = \"Undefined\";\n    ValueErrorType[ValueErrorType[\"Union\"] = 61] = \"Union\";\n    ValueErrorType[ValueErrorType[\"Void\"] = 62] = \"Void\";\n})(ValueErrorType || (exports.ValueErrorType = ValueErrorType = {}));\n// --------------------------------------------------------------------------\n// ValueErrors\n// --------------------------------------------------------------------------\nclass ValueErrorsUnknownTypeError extends Types.TypeBoxError {\n    constructor(schema) {\n        super('Unknown type');\n        this.schema = schema;\n    }\n}\nexports.ValueErrorsUnknownTypeError = ValueErrorsUnknownTypeError;\n// --------------------------------------------------------------------------\n// EscapeKey\n// --------------------------------------------------------------------------\nfunction EscapeKey(key) {\n    return key.replace(/~/g, '~0').replace(/\\//g, '~1'); // RFC6901 Path\n}\nexports.EscapeKey = EscapeKey;\n// --------------------------------------------------------------------------\n// Guards\n// --------------------------------------------------------------------------\nfunction IsDefined(value) {\n    return value !== undefined;\n}\n// --------------------------------------------------------------------------\n// ValueErrorIterator\n// --------------------------------------------------------------------------\nclass ValueErrorIterator {\n    constructor(iterator) {\n        this.iterator = iterator;\n    }\n    [Symbol.iterator]() {\n        return this.iterator;\n    }\n    /** Returns the first value error or undefined if no errors */\n    First() {\n        const next = this.iterator.next();\n        return next.done ? undefined : next.value;\n    }\n}\nexports.ValueErrorIterator = ValueErrorIterator;\n// --------------------------------------------------------------------------\n// Create\n// --------------------------------------------------------------------------\nfunction Create(type, schema, path, value) {\n    return { type, schema, path, value, message: system_1.TypeSystemErrorFunction.Get()(schema, type) };\n}\n// --------------------------------------------------------------------------\n// Types\n// --------------------------------------------------------------------------\nfunction* TAny(schema, references, path, value) { }\nfunction* TArray(schema, references, path, value) {\n    if (!(0, guard_1.IsArray)(value)) {\n        return yield Create(ValueErrorType.Array, schema, path, value);\n    }\n    if (IsDefined(schema.minItems) && !(value.length >= schema.minItems)) {\n        yield Create(ValueErrorType.ArrayMinItems, schema, path, value);\n    }\n    if (IsDefined(schema.maxItems) && !(value.length <= schema.maxItems)) {\n        yield Create(ValueErrorType.ArrayMaxItems, schema, path, value);\n    }\n    for (let i = 0; i < value.length; i++) {\n        yield* Visit(schema.items, references, `${path}/${i}`, value[i]);\n    }\n    // prettier-ignore\n    if (schema.uniqueItems === true && !((function () { const set = new Set(); for (const element of value) {\n        const hashed = (0, hash_1.Hash)(element);\n        if (set.has(hashed)) {\n            return false;\n        }\n        else {\n            set.add(hashed);\n        }\n    } return true; })())) {\n        yield Create(ValueErrorType.ArrayUniqueItems, schema, path, value);\n    }\n    // contains\n    if (!(IsDefined(schema.contains) || IsDefined(schema.minContains) || IsDefined(schema.maxContains))) {\n        return;\n    }\n    const containsSchema = IsDefined(schema.contains) ? schema.contains : Types.Type.Never();\n    const containsCount = value.reduce((acc, value, index) => (Visit(containsSchema, references, `${path}${index}`, value).next().done === true ? acc + 1 : acc), 0);\n    if (containsCount === 0) {\n        yield Create(ValueErrorType.ArrayContains, schema, path, value);\n    }\n    if ((0, guard_1.IsNumber)(schema.minContains) && containsCount < schema.minContains) {\n        yield Create(ValueErrorType.ArrayMinContains, schema, path, value);\n    }\n    if ((0, guard_1.IsNumber)(schema.maxContains) && containsCount > schema.maxContains) {\n        yield Create(ValueErrorType.ArrayMaxContains, schema, path, value);\n    }\n}\nfunction* TAsyncIterator(schema, references, path, value) {\n    if (!(0, guard_1.IsAsyncIterator)(value))\n        yield Create(ValueErrorType.AsyncIterator, schema, path, value);\n}\nfunction* TBigInt(schema, references, path, value) {\n    if (!(0, guard_1.IsBigInt)(value))\n        return yield Create(ValueErrorType.BigInt, schema, path, value);\n    if (IsDefined(schema.exclusiveMaximum) && !(value < schema.exclusiveMaximum)) {\n        yield Create(ValueErrorType.BigIntExclusiveMaximum, schema, path, value);\n    }\n    if (IsDefined(schema.exclusiveMinimum) && !(value > schema.exclusiveMinimum)) {\n        yield Create(ValueErrorType.BigIntExclusiveMinimum, schema, path, value);\n    }\n    if (IsDefined(schema.maximum) && !(value <= schema.maximum)) {\n        yield Create(ValueErrorType.BigIntMaximum, schema, path, value);\n    }\n    if (IsDefined(schema.minimum) && !(value >= schema.minimum)) {\n        yield Create(ValueErrorType.BigIntMinimum, schema, path, value);\n    }\n    if (IsDefined(schema.multipleOf) && !(value % schema.multipleOf === BigInt(0))) {\n        yield Create(ValueErrorType.BigIntMultipleOf, schema, path, value);\n    }\n}\nfunction* TBoolean(schema, references, path, value) {\n    if (!(0, guard_1.IsBoolean)(value))\n        yield Create(ValueErrorType.Boolean, schema, path, value);\n}\nfunction* TConstructor(schema, references, path, value) {\n    yield* Visit(schema.returns, references, path, value.prototype);\n}\nfunction* TDate(schema, references, path, value) {\n    if (!(0, guard_1.IsDate)(value))\n        return yield Create(ValueErrorType.Date, schema, path, value);\n    if (IsDefined(schema.exclusiveMaximumTimestamp) && !(value.getTime() < schema.exclusiveMaximumTimestamp)) {\n        yield Create(ValueErrorType.DateExclusiveMaximumTimestamp, schema, path, value);\n    }\n    if (IsDefined(schema.exclusiveMinimumTimestamp) && !(value.getTime() > schema.exclusiveMinimumTimestamp)) {\n        yield Create(ValueErrorType.DateExclusiveMinimumTimestamp, schema, path, value);\n    }\n    if (IsDefined(schema.maximumTimestamp) && !(value.getTime() <= schema.maximumTimestamp)) {\n        yield Create(ValueErrorType.DateMaximumTimestamp, schema, path, value);\n    }\n    if (IsDefined(schema.minimumTimestamp) && !(value.getTime() >= schema.minimumTimestamp)) {\n        yield Create(ValueErrorType.DateMinimumTimestamp, schema, path, value);\n    }\n    if (IsDefined(schema.multipleOfTimestamp) && !(value.getTime() % schema.multipleOfTimestamp === 0)) {\n        yield Create(ValueErrorType.DateMultipleOfTimestamp, schema, path, value);\n    }\n}\nfunction* TFunction(schema, references, path, value) {\n    if (!(0, guard_1.IsFunction)(value))\n        yield Create(ValueErrorType.Function, schema, path, value);\n}\nfunction* TInteger(schema, references, path, value) {\n    if (!(0, guard_1.IsInteger)(value))\n        return yield Create(ValueErrorType.Integer, schema, path, value);\n    if (IsDefined(schema.exclusiveMaximum) && !(value < schema.exclusiveMaximum)) {\n        yield Create(ValueErrorType.IntegerExclusiveMaximum, schema, path, value);\n    }\n    if (IsDefined(schema.exclusiveMinimum) && !(value > schema.exclusiveMinimum)) {\n        yield Create(ValueErrorType.IntegerExclusiveMinimum, schema, path, value);\n    }\n    if (IsDefined(schema.maximum) && !(value <= schema.maximum)) {\n        yield Create(ValueErrorType.IntegerMaximum, schema, path, value);\n    }\n    if (IsDefined(schema.minimum) && !(value >= schema.minimum)) {\n        yield Create(ValueErrorType.IntegerMinimum, schema, path, value);\n    }\n    if (IsDefined(schema.multipleOf) && !(value % schema.multipleOf === 0)) {\n        yield Create(ValueErrorType.IntegerMultipleOf, schema, path, value);\n    }\n}\nfunction* TIntersect(schema, references, path, value) {\n    for (const inner of schema.allOf) {\n        const next = Visit(inner, references, path, value).next();\n        if (!next.done) {\n            yield Create(ValueErrorType.Intersect, schema, path, value);\n            yield next.value;\n        }\n    }\n    if (schema.unevaluatedProperties === false) {\n        const keyCheck = new RegExp(Types.KeyResolver.ResolvePattern(schema));\n        for (const valueKey of Object.getOwnPropertyNames(value)) {\n            if (!keyCheck.test(valueKey)) {\n                yield Create(ValueErrorType.IntersectUnevaluatedProperties, schema, `${path}/${valueKey}`, value);\n            }\n        }\n    }\n    if (typeof schema.unevaluatedProperties === 'object') {\n        const keyCheck = new RegExp(Types.KeyResolver.ResolvePattern(schema));\n        for (const valueKey of Object.getOwnPropertyNames(value)) {\n            if (!keyCheck.test(valueKey)) {\n                const next = Visit(schema.unevaluatedProperties, references, `${path}/${valueKey}`, value[valueKey]).next();\n                if (!next.done)\n                    yield next.value; // yield interior\n            }\n        }\n    }\n}\nfunction* TIterator(schema, references, path, value) {\n    if (!(0, guard_1.IsIterator)(value))\n        yield Create(ValueErrorType.Iterator, schema, path, value);\n}\nfunction* TLiteral(schema, references, path, value) {\n    if (!(value === schema.const))\n        yield Create(ValueErrorType.Literal, schema, path, value);\n}\nfunction* TNever(schema, references, path, value) {\n    yield Create(ValueErrorType.Never, schema, path, value);\n}\nfunction* TNot(schema, references, path, value) {\n    if (Visit(schema.not, references, path, value).next().done === true)\n        yield Create(ValueErrorType.Not, schema, path, value);\n}\nfunction* TNull(schema, references, path, value) {\n    if (!(0, guard_1.IsNull)(value))\n        yield Create(ValueErrorType.Null, schema, path, value);\n}\nfunction* TNumber(schema, references, path, value) {\n    if (!system_1.TypeSystemPolicy.IsNumberLike(value))\n        return yield Create(ValueErrorType.Number, schema, path, value);\n    if (IsDefined(schema.exclusiveMaximum) && !(value < schema.exclusiveMaximum)) {\n        yield Create(ValueErrorType.NumberExclusiveMaximum, schema, path, value);\n    }\n    if (IsDefined(schema.exclusiveMinimum) && !(value > schema.exclusiveMinimum)) {\n        yield Create(ValueErrorType.NumberExclusiveMinimum, schema, path, value);\n    }\n    if (IsDefined(schema.maximum) && !(value <= schema.maximum)) {\n        yield Create(ValueErrorType.NumberMaximum, schema, path, value);\n    }\n    if (IsDefined(schema.minimum) && !(value >= schema.minimum)) {\n        yield Create(ValueErrorType.NumberMinimum, schema, path, value);\n    }\n    if (IsDefined(schema.multipleOf) && !(value % schema.multipleOf === 0)) {\n        yield Create(ValueErrorType.NumberMultipleOf, schema, path, value);\n    }\n}\nfunction* TObject(schema, references, path, value) {\n    if (!system_1.TypeSystemPolicy.IsObjectLike(value))\n        return yield Create(ValueErrorType.Object, schema, path, value);\n    if (IsDefined(schema.minProperties) && !(Object.getOwnPropertyNames(value).length >= schema.minProperties)) {\n        yield Create(ValueErrorType.ObjectMinProperties, schema, path, value);\n    }\n    if (IsDefined(schema.maxProperties) && !(Object.getOwnPropertyNames(value).length <= schema.maxProperties)) {\n        yield Create(ValueErrorType.ObjectMaxProperties, schema, path, value);\n    }\n    const requiredKeys = Array.isArray(schema.required) ? schema.required : [];\n    const knownKeys = Object.getOwnPropertyNames(schema.properties);\n    const unknownKeys = Object.getOwnPropertyNames(value);\n    for (const requiredKey of requiredKeys) {\n        if (unknownKeys.includes(requiredKey))\n            continue;\n        yield Create(ValueErrorType.ObjectRequiredProperty, schema.properties[requiredKey], `${path}/${EscapeKey(requiredKey)}`, undefined);\n    }\n    if (schema.additionalProperties === false) {\n        for (const valueKey of unknownKeys) {\n            if (!knownKeys.includes(valueKey)) {\n                yield Create(ValueErrorType.ObjectAdditionalProperties, schema, `${path}/${EscapeKey(valueKey)}`, value[valueKey]);\n            }\n        }\n    }\n    if (typeof schema.additionalProperties === 'object') {\n        for (const valueKey of unknownKeys) {\n            if (knownKeys.includes(valueKey))\n                continue;\n            yield* Visit(schema.additionalProperties, references, `${path}/${EscapeKey(valueKey)}`, value[valueKey]);\n        }\n    }\n    for (const knownKey of knownKeys) {\n        const property = schema.properties[knownKey];\n        if (schema.required && schema.required.includes(knownKey)) {\n            yield* Visit(property, references, `${path}/${EscapeKey(knownKey)}`, value[knownKey]);\n            if (Types.ExtendsUndefined.Check(schema) && !(knownKey in value)) {\n                yield Create(ValueErrorType.ObjectRequiredProperty, property, `${path}/${EscapeKey(knownKey)}`, undefined);\n            }\n        }\n        else {\n            if (system_1.TypeSystemPolicy.IsExactOptionalProperty(value, knownKey)) {\n                yield* Visit(property, references, `${path}/${EscapeKey(knownKey)}`, value[knownKey]);\n            }\n        }\n    }\n}\nfunction* TPromise(schema, references, path, value) {\n    if (!(0, guard_1.IsPromise)(value))\n        yield Create(ValueErrorType.Promise, schema, path, value);\n}\nfunction* TRecord(schema, references, path, value) {\n    if (!system_1.TypeSystemPolicy.IsRecordLike(value))\n        return yield Create(ValueErrorType.Object, schema, path, value);\n    if (IsDefined(schema.minProperties) && !(Object.getOwnPropertyNames(value).length >= schema.minProperties)) {\n        yield Create(ValueErrorType.ObjectMinProperties, schema, path, value);\n    }\n    if (IsDefined(schema.maxProperties) && !(Object.getOwnPropertyNames(value).length <= schema.maxProperties)) {\n        yield Create(ValueErrorType.ObjectMaxProperties, schema, path, value);\n    }\n    const [patternKey, patternSchema] = Object.entries(schema.patternProperties)[0];\n    const regex = new RegExp(patternKey);\n    for (const [propertyKey, propertyValue] of Object.entries(value)) {\n        if (regex.test(propertyKey))\n            yield* Visit(patternSchema, references, `${path}/${EscapeKey(propertyKey)}`, propertyValue);\n    }\n    if (typeof schema.additionalProperties === 'object') {\n        for (const [propertyKey, propertyValue] of Object.entries(value)) {\n            if (!regex.test(propertyKey))\n                yield* Visit(schema.additionalProperties, references, `${path}/${EscapeKey(propertyKey)}`, propertyValue);\n        }\n    }\n    if (schema.additionalProperties === false) {\n        for (const [propertyKey, propertyValue] of Object.entries(value)) {\n            if (regex.test(propertyKey))\n                continue;\n            return yield Create(ValueErrorType.ObjectAdditionalProperties, schema, `${path}/${EscapeKey(propertyKey)}`, propertyValue);\n        }\n    }\n}\nfunction* TRef(schema, references, path, value) {\n    yield* Visit((0, deref_1.Deref)(schema, references), references, path, value);\n}\nfunction* TString(schema, references, path, value) {\n    if (!(0, guard_1.IsString)(value))\n        return yield Create(ValueErrorType.String, schema, path, value);\n    if (IsDefined(schema.minLength) && !(value.length >= schema.minLength)) {\n        yield Create(ValueErrorType.StringMinLength, schema, path, value);\n    }\n    if (IsDefined(schema.maxLength) && !(value.length <= schema.maxLength)) {\n        yield Create(ValueErrorType.StringMaxLength, schema, path, value);\n    }\n    if ((0, guard_1.IsString)(schema.pattern)) {\n        const regex = new RegExp(schema.pattern);\n        if (!regex.test(value)) {\n            yield Create(ValueErrorType.StringPattern, schema, path, value);\n        }\n    }\n    if ((0, guard_1.IsString)(schema.format)) {\n        if (!Types.FormatRegistry.Has(schema.format)) {\n            yield Create(ValueErrorType.StringFormatUnknown, schema, path, value);\n        }\n        else {\n            const format = Types.FormatRegistry.Get(schema.format);\n            if (!format(value)) {\n                yield Create(ValueErrorType.StringFormat, schema, path, value);\n            }\n        }\n    }\n}\nfunction* TSymbol(schema, references, path, value) {\n    if (!(0, guard_1.IsSymbol)(value))\n        yield Create(ValueErrorType.Symbol, schema, path, value);\n}\nfunction* TTemplateLiteral(schema, references, path, value) {\n    if (!(0, guard_1.IsString)(value))\n        return yield Create(ValueErrorType.String, schema, path, value);\n    const regex = new RegExp(schema.pattern);\n    if (!regex.test(value)) {\n        yield Create(ValueErrorType.StringPattern, schema, path, value);\n    }\n}\nfunction* TThis(schema, references, path, value) {\n    yield* Visit((0, deref_1.Deref)(schema, references), references, path, value);\n}\nfunction* TTuple(schema, references, path, value) {\n    if (!(0, guard_1.IsArray)(value))\n        return yield Create(ValueErrorType.Tuple, schema, path, value);\n    if (schema.items === undefined && !(value.length === 0)) {\n        return yield Create(ValueErrorType.TupleLength, schema, path, value);\n    }\n    if (!(value.length === schema.maxItems)) {\n        return yield Create(ValueErrorType.TupleLength, schema, path, value);\n    }\n    if (!schema.items) {\n        return;\n    }\n    for (let i = 0; i < schema.items.length; i++) {\n        yield* Visit(schema.items[i], references, `${path}/${i}`, value[i]);\n    }\n}\nfunction* TUndefined(schema, references, path, value) {\n    if (!(0, guard_1.IsUndefined)(value))\n        yield Create(ValueErrorType.Undefined, schema, path, value);\n}\nfunction* TUnion(schema, references, path, value) {\n    let count = 0;\n    for (const subschema of schema.anyOf) {\n        const errors = [...Visit(subschema, references, path, value)];\n        if (errors.length === 0)\n            return; // matched\n        count += errors.length;\n    }\n    if (count > 0) {\n        yield Create(ValueErrorType.Union, schema, path, value);\n    }\n}\nfunction* TUint8Array(schema, references, path, value) {\n    if (!(0, guard_1.IsUint8Array)(value))\n        return yield Create(ValueErrorType.Uint8Array, schema, path, value);\n    if (IsDefined(schema.maxByteLength) && !(value.length <= schema.maxByteLength)) {\n        yield Create(ValueErrorType.Uint8ArrayMaxByteLength, schema, path, value);\n    }\n    if (IsDefined(schema.minByteLength) && !(value.length >= schema.minByteLength)) {\n        yield Create(ValueErrorType.Uint8ArrayMinByteLength, schema, path, value);\n    }\n}\nfunction* TUnknown(schema, references, path, value) { }\nfunction* TVoid(schema, references, path, value) {\n    if (!system_1.TypeSystemPolicy.IsVoidLike(value))\n        yield Create(ValueErrorType.Void, schema, path, value);\n}\nfunction* TKind(schema, references, path, value) {\n    const check = Types.TypeRegistry.Get(schema[Types.Kind]);\n    if (!check(schema, value))\n        yield Create(ValueErrorType.Kind, schema, path, value);\n}\nfunction* Visit(schema, references, path, value) {\n    const references_ = IsDefined(schema.$id) ? [...references, schema] : references;\n    const schema_ = schema;\n    switch (schema_[Types.Kind]) {\n        case 'Any':\n            return yield* TAny(schema_, references_, path, value);\n        case 'Array':\n            return yield* TArray(schema_, references_, path, value);\n        case 'AsyncIterator':\n            return yield* TAsyncIterator(schema_, references_, path, value);\n        case 'BigInt':\n            return yield* TBigInt(schema_, references_, path, value);\n        case 'Boolean':\n            return yield* TBoolean(schema_, references_, path, value);\n        case 'Constructor':\n            return yield* TConstructor(schema_, references_, path, value);\n        case 'Date':\n            return yield* TDate(schema_, references_, path, value);\n        case 'Function':\n            return yield* TFunction(schema_, references_, path, value);\n        case 'Integer':\n            return yield* TInteger(schema_, references_, path, value);\n        case 'Intersect':\n            return yield* TIntersect(schema_, references_, path, value);\n        case 'Iterator':\n            return yield* TIterator(schema_, references_, path, value);\n        case 'Literal':\n            return yield* TLiteral(schema_, references_, path, value);\n        case 'Never':\n            return yield* TNever(schema_, references_, path, value);\n        case 'Not':\n            return yield* TNot(schema_, references_, path, value);\n        case 'Null':\n            return yield* TNull(schema_, references_, path, value);\n        case 'Number':\n            return yield* TNumber(schema_, references_, path, value);\n        case 'Object':\n            return yield* TObject(schema_, references_, path, value);\n        case 'Promise':\n            return yield* TPromise(schema_, references_, path, value);\n        case 'Record':\n            return yield* TRecord(schema_, references_, path, value);\n        case 'Ref':\n            return yield* TRef(schema_, references_, path, value);\n        case 'String':\n            return yield* TString(schema_, references_, path, value);\n        case 'Symbol':\n            return yield* TSymbol(schema_, references_, path, value);\n        case 'TemplateLiteral':\n            return yield* TTemplateLiteral(schema_, references_, path, value);\n        case 'This':\n            return yield* TThis(schema_, references_, path, value);\n        case 'Tuple':\n            return yield* TTuple(schema_, references_, path, value);\n        case 'Undefined':\n            return yield* TUndefined(schema_, references_, path, value);\n        case 'Union':\n            return yield* TUnion(schema_, references_, path, value);\n        case 'Uint8Array':\n            return yield* TUint8Array(schema_, references_, path, value);\n        case 'Unknown':\n            return yield* TUnknown(schema_, references_, path, value);\n        case 'Void':\n            return yield* TVoid(schema_, references_, path, value);\n        default:\n            if (!Types.TypeRegistry.Has(schema_[Types.Kind]))\n                throw new ValueErrorsUnknownTypeError(schema);\n            return yield* TKind(schema_, references_, path, value);\n    }\n}\n/** Returns an iterator for each error in this value. */\nfunction Errors(...args) {\n    const iterator = args.length === 3 ? Visit(args[0], args[1], '', args[2]) : Visit(args[0], [], '', args[1]);\n    return new ValueErrorIterator(iterator);\n}\nexports.Errors = Errors;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}