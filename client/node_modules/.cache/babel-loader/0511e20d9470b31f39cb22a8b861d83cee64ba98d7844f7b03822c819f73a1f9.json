{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nconst fountainDecoder_1 = __importDefault(require(\"./fountainDecoder\"));\nconst bytewords_1 = __importDefault(require(\"./bytewords\"));\nconst assert_1 = __importDefault(require(\"assert\"));\nconst utils_1 = require(\"./utils\");\nconst errors_1 = require(\"./errors\");\nconst ur_1 = __importDefault(require(\"./ur\"));\nconst fountainEncoder_1 = require(\"./fountainEncoder\");\nclass URDecoder {\n  constructor() {\n    let fountainDecoder = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new fountainDecoder_1.default();\n    let type = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'bytes';\n    this.fountainDecoder = fountainDecoder;\n    this.type = type;\n    assert_1.default(utils_1.isURType(type), 'Invalid UR type');\n    this.expected_type = '';\n  }\n  static decodeBody(type, message) {\n    const cbor = bytewords_1.default.decode(message, bytewords_1.default.STYLES.MINIMAL);\n    return new ur_1.default(Buffer.from(cbor, 'hex'), type);\n  }\n  validatePart(type) {\n    if (this.expected_type) {\n      return this.expected_type === type;\n    }\n    if (!utils_1.isURType(type)) {\n      return false;\n    }\n    this.expected_type = type;\n    return true;\n  }\n  static decode(message) {\n    const [type, components] = this.parse(message);\n    if (components.length === 0) {\n      throw new errors_1.InvalidPathLengthError();\n    }\n    const body = components[0];\n    return URDecoder.decodeBody(type, body);\n  }\n  static parse(message) {\n    const lowercase = message.toLowerCase();\n    const prefix = lowercase.slice(0, 3);\n    if (prefix !== 'ur:') {\n      throw new errors_1.InvalidSchemeError();\n    }\n    const components = lowercase.slice(3).split('/');\n    const type = components[0];\n    if (components.length < 2) {\n      throw new errors_1.InvalidPathLengthError();\n    }\n    if (!utils_1.isURType(type)) {\n      throw new errors_1.InvalidTypeError();\n    }\n    return [type, components.slice(1)];\n  }\n  static parseSequenceComponent(s) {\n    const components = s.split('-');\n    if (components.length !== 2) {\n      throw new errors_1.InvalidSequenceComponentError();\n    }\n    const seqNum = utils_1.toUint32(Number(components[0]));\n    const seqLength = Number(components[1]);\n    if (seqNum < 1 || seqLength < 1) {\n      throw new errors_1.InvalidSequenceComponentError();\n    }\n    return [seqNum, seqLength];\n  }\n  receivePart(s) {\n    if (this.result !== undefined) {\n      return false;\n    }\n    const [type, components] = URDecoder.parse(s);\n    if (!this.validatePart(type)) {\n      return false;\n    }\n    // If this is a single-part UR then we're done\n    if (components.length === 1) {\n      this.result = URDecoder.decodeBody(type, components[0]);\n      return true;\n    }\n    if (components.length !== 2) {\n      throw new errors_1.InvalidPathLengthError();\n    }\n    const [seq, fragment] = components;\n    const [seqNum, seqLength] = URDecoder.parseSequenceComponent(seq);\n    const cbor = bytewords_1.default.decode(fragment, bytewords_1.default.STYLES.MINIMAL);\n    const part = fountainEncoder_1.FountainEncoderPart.fromCBOR(cbor);\n    if (seqNum !== part.seqNum || seqLength !== part.seqLength) {\n      return false;\n    }\n    if (!this.fountainDecoder.receivePart(part)) {\n      return false;\n    }\n    if (this.fountainDecoder.isSuccess()) {\n      this.result = new ur_1.default(this.fountainDecoder.resultMessage(), type);\n    } else if (this.fountainDecoder.isFailure()) {\n      this.error = new errors_1.InvalidSchemeError();\n    }\n    return true;\n  }\n  resultUR() {\n    return this.result ? this.result : new ur_1.default(Buffer.from([]));\n  }\n  isComplete() {\n    return this.result && this.result.cbor.length > 0;\n  }\n  isSuccess() {\n    return !this.error && this.isComplete();\n  }\n  isError() {\n    return this.error !== undefined;\n  }\n  resultError() {\n    return this.error ? this.error.message : '';\n  }\n  expectedPartCount() {\n    return this.fountainDecoder.expectedPartCount();\n  }\n  expectedPartIndexes() {\n    return this.fountainDecoder.getExpectedPartIndexes();\n  }\n  receivedPartIndexes() {\n    return this.fountainDecoder.getReceivedPartIndexes();\n  }\n  lastPartIndexes() {\n    return this.fountainDecoder.getLastPartIndexes();\n  }\n  estimatedPercentComplete() {\n    return this.fountainDecoder.estimatedPercentComplete();\n  }\n  getProgress() {\n    return this.fountainDecoder.getProgress();\n  }\n}\nexports.default = URDecoder;","map":{"version":3,"names":["fountainDecoder_1","__importDefault","require","bytewords_1","assert_1","utils_1","errors_1","ur_1","fountainEncoder_1","URDecoder","constructor","fountainDecoder","arguments","length","undefined","default","type","isURType","expected_type","decodeBody","message","cbor","decode","STYLES","MINIMAL","Buffer","from","validatePart","components","parse","InvalidPathLengthError","body","lowercase","toLowerCase","prefix","slice","InvalidSchemeError","split","InvalidTypeError","parseSequenceComponent","s","InvalidSequenceComponentError","seqNum","toUint32","Number","seqLength","receivePart","result","seq","fragment","part","FountainEncoderPart","fromCBOR","isSuccess","resultMessage","isFailure","error","resultUR","isComplete","isError","resultError","expectedPartCount","expectedPartIndexes","getExpectedPartIndexes","receivedPartIndexes","getReceivedPartIndexes","lastPartIndexes","getLastPartIndexes","estimatedPercentComplete","getProgress","exports"],"sources":["C:\\Users\\Administrator\\solana-wallet-app\\node_modules\\@ngraveio\\bc-ur\\src\\urDecoder.ts"],"sourcesContent":["import FountainDecoder from './fountainDecoder';\nimport bytewords from './bytewords';\nimport assert from 'assert';\nimport { isURType, toUint32 } from './utils';\nimport { InvalidSchemeError, InvalidPathLengthError, InvalidTypeError, InvalidSequenceComponentError } from './errors';\nimport UR from './ur';\nimport { FountainEncoderPart } from './fountainEncoder';\n\nexport default class URDecoder {\n  private expected_type: string;\n  private result: UR | undefined;\n  private error: Error | undefined;\n\n  constructor(\n    private fountainDecoder: FountainDecoder = new FountainDecoder(),\n    public type: string = 'bytes'\n  ) {\n    assert(isURType(type), 'Invalid UR type');\n\n    this.expected_type = '';\n  }\n\n  private static decodeBody(type: string, message: string): UR {\n    const cbor = bytewords.decode(message, bytewords.STYLES.MINIMAL);\n\n    return new UR(Buffer.from(cbor, 'hex'), type);\n  }\n\n  private validatePart(type: string): boolean {\n    if (this.expected_type) {\n      return this.expected_type === type;\n    }\n\n    if (!isURType(type)) {\n      return false;\n    }\n\n    this.expected_type = type;\n\n    return true;\n  }\n\n  public static decode(message: string): UR {\n    const [type, components] = this.parse(message);\n\n    if (components.length === 0) {\n      throw new InvalidPathLengthError();\n    }\n\n    const body = components[0];\n\n    return URDecoder.decodeBody(type, body);\n  }\n\n  public static parse(message: string): [string, string[]] {\n    const lowercase = message.toLowerCase();\n    const prefix = lowercase.slice(0, 3);\n\n    if (prefix !== 'ur:') {\n      throw new InvalidSchemeError();\n    }\n\n    const components = lowercase.slice(3).split('/')\n    const type = components[0];\n\n    if (components.length < 2) {\n      throw new InvalidPathLengthError();\n    }\n\n    if (!isURType(type)) {\n      throw new InvalidTypeError();\n    }\n\n    return [type, components.slice(1)]\n  }\n\n  public static parseSequenceComponent(s: string) {\n    const components = s.split('-');\n\n    if (components.length !== 2) {\n      throw new InvalidSequenceComponentError();\n    }\n\n    const seqNum = toUint32(Number(components[0]));\n    const seqLength = Number(components[1]);\n\n    if (seqNum < 1 || seqLength < 1) {\n      throw new InvalidSequenceComponentError();\n    }\n\n    return [seqNum, seqLength];\n  }\n\n  public receivePart(s: string): boolean {\n    if (this.result !== undefined) {\n      return false;\n    }\n\n    const [type, components] = URDecoder.parse(s)\n\n    if (!this.validatePart(type)) {\n      return false;\n    }\n\n    // If this is a single-part UR then we're done\n    if (components.length === 1) {\n      this.result = URDecoder.decodeBody(type, components[0])\n\n      return true;\n    }\n\n    if (components.length !== 2) {\n      throw new InvalidPathLengthError();\n    }\n\n    const [seq, fragment] = components;\n    const [seqNum, seqLength] = URDecoder.parseSequenceComponent(seq);\n    const cbor = bytewords.decode(fragment, bytewords.STYLES.MINIMAL);\n    const part = FountainEncoderPart.fromCBOR(cbor);\n\n    if (seqNum !== part.seqNum || seqLength !== part.seqLength) {\n      return false;\n    }\n\n    if (!this.fountainDecoder.receivePart(part)) {\n      return false;\n    }\n\n    if (this.fountainDecoder.isSuccess()) {\n      this.result = new UR(this.fountainDecoder.resultMessage(), type);\n    }\n    else if (this.fountainDecoder.isFailure()) {\n      this.error = new InvalidSchemeError();\n    }\n\n    return true;\n  }\n\n  public resultUR(): UR {\n    return this.result ? this.result : new UR(Buffer.from([]));\n  }\n\n  public isComplete(): boolean {\n    return this.result && this.result.cbor.length > 0;\n  }\n\n  public isSuccess(): boolean {\n    return !this.error && this.isComplete();\n  }\n\n  public isError(): boolean {\n    return this.error !== undefined;\n  }\n\n  public resultError() {\n    return this.error ? this.error.message : '';\n  }\n\n  public expectedPartCount() {\n    return this.fountainDecoder.expectedPartCount();\n  }\n\n  public expectedPartIndexes() {\n    return this.fountainDecoder.getExpectedPartIndexes();\n  }\n\n  public receivedPartIndexes() {\n    return this.fountainDecoder.getReceivedPartIndexes();\n  }\n\n  public lastPartIndexes() {\n    return this.fountainDecoder.getLastPartIndexes();\n  }\n\n  public estimatedPercentComplete() {\n    return this.fountainDecoder.estimatedPercentComplete();\n  }\n\n  public getProgress() {\n    return this.fountainDecoder.getProgress();\n  }\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}