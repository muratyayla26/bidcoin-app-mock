{"ast":null,"code":"\"use strict\";\n\n/**\n * Ported to Typescript from original implementation below:\n * https://github.com/ahultgren/async-eventemitter -- MIT licensed\n *\n * Type Definitions based on work by: patarapolw <https://github.com/patarapolw> -- MIT licensed\n * that was contributed to Definitely Typed below:\n * https://github.com/DefinitelyTyped/DefinitelyTyped/tree/master/types/async-eventemitter\n */\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.AsyncEventEmitter = void 0;\nconst events_1 = require(\"events\");\nasync function runInSeries(context, tasks, data) {\n  let error;\n  for await (const task of tasks) {\n    try {\n      if (task.length < 2) {\n        //sync\n        task.call(context, data);\n      } else {\n        await new Promise((resolve, reject) => {\n          task.call(context, data, error => {\n            if (error) {\n              reject(error);\n            } else {\n              resolve();\n            }\n          });\n        });\n      }\n    } catch (e) {\n      error = e;\n    }\n  }\n  if (error) {\n    throw error;\n  }\n}\nclass AsyncEventEmitter extends events_1.EventEmitter {\n  emit(event) {\n    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      args[_key - 1] = arguments[_key];\n    }\n    let [data, callback] = args;\n    const self = this;\n    let listeners = self._events[event] ?? [];\n    // Optional data argument\n    if (callback === undefined && typeof data === 'function') {\n      callback = data;\n      data = undefined;\n    }\n    // Special treatment of internal newListener and removeListener events\n    if (event === 'newListener' || event === 'removeListener') {\n      data = {\n        event: data,\n        fn: callback\n      };\n      callback = undefined;\n    }\n    // A single listener is just a function not an array...\n    listeners = Array.isArray(listeners) ? listeners : [listeners];\n    runInSeries(self, listeners.slice(), data).then(callback).catch(callback);\n    return self.listenerCount(event) > 0;\n  }\n  once(event, listener) {\n    const self = this;\n    let g;\n    if (typeof listener !== 'function') {\n      throw new TypeError('listener must be a function');\n    }\n    // Hack to support set arity\n    if (listener.length >= 2) {\n      g = function (e, next) {\n        self.removeListener(event, g);\n        void listener(e, next);\n      };\n    } else {\n      g = function (e) {\n        self.removeListener(event, g);\n        void listener(e, g);\n      };\n    }\n    self.on(event, g);\n    return self;\n  }\n  first(event, listener) {\n    let listeners = this._events[event] ?? [];\n    // Contract\n    if (typeof listener !== 'function') {\n      throw new TypeError('listener must be a function');\n    }\n    // Listeners are not always an array\n    if (!Array.isArray(listeners)) {\n      ;\n      this._events[event] = listeners = [listeners];\n    }\n    listeners.unshift(listener);\n    return this;\n  }\n  before(event, target, listener) {\n    return this.beforeOrAfter(event, target, listener);\n  }\n  after(event, target, listener) {\n    return this.beforeOrAfter(event, target, listener, 'after');\n  }\n  beforeOrAfter(event, target, listener, beforeOrAfter) {\n    let listeners = this._events[event] ?? [];\n    let i;\n    let index;\n    const add = beforeOrAfter === 'after' ? 1 : 0;\n    // Contract\n    if (typeof listener !== 'function') {\n      throw new TypeError('listener must be a function');\n    }\n    if (typeof target !== 'function') {\n      throw new TypeError('target must be a function');\n    }\n    // Listeners are not always an array\n    if (!Array.isArray(listeners)) {\n      ;\n      this._events[event] = listeners = [listeners];\n    }\n    index = listeners.length;\n    for (i = listeners.length; i--;) {\n      if (listeners[i] === target) {\n        index = i + add;\n        break;\n      }\n    }\n    listeners.splice(index, 0, listener);\n    return this;\n  }\n  on(event, listener) {\n    return super.on(event, listener);\n  }\n  addListener(event, listener) {\n    return super.addListener(event, listener);\n  }\n  prependListener(event, listener) {\n    return super.prependListener(event, listener);\n  }\n  prependOnceListener(event, listener) {\n    return super.prependOnceListener(event, listener);\n  }\n  removeAllListeners(event) {\n    return super.removeAllListeners(event);\n  }\n  removeListener(event, listener) {\n    return super.removeListener(event, listener);\n  }\n  eventNames() {\n    return super.eventNames();\n  }\n  listeners(event) {\n    return super.listeners(event);\n  }\n  listenerCount(event) {\n    return super.listenerCount(event);\n  }\n  getMaxListeners() {\n    return super.getMaxListeners();\n  }\n  setMaxListeners(maxListeners) {\n    return super.setMaxListeners(maxListeners);\n  }\n}\nexports.AsyncEventEmitter = AsyncEventEmitter;","map":{"version":3,"names":["events_1","require","runInSeries","context","tasks","data","error","task","length","call","Promise","resolve","reject","e","AsyncEventEmitter","EventEmitter","emit","event","_len","arguments","args","Array","_key","callback","self","listeners","_events","undefined","fn","isArray","slice","then","catch","listenerCount","once","listener","g","TypeError","next","removeListener","on","first","unshift","before","target","beforeOrAfter","after","i","index","add","splice","addListener","prependListener","prependOnceListener","removeAllListeners","eventNames","getMaxListeners","setMaxListeners","maxListeners","exports"],"sources":["C:\\Users\\Administrator\\solana-wallet-app\\node_modules\\@ethereumjs\\util\\src\\asyncEventEmitter.ts"],"sourcesContent":["/**\n * Ported to Typescript from original implementation below:\n * https://github.com/ahultgren/async-eventemitter -- MIT licensed\n *\n * Type Definitions based on work by: patarapolw <https://github.com/patarapolw> -- MIT licensed\n * that was contributed to Definitely Typed below:\n * https://github.com/DefinitelyTyped/DefinitelyTyped/tree/master/types/async-eventemitter\n */\n\nimport { EventEmitter } from 'events'\ntype AsyncListener<T, R> =\n  | ((data: T, callback?: (result?: R) => void) => Promise<R>)\n  | ((data: T, callback?: (result?: R) => void) => void)\nexport interface EventMap {\n  [event: string]: AsyncListener<any, any>\n}\n\nasync function runInSeries(\n  context: any,\n  tasks: Array<(data: unknown, callback?: (error?: Error) => void) => void>,\n  data: unknown\n): Promise<void> {\n  let error: Error | undefined\n  for await (const task of tasks) {\n    try {\n      if (task.length < 2) {\n        //sync\n        task.call(context, data)\n      } else {\n        await new Promise<void>((resolve, reject) => {\n          task.call(context, data, (error) => {\n            if (error) {\n              reject(error)\n            } else {\n              resolve()\n            }\n          })\n        })\n      }\n    } catch (e: unknown) {\n      error = e as Error\n    }\n  }\n  if (error) {\n    throw error\n  }\n}\n\nexport class AsyncEventEmitter<T extends EventMap> extends EventEmitter {\n  emit<E extends keyof T>(event: E & string, ...args: Parameters<T[E]>) {\n    let [data, callback] = args\n    const self = this\n\n    let listeners = (self as any)._events[event] ?? []\n\n    // Optional data argument\n    if (callback === undefined && typeof data === 'function') {\n      callback = data\n      data = undefined\n    }\n\n    // Special treatment of internal newListener and removeListener events\n    if (event === 'newListener' || event === 'removeListener') {\n      data = {\n        event: data,\n        fn: callback,\n      }\n\n      callback = undefined\n    }\n\n    // A single listener is just a function not an array...\n    listeners = Array.isArray(listeners) ? listeners : [listeners]\n    runInSeries(self, listeners.slice(), data).then(callback).catch(callback)\n\n    return self.listenerCount(event) > 0\n  }\n\n  once<E extends keyof T>(event: E & string, listener: T[E]): this {\n    const self = this\n    let g: (...args: any[]) => void\n\n    if (typeof listener !== 'function') {\n      throw new TypeError('listener must be a function')\n    }\n\n    // Hack to support set arity\n    if (listener.length >= 2) {\n      g = function (e: E, next: any) {\n        self.removeListener(event, g as T[E])\n        void listener(e, next)\n      }\n    } else {\n      g = function (e: E) {\n        self.removeListener(event, g as T[E])\n        void listener(e, g)\n      }\n    }\n\n    self.on(event, g as T[E])\n\n    return self\n  }\n\n  first<E extends keyof T>(event: E & string, listener: T[E]): this {\n    let listeners = (this as any)._events[event] ?? []\n\n    // Contract\n    if (typeof listener !== 'function') {\n      throw new TypeError('listener must be a function')\n    }\n\n    // Listeners are not always an array\n    if (!Array.isArray(listeners)) {\n      ;(this as any)._events[event] = listeners = [listeners]\n    }\n\n    listeners.unshift(listener)\n\n    return this\n  }\n\n  before<E extends keyof T>(event: E & string, target: T[E], listener: T[E]): this {\n    return this.beforeOrAfter(event, target, listener)\n  }\n\n  after<E extends keyof T>(event: E & string, target: T[E], listener: T[E]): this {\n    return this.beforeOrAfter(event, target, listener, 'after')\n  }\n\n  private beforeOrAfter<E extends keyof T>(\n    event: E & string,\n    target: T[E],\n    listener: T[E],\n    beforeOrAfter?: string\n  ) {\n    let listeners = (this as any)._events[event] ?? []\n    let i\n    let index\n    const add = beforeOrAfter === 'after' ? 1 : 0\n\n    // Contract\n    if (typeof listener !== 'function') {\n      throw new TypeError('listener must be a function')\n    }\n    if (typeof target !== 'function') {\n      throw new TypeError('target must be a function')\n    }\n\n    // Listeners are not always an array\n    if (!Array.isArray(listeners)) {\n      ;(this as any)._events[event] = listeners = [listeners]\n    }\n\n    index = listeners.length\n\n    for (i = listeners.length; i--; ) {\n      if (listeners[i] === target) {\n        index = i + add\n        break\n      }\n    }\n\n    listeners.splice(index, 0, listener)\n\n    return this\n  }\n\n  on<E extends keyof T>(event: E & string, listener: T[E]): this {\n    return super.on(event, listener)\n  }\n\n  addListener<E extends keyof T>(event: E & string, listener: T[E]): this {\n    return super.addListener(event, listener)\n  }\n\n  prependListener<E extends keyof T>(event: E & string, listener: T[E]): this {\n    return super.prependListener(event, listener)\n  }\n\n  prependOnceListener<E extends keyof T>(event: E & string, listener: T[E]): this {\n    return super.prependOnceListener(event, listener)\n  }\n\n  removeAllListeners(event?: keyof T & string): this {\n    return super.removeAllListeners(event)\n  }\n\n  removeListener<E extends keyof T>(event: E & string, listener: T[E]): this {\n    return super.removeListener(event, listener)\n  }\n\n  eventNames(): Array<keyof T & string> {\n    return super.eventNames() as keyof T & string[]\n  }\n\n  listeners<E extends keyof T>(event: E & string): Array<T[E]> {\n    return super.listeners(event) as T[E][]\n  }\n\n  listenerCount(event: keyof T & string): number {\n    return super.listenerCount(event)\n  }\n\n  getMaxListeners(): number {\n    return super.getMaxListeners()\n  }\n\n  setMaxListeners(maxListeners: number): this {\n    return super.setMaxListeners(maxListeners)\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}