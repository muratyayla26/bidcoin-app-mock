{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: !0\n});\nvar t = require(\"@keystonehq/bc-ur-registry\"),\n  e = require(\"uuid\");\nconst s = {\n    SOL_SIGN_REQUEST: new t.RegistryType(\"sol-sign-request\", 1101),\n    SOL_SIGNATURE: new t.RegistryType(\"sol-signature\", 1102),\n    SOL_NFT_ITEM: new t.RegistryType(\"sol-nft-item\", 1104)\n  },\n  {\n    decodeToDataItem: i,\n    RegistryTypes: a\n  } = t.extend;\nvar r, n;\n(r = exports.SignType || (exports.SignType = {}))[r.Transaction = 1] = \"Transaction\", r[r.Message = 2] = \"Message\", function (t) {\n  t[t.requestId = 1] = \"requestId\", t[t.signData = 2] = \"signData\", t[t.derivationPath = 3] = \"derivationPath\", t[t.address = 4] = \"address\", t[t.origin = 5] = \"origin\", t[t.signType = 6] = \"signType\";\n}(n || (n = {}));\nclass o extends t.RegistryItem {\n  constructor(e) {\n    super(), this.getRegistryType = () => s.SOL_SIGN_REQUEST, this.getRequestId = () => this.requestId, this.getSignData = () => this.signData, this.getDerivationPath = () => this.derivationPath.getPath(), this.getSignRequestAddress = () => this.address, this.getOrigin = () => this.origin, this.getSignType = () => this.signType, this.toDataItem = () => {\n      const e = {};\n      this.requestId && (e[n.requestId] = new t.DataItem(this.requestId, a.UUID.getTag())), this.address && (e[n.address] = this.address), this.origin && (e[n.origin] = this.origin), e[n.signData] = this.signData, e[n.signType] = this.signType;\n      const s = this.derivationPath.toDataItem();\n      return s.setTag(this.derivationPath.getRegistryType().getTag()), e[n.derivationPath] = s, new t.DataItem(e);\n    }, this.requestId = e.requestId, this.signData = e.signData, this.derivationPath = e.derivationPath, this.address = e.address, this.origin = e.origin, this.signType = e.signType;\n  }\n  static constructSOLRequest(s, i, a, r, n, d, g) {\n    const m = i.replace(/[m|M]\\//, \"\").split(\"/\"),\n      h = new t.CryptoKeypath(m.map(e => {\n        const s = parseInt(e.replace(\"'\", \"\"));\n        let i = !1;\n        return e.endsWith(\"'\") && (i = !0), new t.PathComponent({\n          index: s,\n          hardened: i\n        });\n      }), Buffer.from(a, \"hex\"));\n    return new o({\n      requestId: n ? Buffer.from(e.parse(n)) : void 0,\n      signData: s,\n      derivationPath: h,\n      address: d ? Buffer.from(d.replace(\"0x\", \"\"), \"hex\") : void 0,\n      origin: g || void 0,\n      signType: r\n    });\n  }\n}\no.fromDataItem = e => {\n  const s = e.getData(),\n    i = s[n.signData],\n    a = t.CryptoKeypath.fromDataItem(s[n.derivationPath]),\n    r = s[n.address] ? s[n.address] : void 0,\n    d = s[n.requestId] ? s[n.requestId].getData() : void 0;\n  return new o({\n    requestId: d,\n    signData: i,\n    derivationPath: a,\n    address: r,\n    origin: s[n.origin] ? s[n.origin] : void 0,\n    signType: s[n.signType]\n  });\n}, o.fromCBOR = t => {\n  const e = i(t);\n  return o.fromDataItem(e);\n};\nconst {\n  RegistryTypes: d,\n  decodeToDataItem: g\n} = t.extend;\nvar m;\n!function (t) {\n  t[t.requestId = 1] = \"requestId\", t[t.signature = 2] = \"signature\";\n}(m || (m = {}));\nclass h extends t.RegistryItem {\n  constructor(e, i) {\n    super(), this.getRegistryType = () => s.SOL_SIGNATURE, this.getRequestId = () => this.requestId, this.getSignature = () => this.signature, this.toDataItem = () => {\n      const e = {};\n      return this.requestId && (e[m.requestId] = new t.DataItem(this.requestId, d.UUID.getTag())), e[m.signature] = this.signature, new t.DataItem(e);\n    }, this.signature = e, this.requestId = i;\n  }\n}\nh.fromDataItem = t => {\n  const e = t.getData(),\n    s = e[m.signature],\n    i = e[m.requestId] ? e[m.requestId].getData() : void 0;\n  return new h(s, i);\n}, h.fromCBOR = t => {\n  const e = g(t);\n  return h.fromDataItem(e);\n};\nconst {\n  decodeToDataItem: u\n} = t.extend;\nvar c;\n!function (t) {\n  t[t.mintAddress = 1] = \"mintAddress\", t[t.collectionName = 2] = \"collectionName\", t[t.name = 3] = \"name\", t[t.mediaData = 4] = \"mediaData\";\n}(c || (c = {}));\nclass I extends t.RegistryItem {\n  constructor(e) {\n    super(), this.getRegistryType = () => s.SOL_NFT_ITEM, this.getName = () => this.name, this.getMediaData = () => this.mediaData, this.getMintAddress = () => this.mintAddress, this.getCollectionName = () => this.collectionName, this.toDataItem = () => {\n      const e = {};\n      return e[c.name] = this.name, e[c.mintAddress] = this.mintAddress, e[c.collectionName] = this.collectionName, e[c.mediaData] = this.mediaData, new t.DataItem(e);\n    }, this.name = e.name, this.mintAddress = e.mintAddress, this.collectionName = e.collectionName, this.mediaData = e.mediaData;\n  }\n  static constructETHNFTItem(t, e, s, i) {\n    return new I({\n      mintAddress: t,\n      collectionName: e,\n      mediaData: i,\n      name: s\n    });\n  }\n}\nI.fromDataItem = t => {\n  const e = t.getData();\n  return new I({\n    name: e[c.name],\n    mintAddress: e[c.mintAddress],\n    collectionName: e[c.collectionName],\n    mediaData: e[c.mediaData]\n  });\n}, I.fromCBOR = t => {\n  const e = u(t);\n  return I.fromDataItem(e);\n}, t.patchTags(Object.values(s).filter(t => !!t.getTag()).map(t => t.getTag())), Object.keys(t).forEach(function (e) {\n  \"default\" !== e && Object.defineProperty(exports, e, {\n    enumerable: !0,\n    get: function () {\n      return t[e];\n    }\n  });\n}), exports.SOLNFTItem = I, exports.SolSignRequest = o, exports.SolSignature = h;","map":{"version":3,"names":["s","SOL_SIGN_REQUEST","t","RegistryType","SOL_SIGNATURE","SOL_NFT_ITEM","decodeToDataItem","i","RegistryTypes","a","extend","r","n","exports","SignType","Transaction","Message","requestId","signData","derivationPath","address","origin","signType","o","RegistryItem","constructor","e","getRegistryType","getRequestId","getSignData","getDerivationPath","getPath","getSignRequestAddress","getOrigin","getSignType","toDataItem","DataItem","UUID","getTag","setTag","constructSOLRequest","d","g","m","replace","split","h","CryptoKeypath","map","parseInt","endsWith","PathComponent","index","hardened","Buffer","from","parse","fromDataItem","getData","fromCBOR","signature","getSignature","u","c","mintAddress","collectionName","name","mediaData","I","getName","getMediaData","getMintAddress","getCollectionName","constructETHNFTItem","patchTags","Object","values","filter","keys","forEach","defineProperty","enumerable","get","SOLNFTItem","SolSignRequest","SolSignature"],"sources":["C:\\Users\\Administrator\\solana-wallet-app\\node_modules\\@keystonehq\\bc-ur-registry-sol\\src\\RegistryType.ts","C:\\Users\\Administrator\\solana-wallet-app\\node_modules\\@keystonehq\\bc-ur-registry-sol\\src\\SolSignRequest.ts","C:\\Users\\Administrator\\solana-wallet-app\\node_modules\\@keystonehq\\bc-ur-registry-sol\\src\\SolSignature.ts","C:\\Users\\Administrator\\solana-wallet-app\\node_modules\\@keystonehq\\bc-ur-registry-sol\\src\\SOLNFTItem.ts","C:\\Users\\Administrator\\solana-wallet-app\\node_modules\\@keystonehq\\bc-ur-registry-sol\\src\\index.ts"],"sourcesContent":["import { RegistryType } from \"@keystonehq/bc-ur-registry\";\n\nexport const ExtendedRegistryTypes = {\n  SOL_SIGN_REQUEST: new RegistryType(\"sol-sign-request\", 1101),\n  SOL_SIGNATURE: new RegistryType(\"sol-signature\", 1102),\n  SOL_NFT_ITEM: new RegistryType(\"sol-nft-item\", 1104),\n};\n","import {\n  CryptoKeypath,\n  extend,\n  DataItem,\n  PathComponent,\n  RegistryItem,\n  DataItemMap,\n} from \"@keystonehq/bc-ur-registry\";\nimport { ExtendedRegistryTypes } from \"./RegistryType\";\nimport * as uuid from \"uuid\";\n\nconst { decodeToDataItem, RegistryTypes } = extend;\n\nexport enum SignType {\n  Transaction = 1,\n  Message = 2,\n}\n\nenum Keys {\n  requestId = 1,\n  signData,\n  derivationPath,\n  address,\n  origin,\n  signType ,\n}\n\ntype signRequestProps = {\n  requestId?: Buffer;\n  signData: Buffer;\n  derivationPath: CryptoKeypath;\n  address?: Buffer;\n  origin?: string;\n  signType: SignType;\n};\n\nexport class SolSignRequest extends RegistryItem {\n  private requestId?: Buffer;\n  private signData: Buffer;\n  private derivationPath: CryptoKeypath;\n  private address?: Buffer;\n  private origin?: string;\n  private signType: SignType;\n\n  getRegistryType = () => ExtendedRegistryTypes.SOL_SIGN_REQUEST;\n\n  constructor(args: signRequestProps) {\n    super();\n    this.requestId = args.requestId;\n    this.signData = args.signData;\n    this.derivationPath = args.derivationPath;\n    this.address = args.address;\n    this.origin = args.origin;\n    this.signType = args.signType;\n  }\n\n  public getRequestId = () => this.requestId;\n  public getSignData = () => this.signData;\n  public getDerivationPath = () => this.derivationPath.getPath();\n  public getSignRequestAddress = () => this.address;\n  public getOrigin = () => this.origin;\n  public getSignType = () => this.signType;\n\n  public toDataItem = () => {\n    const map: DataItemMap = {};\n    if (this.requestId) {\n      map[Keys.requestId] = new DataItem(\n        this.requestId,\n        RegistryTypes.UUID.getTag()\n      );\n    }\n    if (this.address) {\n      map[Keys.address] = this.address;\n    }\n\n    if (this.origin) {\n      map[Keys.origin] = this.origin;\n    }\n\n    map[Keys.signData] = this.signData;\n    map[Keys.signType] = this.signType;\n\n    const keyPath = this.derivationPath.toDataItem();\n    keyPath.setTag(this.derivationPath.getRegistryType().getTag());\n    map[Keys.derivationPath] = keyPath;\n\n    return new DataItem(map);\n  };\n\n  public static fromDataItem = (dataItem: DataItem) => {\n    const map = dataItem.getData();\n    const signData = map[Keys.signData];\n    const derivationPath = CryptoKeypath.fromDataItem(map[Keys.derivationPath]);\n    const address = map[Keys.address] ? map[Keys.address] : undefined;\n    const requestId = map[Keys.requestId]\n      ? map[Keys.requestId].getData()\n      : undefined;\n    const origin = map[Keys.origin] ? map[Keys.origin] : undefined;\n    const signType = map[Keys.signType];\n\n    return new SolSignRequest({\n      requestId,\n      signData,\n      derivationPath,\n      address,\n      origin,\n      signType\n    });\n  };\n\n  public static fromCBOR = (_cborPayload: Buffer) => {\n    const dataItem = decodeToDataItem(_cborPayload);\n    return SolSignRequest.fromDataItem(dataItem);\n  };\n\n  public static constructSOLRequest(\n    signData: Buffer,\n    hdPath: string,\n    xfp: string,\n    signType: SignType,\n    uuidString?: string,\n    address?: string,\n    origin?: string\n  ) {\n    const paths = hdPath.replace(/[m|M]\\//, \"\").split(\"/\");\n    const hdpathObject = new CryptoKeypath(\n      paths.map((path) => {\n        const index = parseInt(path.replace(\"'\", \"\"));\n        let isHardened = false;\n        if (path.endsWith(\"'\")) {\n          isHardened = true;\n        }\n        return new PathComponent({ index, hardened: isHardened });\n      }),\n      Buffer.from(xfp, \"hex\")\n    );\n\n    return new SolSignRequest({\n      requestId: uuidString\n        ? Buffer.from(uuid.parse(uuidString) as Uint8Array)\n        : undefined,\n      signData,\n      derivationPath: hdpathObject,\n      address: address\n        ? Buffer.from(address.replace(\"0x\", \"\"), \"hex\")\n        : undefined,\n      origin: origin || undefined,\n      signType,\n    });\n  }\n}\n","import {\n  extend,\n  DataItem,\n  RegistryItem,\n  DataItemMap,\n} from \"@keystonehq/bc-ur-registry\";\nimport { ExtendedRegistryTypes } from \"./RegistryType\";\n\nconst { RegistryTypes, decodeToDataItem } = extend;\n\nenum Keys {\n  requestId = 1,\n  signature,\n}\n\nexport class SolSignature extends RegistryItem {\n  private requestId?: Buffer;\n  private signature: Buffer;\n\n  getRegistryType = () => ExtendedRegistryTypes.SOL_SIGNATURE;\n\n  constructor(signature: Buffer, requestId?: Buffer) {\n    super();\n    this.signature = signature;\n    this.requestId = requestId;\n  }\n\n  public getRequestId = () => this.requestId;\n  public getSignature = () => this.signature;\n\n  public toDataItem = () => {\n    const map: DataItemMap = {};\n    if (this.requestId) {\n      map[Keys.requestId] = new DataItem(\n        this.requestId,\n        RegistryTypes.UUID.getTag()\n      );\n    }\n    map[Keys.signature] = this.signature;\n    return new DataItem(map);\n  };\n\n  public static fromDataItem = (dataItem: DataItem) => {\n    const map = dataItem.getData();\n    const signature = map[Keys.signature];\n    const requestId = map[Keys.requestId]\n      ? map[Keys.requestId].getData()\n      : undefined;\n\n    return new SolSignature(signature, requestId);\n  };\n\n  public static fromCBOR = (_cborPayload: Buffer) => {\n    const dataItem = decodeToDataItem(_cborPayload);\n    return SolSignature.fromDataItem(dataItem);\n  };\n}\n","import {\n  extend,\n  DataItem,\n  RegistryItem,\n  DataItemMap,\n} from \"@keystonehq/bc-ur-registry\";\nimport { ExtendedRegistryTypes } from \"./RegistryType\";\n\nconst { decodeToDataItem } = extend;\n\nenum Keys {\n  mintAddress = 1,\n  collectionName,\n  name,\n  mediaData,\n}\n\ntype NFTProps = {\n  mintAddress: string;\n  collectionName: string;\n  name: string;\n  mediaData: string;\n};\n\nexport class SOLNFTItem extends RegistryItem {\n  private name: string;\n  private mintAddress: string;\n  private collectionName: string;\n  private mediaData: string;\n\n  getRegistryType = () => ExtendedRegistryTypes.SOL_NFT_ITEM;\n\n  constructor(args: NFTProps) {\n    super();\n    this.name = args.name;\n    this.mintAddress = args.mintAddress;\n    this.collectionName = args.collectionName;\n    this.mediaData = args.mediaData; // remove the data perfix for android usage\n  }\n\n  public getName = () => this.name;\n  public getMediaData = () => this.mediaData;\n  public getMintAddress = () => this.mintAddress;\n  public getCollectionName = () => this.collectionName;\n\n  public toDataItem = () => {\n    const map: DataItemMap = {};\n    map[Keys.name] = this.name;\n    map[Keys.mintAddress] = this.mintAddress;\n    map[Keys.collectionName] = this.collectionName;\n    map[Keys.mediaData] = this.mediaData;\n\n    return new DataItem(map);\n  };\n\n  public static fromDataItem = (dataItem: DataItem) => {\n    const map = dataItem.getData();\n    const name = map[Keys.name];\n    const mediaData = map[Keys.mediaData];\n    const mintAddress = map[Keys.mintAddress];\n    const collectionName = map[Keys.collectionName];\n\n    return new SOLNFTItem({\n      name,\n      mintAddress,\n      collectionName,\n      mediaData,\n    });\n  };\n\n  public static fromCBOR = (_cborPayload: Buffer) => {\n    const dataItem = decodeToDataItem(_cborPayload);\n    return SOLNFTItem.fromDataItem(dataItem);\n  };\n\n  public static constructETHNFTItem(\n    mintAddress: string,\n    collectionName: string,\n    name: string,\n    mediaData: string\n  ) {\n    return new SOLNFTItem({\n      mintAddress,\n      collectionName,\n      mediaData,\n      name,\n    });\n  }\n}\n","import { patchTags } from \"@keystonehq/bc-ur-registry\";\nimport { ExtendedRegistryTypes } from \"./RegistryType\";\nexport * from \"@keystonehq/bc-ur-registry\";\n\npatchTags(\n  Object.values(ExtendedRegistryTypes)\n    .filter((rt) => !!rt.getTag())\n    .map((rt) => rt.getTag()) as number[]\n);\n\nexport { SolSignRequest, SignType } from \"./SolSignRequest\";\nexport { SolSignature } from \"./SolSignature\";\nexport { SOLNFTItem } from \"./SOLNFTItem\";\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}